# Task #17 - disk_controller_type

## Summary

Implemented `disk_controller_type` as an optional, computed field in `properties.storageProfile.diskControllerType`. The field validates enum values (NVMe, SCSI) and is updatable without ForceNew (though Azure requires VM deallocation for updates, which is a runtime concern outside Terraform's scope).

## Shadow Implementation

```hcl
# variables.tf
variable "disk_controller_type" {
  type        = string
  default     = null
  description = "(Optional) Specifies the Disk Controller Type used for this Virtual Machine. Possible values are `SCSI` and `NVMe`."

  validation {                                                                  # <-
    condition = var.disk_controller_type == null || contains([                  # <-
      "NVMe",                                                                    # <-
      "SCSI"                                                                     # <-
    ], var.disk_controller_type)                                                # <-
    error_message = "The disk_controller_type must be either 'NVMe' or 'SCSI'." # <-
  }                                                                              # <-
}

# migrate_main.tf
locals {
  body = {
    properties = merge(
      {
        hardwareProfile = {
          vmSize = var.size
        }
      },
      {
        networkProfile = {
          networkInterfaces = [
            for i, nic_id in var.network_interface_ids : {
              id = nic_id
              properties = {
                primary = i == 0
              }
            }
          ]
        }
      },
      {                                                                           # <-
        storageProfile = merge(                                                   # <-
          var.disk_controller_type != null ? {                                    # <-
            diskControllerType = var.disk_controller_type                         # <-
          } : {}                                                                   # <-
        )                                                                          # <-
      },                                                                           # <-
      # ... rest of merges
    )
  }
}
```

## Create Phase Verification

**Pattern**: Single-phase operation

**Query Result**: From `resourceWindowsVirtualMachineCreate`:

```go
if diskControllerType, ok := d.GetOk("disk_controller_type"); ok {
    params.Properties.StorageProfile.DiskControllerType = pointer.To(virtualmachines.DiskControllerTypes(diskControllerType.(string)))
}

// ...

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Phase Classification**: The field is set on the `params` object before the primary `CreateOrUpdateThenPoll` call, so it's part of the Create phase.

**Decision**: Add to `local.body.properties.storageProfile.diskControllerType`

## Assignment Path Verification

**Predicted Path**: `properties.storageProfile.diskControllerType`

**Go Code Evidence**:

```go
// From Create method
params := virtualmachines.VirtualMachine{
    Properties: &virtualmachines.VirtualMachineProperties{
        StorageProfile: &virtualmachines.StorageProfile{
            DataDisks: &[]virtualmachines.DataDisk{},
        },
    },
}

// Later in the Create method
if diskControllerType, ok := d.GetOk("disk_controller_type"); ok {
    params.Properties.StorageProfile.DiskControllerType = pointer.To(virtualmachines.DiskControllerTypes(diskControllerType.(string)))
}
```

The assignment is: `params.Properties.StorageProfile.DiskControllerType`

**Trace**:
1. `params` is of type `virtualmachines.VirtualMachine`
2. `.Properties` is of type `*virtualmachines.VirtualMachineProperties`
3. `.StorageProfile` is of type `*virtualmachines.StorageProfile`
4. `.DiskControllerType` is the field being set

**Verified Path**: `properties.storageProfile.diskControllerType`

**Path Comparison**: ✅ Match - predicted path matches verified path

## Provider Schema

```go
"disk_controller_type": {
    Type:     pluginsdk.TypeString,
    Optional: true,
    Computed: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachines.DiskControllerTypesNVMe),
        string(virtualmachines.DiskControllerTypesSCSI),
    }, false),
},
```

**Field Properties**:
- Type: String
- Optional: true
- Computed: true (Azure may return a default value)
- ForceNew: false (NOT a ForceNew field)
- ValidateFunc: StringInSlice with values "NVMe" and "SCSI"
- DiffSuppressFunc: None

## Azure API Schema

From `query_azapi_resource_schema` for `Microsoft.Compute/virtualMachines@2024-03-01`:

```
"storageProfile":ObjectWithOptionalAttrs(map[string]Type{
    "diskControllerType":String,
    // ... other fields
}, []string{"dataDisks", "diskControllerType", "imageReference", "osDisk"})
```

**Property Path**: `properties.storageProfile.diskControllerType`

**Type**: String (all fields optional in storageProfile)

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| disk_controller_type   | diskControllerType   |

## Special Handling

### 1. Validation

**Provider Validation**: `validation.StringInSlice([]string{"NVMe", "SCSI"}, false)`

**Implementation**: Added validation block in `variables.tf`:

```hcl
validation {
  condition = var.disk_controller_type == null || contains([
    "NVMe",
    "SCSI"
  ], var.disk_controller_type)
  error_message = "The disk_controller_type must be either 'NVMe' or 'SCSI'."
}
```

**Rationale**: The provider validates enum values at plan time. We must replicate this validation to provide the same user experience with AzAPI.

### 2. ForceNew Analysis

**Schema Declaration**: `ForceNew: false` (field is NOT marked as ForceNew)

**CustomizeDiff Check**: No CustomizeDiff function in the resource definition - the resource function shows:

```go
resource := &pluginsdk.Resource{
    Create: resourceWindowsVirtualMachineCreate,
    Read:   resourceWindowsVirtualMachineRead,
    Update: resourceWindowsVirtualMachineUpdate,
    Delete: resourceWindowsVirtualMachineDelete,
    // No CustomizeDiff defined
}
```

**Update Behavior**: From `resourceWindowsVirtualMachineUpdate`:

```go
if d.HasChange("disk_controller_type") {
    shouldUpdate = true
    shouldDeallocate = true

    if update.Properties.StorageProfile == nil {
        update.Properties.StorageProfile = &virtualmachines.StorageProfile{}
    }

    update.Properties.StorageProfile.DiskControllerType = pointer.To(virtualmachines.DiskControllerTypes(d.Get("disk_controller_type").(string)))
}
```

**Analysis**: 
- The field is updatable (`d.HasChange` triggers an update)
- Update requires VM deallocation (`shouldDeallocate = true`)
- However, this is NOT a ForceNew field - the provider attempts to update in-place
- The deallocation is a runtime operation (Azure API requirement), not a Terraform state requirement
- With azapi_resource, users would need to manually deallocate the VM before applying changes to this field

**Decision**: Do NOT add to `replace_triggers_external_values` because:
1. The field is explicitly NOT ForceNew in the schema
2. The provider supports updates (doesn't force recreation)
3. The deallocation requirement is an Azure API runtime constraint, not a Terraform lifecycle constraint
4. Users can update this field without recreating the VM if they deallocate first

### 3. Computed Field

**Computed: true** - Azure may return a default value if not specified.

**Implementation**: The field is optional in the Terraform schema with `default = null`. When null, it's omitted from the body, allowing Azure to use its default.

## Deferred Work Completion

No work was deferred to this task in `following.md`.

## Edge Case Analysis

### Null Semantics

- **null**: Omit from API request body, Azure uses default disk controller type
- **"NVMe"**: Explicitly set to NVMe
- **"SCSI"**: Explicitly set to SCSI

### Boundary Conditions

1. **Empty string**: Rejected by validation (not in allowed list)
2. **Case sensitivity**: Provider validation is case-sensitive (false parameter to StringInSlice), so "nvme" or "scsi" would be rejected
3. **Invalid values**: Rejected by validation at plan time

### Idempotency

✅ Idempotent - Value is used directly, no transformations or ordering dependencies.

### Safe References

✅ Safe - Direct variable reference with null check in conditional:
```hcl
var.disk_controller_type != null ? {
  diskControllerType = var.disk_controller_type
} : {}
```

### Update Semantics

The field can be updated, but Azure requires the VM to be in a deallocated state. With azapi_resource:
- Terraform will detect the change and attempt to update
- The API call may fail if the VM is not deallocated
- Users must manually deallocate the VM before applying updates to this field
- This is consistent with other fields that require deallocation (the deallocation is a runtime concern, not a ForceNew concern)

## Checklist

- ✅ Property in correct local (`body.properties.storageProfile`)
- ✅ ForceNew NOT needed (field is updatable, deallocation is runtime concern)
- ✅ All logic EXACTLY replicated from provider (validation matches StringInSlice)
- ✅ Validations IMPLEMENTED in variables.tf (enum validation added)
- ✅ Hidden fields checked (none for this field)
- ✅ Deferred work in following.md: None to defer
- ✅ Deferred work from following.md: None deferred to this task
- ✅ Critical review (null, edge, idempotent, safe refs) - documented in Edge Case Analysis
- ✅ Edge Case Analysis in proof
- ✅ Proof created
- ✅ Self-Review: Only added disk_controller_type field implementation

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #17 - disk_controller_type

### Validation Results

✅ **ForceNew Logic:** Correctly determined NOT ForceNew (schema shows `ForceNew: false`, no CustomizeDiff logic)
✅ **Stable Keys:** Not applicable (field not in replace_triggers_external_values)
✅ **Phase Detection:** Field correctly placed in `local.body.properties.storageProfile` (Create phase)
✅ **Type Conversion:** Correct conversion from Terraform `string` to Azure API `string` (diskControllerType)
✅ **Null Handling:** Correctly propagates null semantics (null = omit from body, Azure uses default)
✅ **Validations:** Provider `StringInSlice` validation exactly replicated in variables.tf with correct enum values ("NVMe", "SCSI")
✅ **Deferred Work Completion:** No deferred work for this task (verified following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, case sensitivity, invalid values, update behavior)
✅ **Shared Path Merge:** No duplicate keys - `storageProfile` appears only once in merge (nested merge correctly used)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The validation matches the provider's `StringInSlice` function with correct enum values. The field is correctly determined to be updatable (not ForceNew) even though Azure requires VM deallocation - this is a runtime API concern, not a Terraform lifecycle concern. The field is properly placed in the Create phase body structure with correct nested merge for the shared `storageProfile` path. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
