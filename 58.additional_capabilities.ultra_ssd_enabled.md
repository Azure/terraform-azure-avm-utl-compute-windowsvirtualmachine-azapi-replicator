# Task #58 - additional_capabilities.ultra_ssd_enabled

## Shadow Implementation

```hcl
# variables.tf
variable "additional_capabilities" {  # <-
  type = object({  # <-
    hibernation_enabled = optional(bool, false)  # <-
    ultra_ssd_enabled   = optional(bool, false)  # <-
  })  # <-
  default     = null  # <-
  description = <<-EOT  # <-
 - `hibernation_enabled` - (Optional) Whether to enable the hibernation capability or not.  # <-
 - `ultra_ssd_enabled` - (Optional) Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.  # <-
EOT  # <-
}  # <-

# migrate_main.tf
locals {  # <-
  body = merge(  # <-
    {  # <-
      properties = merge(  # <-
        # ... other properties ...  # <-
        var.additional_capabilities != null ? {  # <-
          additionalCapabilities = {  # <-
            hibernationEnabled = var.additional_capabilities.hibernation_enabled  # <-
            ultraSSDEnabled    = var.additional_capabilities.ultra_ssd_enabled  # <-
          }  # <-
        } : {},  # <-
        # ... other properties ...  # <-
      )  # <-
    }  # <-
  )  # <-
}  # <-
```

## Summary

Implemented the `ultra_ssd_enabled` argument within the `additional_capabilities` block. The field is mapped to `properties.additionalCapabilities.ultraSSDEnabled` in the Azure API and has a default value of `false` applied using Terraform's `optional(bool, false)` syntax.

## Create Phase Verification

**Pattern:** Single-phase creation (field processed during primary Create operation)

**Evidence from Create method:**

```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...

	additionalCapabilitiesRaw := d.Get("additional_capabilities").([]interface{})
	additionalCapabilities := expandVirtualMachineAdditionalCapabilities(additionalCapabilitiesRaw)

	// ... other code ...

	params := virtualmachines.VirtualMachine{
		Properties: &virtualmachines.VirtualMachineProperties{
			// Optional
			AdditionalCapabilities: additionalCapabilities,
			// ... other properties ...
		},
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
}
```

**Classification:** The `additionalCapabilities` field is expanded and assigned to `params.Properties.AdditionalCapabilities` BEFORE the primary `CreateOrUpdateThenPoll` operation. This is a **Create phase** field.

**Decision:** Implement in `local.body.properties.additionalCapabilities.ultraSSDEnabled` (not in post-creation operations).

## Assignment Path Verification

**Predicted Path:** `properties.additionalCapabilities.ultraSSDEnabled`

**Go Code Evidence from Expand Function:**

From the Task #56 proof document, the expand function shows:

```go
func expandVirtualMachineAdditionalCapabilities(input []interface{}) *virtualmachines.AdditionalCapabilities {
	capabilities := virtualmachines.AdditionalCapabilities{}

	if len(input) > 0 {
		raw := input[0].(map[string]interface{})

		capabilities.UltraSSDEnabled = pointer.To(raw["ultra_ssd_enabled"].(bool))

		capabilities.HibernationEnabled = pointer.To(raw["hibernation_enabled"].(bool))
	}

	return &capabilities
}
```

The struct assignment from Create method:
```go
params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		AdditionalCapabilities: additionalCapabilities,
	},
}
```

**Path Trace:**
1. `params.Properties = &virtualmachines.VirtualMachineProperties{...}` - adds `properties` nesting
2. `AdditionalCapabilities: additionalCapabilities` - assigns to the `additionalCapabilities` field
3. Within `additionalCapabilities` struct: `UltraSSDEnabled: pointer.To(...)` - assigns to `ultraSSDEnabled` field

**Verified Path:** `properties.additionalCapabilities.ultraSSDEnabled`

**Path Comparison:** ✅ Match - predicted path matches actual path in API.

## Provider Schema

**Schema Definition:**

```go
func virtualMachineAdditionalCapabilitiesSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				// TODO: confirm this command

				// NOTE: requires registration to use:
				// $ az feature show --namespace Microsoft.Compute --name UltraSSDWithVMSS
				// $ az provider register -n Microsoft.Compute
				"ultra_ssd_enabled": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  false,
				},

				"hibernation_enabled": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  false,
				},
			},
		},
	}
}
```

**Key Attributes:**
- **Type:** Bool
- **Optional:** true
- **Default:** false
- **ForceNew:** false (not specified, so updates are allowed)
- **No DiffSuppressFunc**
- **No Validations**
- **No ConflictsWith/RequiredWith**

## Azure API Schema

**Resource Path:** `properties.additionalCapabilities.ultraSSDEnabled`

**Schema Type:** Bool (optional)

**Azure API Documentation:**
```json
{
  "ultraSSDEnabled": "The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled."
}
```

## Hidden Fields

**Expand Function Analysis:**

The expand function `expandVirtualMachineAdditionalCapabilities` was already analyzed in Task #56. It shows no hidden fields related to `ultra_ssd_enabled` - the field is directly mapped from input to the struct field.

**Result:** ✅ No hidden fields found for `ultra_ssd_enabled`.

## Mapping

**Terraform to Azure API:**
- `additional_capabilities.ultra_ssd_enabled` (bool) → `properties.additionalCapabilities.ultraSSDEnabled` (bool)

**Naming Convention:** snake_case → camelCase (with proper capitalization: `SSD` remains uppercase)

## Special Handling

### Default Value Implementation

**Provider Behavior:** The provider schema defines `Default: false` for the field.

**Implementation:** Used Terraform's `optional(bool, false)` syntax in the object type definition:
```hcl
variable "additional_capabilities" {
  type = object({
    hibernation_enabled = optional(bool, false)
    ultra_ssd_enabled   = optional(bool, false)
  })
  default = null
}
```

This ensures that when the `additional_capabilities` block is set but `ultra_ssd_enabled` is not explicitly specified, the value defaults to `false`, exactly matching the provider behavior.

### No ForceNew Required

The field does not have `ForceNew: true` in the provider schema, and there is no CustomizeDiff logic affecting it. Therefore, no entry in `replace_triggers_external_values` is needed.

### No Sensitive Fields

The field is not marked as Sensitive in the provider schema.

### No Validations

The provider schema has no validation functions for this field. No validation blocks are required in `variables.tf`.

### No DiffSuppressFunc

The field has no `DiffSuppressFunc` in the provider schema, so standard comparison logic applies.

## Deferred Work Completion

**Check following.md:** No work was deferred to Task #58.

**Deferred FROM this task:** None - this is a simple boolean field with no cross-field dependencies.

## Edge Case Analysis

### Null Semantics

- **`var.additional_capabilities == null`:** The entire `additionalCapabilities` object is omitted from the API request. The field is not sent to Azure.
- **`var.additional_capabilities != null` but `ultra_ssd_enabled` not set:** The `optional(bool, false)` ensures the value is `false`. The field is sent to Azure with value `false`.
- **`var.additional_capabilities.ultra_ssd_enabled = true`:** The field is sent to Azure with value `true`.

This exactly matches the provider behavior where the default is `false` when the block exists.

### Idempotency

- The field value is directly passed without transformation
- The boolean value is stable and deterministic
- No order-dependent operations
- Repeated applies with same input produce identical output

### Safe References

- The parent condition `var.additional_capabilities != null` is checked before accessing the block
- The field access `var.additional_capabilities.ultra_ssd_enabled` is safe because the parent null check ensures the object exists
- The `optional(bool, false)` ensures the field always has a value when the parent object exists

### Boundary Conditions

- **`false` value:** Explicitly sent to Azure, disabling UltraSSD capability
- **`true` value:** Explicitly sent to Azure, enabling UltraSSD capability (allows data disks with `UltraSSD_LRS` storage account type)
- **Default behavior:** When block exists but field not specified, defaults to `false` (matches provider)

## Critical Review

### Exact Provider Replication

✅ **Default Value:** The `optional(bool, false)` syntax exactly replicates the provider's `Default: false` behavior.

✅ **Type:** Bool type matches provider schema.

✅ **Optionality:** Field is optional within the block, matching provider schema.

✅ **No Transformations:** Value is passed directly without any conditional logic or transformations, exactly as the provider's expand function does with `pointer.To(raw["ultra_ssd_enabled"].(bool))`.

✅ **API Path:** Field is placed at correct API path `properties.additionalCapabilities.ultraSSDEnabled`.

✅ **Naming Convention:** Correctly preserves uppercase `SSD` in camelCase conversion: `ultra_ssd_enabled` → `ultraSSDEnabled`.

### Implementation Verification

The implementation:
1. ✅ Adds default value using `optional(bool, false)` in variable definition
2. ✅ Maps field directly: `ultraSSDEnabled = var.additional_capabilities.ultra_ssd_enabled`
3. ✅ Places field within parent conditional: `var.additional_capabilities != null ? {...} : {}`
4. ✅ Uses correct camelCase naming with uppercase preservation: `ultraSSDEnabled`

This exactly matches the provider's expand function logic which always sets the field (with a boolean value) when the parent block exists.

## Checklist

- ✅ Property in correct local (`local.body.properties.additionalCapabilities.ultraSSDEnabled`)
- ✅ Default value replicated using `optional(bool, false)`
- ✅ No ForceNew required (field is not ForceNew in provider)
- ✅ No validations required (none in provider schema)
- ✅ No DiffSuppressFunc (none in provider schema)
- ✅ Hidden fields checked (none found)
- ✅ No deferred work to complete (checked following.md)
- ✅ No deferred work from this task (simple field, no dependencies)
- ✅ Critical review completed (null semantics, idempotency, safe references)
- ✅ Edge Case Analysis included
- ✅ Proof document created
- ✅ track.md ready to be updated to "Pending for check"
- ✅ Self-review: Only `ultra_ssd_enabled` field implemented, completing the `additional_capabilities` block implementation
- ✅ Implementation exactly replicates provider behavior with no deviations

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #58 - additional_capabilities.ultra_ssd_enabled

### Validation Results

✅ **ForceNew Logic:** No ForceNew required (field does not have ForceNew: true in provider schema, no CustomizeDiff logic)
✅ **Stable Keys:** N/A - no entries in `replace_triggers_external_values` needed
✅ **Phase Detection:** Field correctly placed in `local.body.properties.additionalCapabilities` (Create phase)
✅ **Type Conversion:** Direct bool to bool mapping, no conversion needed
✅ **Null Handling:** Correctly propagates null semantics - parent block conditional prevents field emission when null
✅ **Default Value Method:** Uses PREFERRED method `optional(bool, false)` in object type definition (executor.md lines 145-149)
✅ **Naming Convention:** Correct camelCase conversion with uppercase preservation: `ultra_ssd_enabled` → `ultraSSDEnabled`
✅ **Validations:** None required (provider schema has no validations for this field)
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Deferred Work Recording:** No deferrals made (simple field with no cross-field dependencies)
✅ **Shared Path Merge Check:** `additionalCapabilities` key appears only ONCE in merge (lines 252-257) - no conflicts
✅ **Edge Cases:** Properly analyzed - null semantics, idempotency, safe references, boundary conditions all handled correctly

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The executor correctly:

1. **Used preferred default value method:** `optional(bool, false)` in the object type definition instead of fallback coalesce() in locals
2. **Correct API path:** `properties.additionalCapabilities.ultraSSDEnabled` matches provider expand function
3. **Correct naming convention:** Preserved uppercase `SSD` in camelCase conversion
4. **Direct value mapping:** `ultraSSDEnabled = var.additional_capabilities.ultra_ssd_enabled` exactly matches provider's `UltraSSDEnabled: pointer.To(raw["ultra_ssd_enabled"].(bool))`
5. **No unnecessary logic:** Did not add ForceNew, validations, or other logic not present in provider schema
6. **Complete documentation:** Proof document includes all required sections with proper evidence

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
