# Task #18: edge_zone - Implementation Proof

## Summary

Successfully migrated the `edge_zone` root-level argument from `azurerm_windows_virtual_machine` to `azapi_resource`. This field specifies the Edge Zone within the Azure Region where the Virtual Machine should exist. The implementation includes DiffSuppressFunc logic for normalized case-insensitive comparison, StateFunc normalization, ForceNew behavior, and proper mapping to the Azure API's `extendedLocation` object.

## Create Phase Verification

### Pattern Classification
**Single-Phase Pattern**: The `edge_zone` field is set during the primary `CreateOrUpdateThenPoll` operation.

### Evidence from Create Method

```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Compute.VirtualMachinesClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id := virtualmachines.NewVirtualMachineID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
	
	// ... other setup code ...
	
	params := virtualmachines.VirtualMachine{
		Name:             pointer.To(id.VirtualMachineName),
		ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)), // <- edge_zone assigned here
		Location:         location.Normalize(d.Get("location").(string)),
		Identity:         identityExpanded,
		Plan:             plan,
		Properties: &virtualmachines.VirtualMachineProperties{
			// ... properties ...
		},
		Tags: tags.Expand(t),
	}
	
	// ... rest of creation logic ...
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
}
```

**Field Classification**: The `edge_zone` field is assigned to `params.ExtendedLocation` via `expandEdgeZone()` BEFORE the primary `CreateOrUpdateThenPoll` call.

**Decision**: Belongs in `local.body` (main request body), NOT a post-creation operation.

## Assignment Path Verification

### Predicted Path
Based on the Create method, the predicted path is:
- Terraform field: `edge_zone`
- Azure API path: `extendedLocation.name` (at root level, not in `properties`)

### Go Code Evidence - expandEdgeZone Function

```go
func expandEdgeZone(input string) *edgezones.Model {
	normalized := edgezones.Normalize(input)
	if normalized == "" {
		return nil
	}

	return &edgezones.Model{
		Name: normalized,
	}
}
```

**Assignment tracing**:
1. `expandEdgeZone(d.Get("edge_zone").(string))` returns `*edgezones.Model` or `nil`
2. The `edgezones.Model` type is:
```go
type Model struct {
	Name string
}
```
3. The returned value is assigned to `params.ExtendedLocation` (root level)
4. The Azure API expects `extendedLocation.name` and `extendedLocation.type`

### Go Code Evidence - Normalization Logic

The `edgezones.Normalize` function performs location normalization:

```go
func Normalize(input string) string {
	// we're intentionally passing through to Locations today since this is sufficient
	// but it's helpful to have a specific endpoint for this should this need to change
	// in the future
	return location.Normalize(input)
}
```

Where `location.Normalize` removes spaces and converts to lowercase:
```go
func Normalize(input string) string {
	return replace(lower(input), " ", "")
}
```

### Verified Path
- **TF Field**: `edge_zone` → **API Field**: `extendedLocation.name` (root level)
- **Additional API Field**: `extendedLocation.type` is hardcoded to `"EdgeZone"`

**Path Comparison**: ✅ Match - The predicted path matches the verified path from Go code evidence.

## Provider Schema

### Schema Definition

```go
"edge_zone": commonschema.EdgeZoneOptionalForceNew(),
```

Where `EdgeZoneOptionalForceNew()` is defined as:

```go
func EdgeZoneOptionalForceNew() *schema.Schema {
	return &schema.Schema{
		Type:             schema.TypeString,
		Optional:         true,
		ForceNew:         true,
		ValidateFunc:     validation.StringIsNotEmpty,
		StateFunc:        edgezones.StateFunc,
		DiffSuppressFunc: edgezones.DiffSuppressFunc,
	}
}
```

**Key Properties**:
- **Type**: `TypeString`
- **Optional**: `true`
- **ForceNew**: `true` - Changes force new resource creation
- **ValidateFunc**: `validation.StringIsNotEmpty` - Value must not be empty if provided
- **StateFunc**: `edgezones.StateFunc` - Normalizes value before storing in state
- **DiffSuppressFunc**: `edgezones.DiffSuppressFunc` - Suppresses diffs when normalized values match

### StateFunc Implementation

```go
func StateFunc(location interface{}) string {
	input := location.(string)
	return Normalize(input)
}
```

This normalizes the input by removing spaces and converting to lowercase before storing in state.

### DiffSuppressFunc Implementation

```go
func DiffSuppressFunc(_, old, new string, _ *schema.ResourceData) bool {
	return Normalize(old) == Normalize(new)
}
```

This suppresses differences when both values normalize to the same string (case-insensitive, space-insensitive).

## Azure API Schema

### API Field Location and Type

From Azure API documentation for `Microsoft.Compute/virtualMachines@2024-03-01`:

```
"extendedLocation": {
  "name": "The name of the extended location.",
  "type": "The type of the extended location. (Possible values: EdgeZone)"
}
```

**Property Path**: `extendedLocation` (root level, NOT in `properties`)
**Schema**:
- `extendedLocation.name`: String - The name of the edge zone
- `extendedLocation.type`: String - Must be "EdgeZone"

## Mapping

| Terraform Field | Go Type | Azure API Field | Azure Type |
|----------------|---------|-----------------|------------|
| `edge_zone` | `string` | `extendedLocation.name` | `String` |
| (hardcoded) | - | `extendedLocation.type` | `String` ("EdgeZone") |

**Naming Convention**: 
- Terraform: `edge_zone` (snake_case)
- Azure API: `extendedLocation.name` (camelCase) + `extendedLocation.type`

## Special Handling

### 1. DiffSuppressFunc - Normalized Comparison

The provider uses `DiffSuppressFunc` to suppress diffs when normalized values match:

```go
func DiffSuppressFunc(_, old, new string, _ *schema.ResourceData) bool {
	return Normalize(old) == Normalize(new)
}
```

**Implementation in Terraform**:

```hcl
locals {
  should_read_existing_edge_zone = var.edge_zone != null
  
  existing_edge_zone = local.should_read_existing_edge_zone && data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.extendedLocation.name, null) : null
  
  edge_zone_normalized = var.edge_zone != null ? replace(lower(var.edge_zone), " ", "") : null
  
  desired_edge_zone = local.edge_zone_normalized
  
  edge_zone_should_suppress = (
    local.existing_edge_zone != null && 
    local.desired_edge_zone != null && 
    replace(lower(local.existing_edge_zone), " ", "") == local.desired_edge_zone
  )
  
  effective_edge_zone = local.edge_zone_should_suppress ? coalesce(local.existing_edge_zone, local.desired_edge_zone) : local.desired_edge_zone
}
```

**Behavior**:
- Normalizes input by removing spaces and converting to lowercase
- Reads existing edge zone value from state
- Compares normalized values
- If normalized values match, uses existing value (suppresses diff)
- If normalized values differ, uses new value (shows diff)

### 2. StateFunc - Value Normalization

The provider applies normalization via `StateFunc` before storing in state:

```go
func StateFunc(location interface{}) string {
	input := location.(string)
	return Normalize(input)
}
```

**Implementation**: The `edge_zone_normalized` local applies the same normalization logic:

```hcl
edge_zone_normalized = var.edge_zone != null ? replace(lower(var.edge_zone), " ", "") : null
```

### 3. ForceNew Behavior

**Provider Schema**: `ForceNew: true`

**Implementation in `replace_triggers_external_values`**:

```hcl
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    edge_zone = { value = local.edge_zone_normalized }
  }
}
```

**Behavior**: Tracks the normalized value. When `edge_zone` changes, Terraform forces resource replacement.

### 4. Validation

**Provider Validation**: `validation.StringIsNotEmpty`

**Implementation in `variables.tf`**:

```hcl
variable "edge_zone" {
  type        = string
  default     = null
  description = "(Optional) Specifies the Edge Zone within the Azure Region where this Windows Virtual Machine should exist. Changing this forces a new Windows Virtual Machine to be created."

  validation {
    condition     = var.edge_zone == null || var.edge_zone != ""
    error_message = "The edge_zone must not be empty."
  }
}
```

### 5. Conditional Inclusion in Body

The `extendedLocation` object is only included when `edge_zone` is provided:

```hcl
body = merge(
  {
    properties = { /* ... */ }
  },
  local.effective_edge_zone != null ? {
    extendedLocation = {
      name = local.effective_edge_zone
      type = "EdgeZone"
    }
  } : {}
)
```

**Behavior**: 
- When `edge_zone` is `null`, `extendedLocation` is not included in the request body
- When `edge_zone` is provided, `extendedLocation` is included with `name` and `type` fields
- The `type` field is hardcoded to `"EdgeZone"` per Azure API requirements

## Shadow Implementation

```hcl
# In variables.tf
variable "edge_zone" {
  type        = string
  default     = null
  description = "(Optional) Specifies the Edge Zone within the Azure Region where this Windows Virtual Machine should exist. Changing this forces a new Windows Virtual Machine to be created."

  validation {
    condition     = var.edge_zone == null || var.edge_zone != ""  # <-
    error_message = "The edge_zone must not be empty."
  }
}

# In migrate_main.tf
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    edge_zone = { value = local.edge_zone_normalized }  # <-
  }
  
  should_read_existing_edge_zone = var.edge_zone != null  # <-
  
  existing_edge_zone = local.should_read_existing_edge_zone && data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.extendedLocation.name, null) : null  # <-
  
  edge_zone_normalized = var.edge_zone != null ? replace(lower(var.edge_zone), " ", "") : null  # <-
  
  desired_edge_zone = local.edge_zone_normalized  # <-
  
  edge_zone_should_suppress = (  # <-
    local.existing_edge_zone != null && 
    local.desired_edge_zone != null && 
    replace(lower(local.existing_edge_zone), " ", "") == local.desired_edge_zone
  )
  
  effective_edge_zone = local.edge_zone_should_suppress ? coalesce(local.existing_edge_zone, local.desired_edge_zone) : local.desired_edge_zone  # <-
  
  body = merge(
    {
      properties = {
        # ... properties ...
      }
    },
    local.effective_edge_zone != null ? {  # <-
      extendedLocation = {
        name = local.effective_edge_zone
        type = "EdgeZone"
      }
    } : {}
  )
}
```

## Critical Review & Edge Case Analysis

### Null Semantics
- **`null` input**: When `var.edge_zone` is `null`, no `extendedLocation` is added to the body, which is correct behavior for an optional field
- **Empty string**: The validation block prevents empty strings, ensuring only valid edge zone names are accepted
- **Normalized value**: The normalization happens before comparison and storage, ensuring consistent behavior

### Edge Cases

1. **Case Variations**: 
   - Input: `"East US 2"` vs `"eastus2"` vs `"EASTUS2"`
   - All normalize to: `"eastus2"`
   - DiffSuppressFunc ensures these are treated as equal
   - ✅ Handled correctly

2. **Space Variations**:
   - Input: `"East US 2"` vs `"EastUS2"` vs `"east us 2"`
   - All normalize to: `"eastus2"`
   - DiffSuppressFunc ensures these are treated as equal
   - ✅ Handled correctly

3. **Null to Non-Null**:
   - Existing: `null`, New: `"eastus2"`
   - DiffSuppressFunc condition: `existing_edge_zone != null` is false, no suppression
   - Uses desired value, forces replacement
   - ✅ Handled correctly

4. **Non-Null to Null**:
   - Existing: `"eastus2"`, New: `null`
   - DiffSuppressFunc condition: `desired_edge_zone != null` is false, no suppression
   - Uses desired value (null), removes `extendedLocation`, forces replacement
   - ✅ Handled correctly

5. **First Creation**:
   - No existing resource: `data.azapi_resource.existing.exists` is false
   - `existing_edge_zone` is `null`
   - DiffSuppressFunc condition: `existing_edge_zone != null` is false, no suppression
   - Uses desired value
   - ✅ Handled correctly

### Idempotency
- Same normalized input always produces same normalized output
- DiffSuppressFunc ensures case/space variations don't trigger unnecessary updates
- ForceNew behavior is deterministic based on normalized value changes
- ✅ Idempotent

### Safe References
- All accesses to `data.azapi_resource.existing` are guarded by `.exists` check
- `try()` with fallback to `null` prevents errors when field is missing
- Conditional reads (`should_read_existing_edge_zone`) prevent unnecessary data reads
- ✅ Safe

### DiffSuppressFunc Behavior Verification

**Scenario 1**: User sets `edge_zone = "East US 2"`, API returns `"eastus2"`
- Normalized input: `"eastus2"`
- Existing from API: `"eastus2"`
- Normalized existing: `"eastus2"`
- Suppression condition: `"eastus2" == "eastus2"` → true
- Result: Diff suppressed, uses existing value `"eastus2"` ✅

**Scenario 2**: User changes from `"eastus2"` to `"westus2"`
- Normalized input: `"westus2"`
- Existing from API: `"eastus2"`
- Normalized existing: `"eastus2"`
- Suppression condition: `"eastus2" == "westus2"` → false
- Result: Diff shown, uses new value `"westus2"`, forces replacement ✅

**Scenario 3**: User changes from `"East US 2"` to `"EAST US 2"`
- Normalized input: `"eastus2"`
- Existing from API: `"eastus2"`
- Normalized existing: `"eastus2"`
- Suppression condition: `"eastus2" == "eastus2"` → true
- Result: Diff suppressed, uses existing value ✅

## Deferred Work Completion

Checked `following.md` - No work was deferred to Task #18.

## Checklist

- ✅ Property in correct local (`body.extendedLocation`)
- ✅ ForceNew wrapped: `edge_zone = { value = local.edge_zone_normalized }`
- ✅ All logic EXACTLY replicated from provider (DiffSuppressFunc, StateFunc normalization)
- ✅ Validations IMPLEMENTED in variables.tf (non-empty string check)
- ✅ N/A - No sensitive field migration
- ✅ Hidden fields checked (hardcoded `type = "EdgeZone"`)
- ✅ No work deferred to other tasks
- ✅ No work deferred from other tasks
- ✅ Critical review complete (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created (18.edge_zone.md)
- ✅ `track.md` will be updated to Pending for check
- ✅ Self-Review: Only Task #18 content added, no overlap with other tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #18 - edge_zone

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew with normalized value tracking using wrapped object `{ value = local.edge_zone_normalized }`
✅ **DiffSuppressFunc Replication:** EXACT replication of provider's normalized comparison logic (lowercase, space removal)
✅ **StateFunc Replication:** EXACT replication of provider's normalization logic
✅ **Stable Keys:** Key `edge_zone` always present in `replace_triggers_external_values`
✅ **Phase Detection:** Field correctly placed in `local.body` at root level (not in properties)
✅ **Type Conversion:** Direct string-to-string mapping, no conversion needed
✅ **Null Handling:** Correctly propagates null semantics with conditional object inclusion
✅ **Validations:** Non-empty string validation correctly implemented in variables.tf
✅ **Hidden Fields:** Hardcoded `type = "EdgeZone"` correctly added per Azure API requirements
✅ **Placement:** `extendedLocation` correctly placed at root level (outside properties)
✅ **Safe References:** All data source accesses properly guarded with `.exists` checks
✅ **Deferred Work Completion:** No deferred work for this task (verified following.md)
✅ **Edge Cases:** All edge cases properly analyzed and handled (case variations, space variations, null transitions)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The DiffSuppressFunc logic performs normalized case-insensitive comparison, StateFunc normalization is correctly applied, ForceNew behavior tracks the normalized value, validation ensures non-empty strings, and the Azure API mapping correctly places `extendedLocation` at root level with both `name` and hardcoded `type` fields.

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
