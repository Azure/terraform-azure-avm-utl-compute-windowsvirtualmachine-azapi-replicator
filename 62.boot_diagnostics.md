# Task #62 - boot_diagnostics Block Structure Skeleton

## Summary

Created the conditional structure skeleton for the `boot_diagnostics` block. This block maps to Azure API's `properties.diagnosticsProfile.bootDiagnostics` object with one user-facing argument (`storage_account_uri` - Task #63) and one hidden field (`enabled` - computed based on block presence).

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... other fields ...
        var.boot_diagnostics != null ? {  # <-
          diagnosticsProfile = {  # <-
            bootDiagnostics = {  # <-
              # storage_account_uri = ... # Task #63  # <-
              # enabled = ... # Hidden field - computed based on block presence and storage_account_uri value  # <-
            }  # <-
          }  # <-
        } : {}  # <-
      )
    }
  )
}
```

## Provider Schema

From `bootDiagnosticsSchema()` in `internal/services/compute/shared_schema.go`:

```go
func bootDiagnosticsSchema() *pluginsdk.Schema {
	// lintignore:XS003
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				// TODO: should this be `storage_account_endpoint`?
				"storage_account_uri": {
					Type:     pluginsdk.TypeString,
					Optional: true,
					// TODO: validation
				},
			},
		},
	}
}
```

**Key Properties:**
- **Type:** `TypeList` (MaxItems: 1) - single block
- **Optional:** `true` - block is optional
- **Nested Fields:** Only `storage_account_uri` (Optional string)
- **No ForceNew:** Block does not have `ForceNew: true`

## Create Phase Verification

### Pattern Identification

Querying Create method to identify where `boot_diagnostics` is processed:

From `resourceWindowsVirtualMachineCreate()`:

```go
bootDiagnosticsRaw := d.Get("boot_diagnostics").([]interface{})
bootDiagnostics := expandBootDiagnostics(bootDiagnosticsRaw)

// ... later in params construction ...

params := virtualmachines.VirtualMachine{
	// ...
	Properties: &virtualmachines.VirtualMachineProperties{
		// ...
		DiagnosticsProfile:     bootDiagnostics,
		// ...
	},
}

// Single-phase operation: only CreateOrUpdateThenPoll is called
if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Pattern:** Single-phase - `boot_diagnostics` is processed in the primary `CreateOrUpdateThenPoll` operation only.

**Classification:** This block belongs in `local.body` during the Create phase.

## Assignment Path Verification

### Predicted Path
`properties.diagnosticsProfile.bootDiagnostics`

### Go Code Evidence

From Create method:
```go
params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		DiagnosticsProfile:     bootDiagnostics,  // ← Direct assignment to DiagnosticsProfile
	},
}
```

The `DiagnosticsProfile` field in `VirtualMachineProperties`:
```go
type VirtualMachineProperties struct {
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`
	// ...
}
```

The `DiagnosticsProfile` type structure:
```go
type DiagnosticsProfile struct {
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}
```

### Verified Path
`properties.diagnosticsProfile.bootDiagnostics`

### Path Comparison
✅ **Match:** Predicted path matches actual API structure.

## Azure API Schema

From Azure API schema query (`Microsoft.Compute/virtualMachines@2024-03-01`):

```
properties.diagnosticsProfile: ObjectWithOptionalAttrs(map[string]Type{
  "bootDiagnostics": ObjectWithOptionalAttrs(map[string]Type{
    "enabled": Bool,
    "storageUri": String
  }, []string{"enabled", "storageUri"})
}, []string{"bootDiagnostics"})
```

**Fields in Azure API:**
1. `enabled` (Bool) - Optional
2. `storageUri` (String) - Optional

**Mapping:**
- Terraform `storage_account_uri` → Azure API `storageUri`
- Hidden: `enabled` (Boolean) - not exposed in Terraform schema but computed by provider

## Hidden Fields Detection

### Analysis of expandBootDiagnostics Function

From `internal/services/compute/shared_schema.go`:

```go
func expandBootDiagnostics(input []interface{}) *virtualmachines.DiagnosticsProfile {
	if len(input) == 0 {
		return &virtualmachines.DiagnosticsProfile{
			BootDiagnostics: &virtualmachines.BootDiagnostics{
				Enabled:    pointer.To(false),  // ← Hidden field: false when block absent
				StorageUri: pointer.To(""),
			},
		}
	}

	// this serves the managed boot diagnostics, in this case we only have this empty block without `storage_account_uri` set
	if input[0] == nil {
		return &virtualmachines.DiagnosticsProfile{
			BootDiagnostics: &virtualmachines.BootDiagnostics{
				Enabled:    pointer.To(true),  // ← Hidden field: true when block present, storage_account_uri null
				StorageUri: pointer.To(""),
			},
		}
	}

	raw := input[0].(map[string]interface{})

	storageAccountUri := raw["storage_account_uri"].(string)

	return &virtualmachines.DiagnosticsProfile{
		BootDiagnostics: &virtualmachines.BootDiagnostics{
			Enabled:    pointer.To(true),  // ← Hidden field: true when block present with storage_account_uri
			StorageUri: pointer.To(storageAccountUri),
		},
	}
}
```

**Hidden Field Identified:**
- **Field:** `enabled` (Boolean)
- **Logic:**
  - `enabled = false` + `storageUri = ""` when `boot_diagnostics` block is **absent** (`len(input) == 0`)
  - `enabled = true` + `storageUri = ""` when `boot_diagnostics` block is **present but empty** (managed boot diagnostics)
  - `enabled = true` + `storageUri = <value>` when `boot_diagnostics.storage_account_uri` is **set**

**Special Behavior:**
This block supports **three distinct states**:
1. **Block absent:** Disables boot diagnostics entirely
2. **Block present, empty:** Enables managed boot diagnostics (stores to platform-managed storage)
3. **Block present, with URI:** Enables boot diagnostics with custom storage account

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `boot_diagnostics` | `properties.diagnosticsProfile.bootDiagnostics` | Conditional object presence |
| `boot_diagnostics.storage_account_uri` | `properties.diagnosticsProfile.bootDiagnostics.storageUri` | Task #63 |
| (hidden) | `properties.diagnosticsProfile.bootDiagnostics.enabled` | Computed: `false` when block absent, `true` when block present |

## Special Handling

### 1. Block Conditionality

The block is conditional based on `var.boot_diagnostics != null`. When the variable is `null`, the entire `diagnosticsProfile` structure must be included with `enabled = false` and `storageUri = ""` to explicitly disable boot diagnostics.

### 2. Hidden Field Logic (Implementation Deferred)

The `enabled` field has complex three-state logic that depends on:
- Whether the block is present
- Whether `storage_account_uri` is set

This logic will be implemented as a hidden field in the skeleton, with details handled by the `__check_root_hidden_fields__` task or child argument task.

### 3. No ForceNew

The block does not have `ForceNew: true`, meaning it can be updated in-place.

## Edge Case Analysis

### Null Semantics

1. **`var.boot_diagnostics == null`:**
   - Meaning: User did not specify the `boot_diagnostics` block
   - Action: Must send `enabled = false`, `storageUri = ""` to explicitly disable
   - Critical: Not sending anything would leave boot diagnostics in undefined state

2. **`var.boot_diagnostics != null` but `storage_account_uri == null`:**
   - Meaning: User specified empty block (managed boot diagnostics)
   - Action: Send `enabled = true`, `storageUri = ""`
   - Purpose: Enable platform-managed boot diagnostics

3. **`var.boot_diagnostics.storage_account_uri != null`:**
   - Meaning: User specified custom storage account
   - Action: Send `enabled = true`, `storageUri = <value>`
   - Purpose: Enable boot diagnostics with custom storage

### Idempotency

The three-state logic ensures idempotent behavior:
- Disabled → Disabled: No change
- Enabled (managed) → Enabled (managed): No change
- Enabled (custom) → Enabled (custom): No change (if URI unchanged)

### Safe References

All nested access uses safe checks:
- `var.boot_diagnostics != null` guards the entire block
- Child task will handle `storage_account_uri` safely

## Child Tasks

This skeleton establishes the structure for these child tasks:

| Task # | Path | Type | Notes |
|--------|------|------|-------|
| 63 | `boot_diagnostics.storage_account_uri` | Argument | Optional string; Azure API field: `storageUri` |

**Hidden Field Task:**
The `enabled` field is a hidden field that will be handled as part of the structure implementation. It does not have a separate task number as it's computed based on block presence and `storage_account_uri` value.

## Tasks Ready for Delegation

After creating this skeleton, the following child task is ready:

- **Task #63:** `boot_diagnostics.storage_account_uri` - Can now be implemented within the established skeleton structure

## Checklist

- ✅ Created conditional block skeleton with comment placeholders
- ✅ Verified path: `properties.diagnosticsProfile.bootDiagnostics`
- ✅ Identified hidden field: `enabled` (Boolean) with three-state logic
- ✅ Analyzed expand function for hidden field computation logic
- ✅ Documented three distinct states (absent/empty/with-uri)
- ✅ No ForceNew behavior
- ✅ Edge case analysis completed (null semantics, idempotency)
- ✅ Child tasks documented (Task #63)
- ✅ Proof document created
- ✅ track.md status ready for update to "Pending for check"
- ✅ Self-review: Only added skeleton structure for boot_diagnostics block, no other fields

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #62 - boot_diagnostics

### Issues Identified

#### Issue 1: Incomplete Hidden Field Implementation - Missing "Absent" State Logic

**Problem:**
The executor created a conditional structure that only handles `var.boot_diagnostics != null`, but did NOT implement the hidden field `enabled` logic for when the block is **absent** (`var.boot_diagnostics == null`).

**Executor's Implementation:**
```hcl
var.boot_diagnostics != null ? {
  diagnosticsProfile = {
    bootDiagnostics = {
      # storage_account_uri = ... # Task #63
      # enabled = ... # Hidden field - computed based on block presence and storage_account_uri value
    }
  }
} : {}  # ❌ Sends nothing when block absent - WRONG
```

**Why This Violates executor.md:**

From the proof document's own analysis (lines 158-177), the `expandBootDiagnostics` function shows:

```go
if len(input) == 0 {  // When boot_diagnostics block is absent
    return &virtualmachines.DiagnosticsProfile{
        BootDiagnostics: &virtualmachines.BootDiagnostics{
            Enabled:    pointer.To(false),  // ← Explicitly sends false
            StorageUri: pointer.To(""),     // ← Explicitly sends empty string
        },
    }
}
```

**Provider's Actual Behavior:**
The provider has THREE distinct states:
1. **Block absent:** Sends `enabled=false, storageUri=""` to explicitly disable boot diagnostics
2. **Block present, empty:** Sends `enabled=true, storageUri=""` for managed boot diagnostics  
3. **Block present, with URI:** Sends `enabled=true, storageUri=<value>` for custom storage

**Executor's Implementation:**
- ✅ Prepares structure for state #2 and #3 (block present)
- ❌ State #1 (block absent): Sends nothing (`{}`) instead of `enabled=false, storageUri=""`

**Root Cause:**
The executor identified the hidden field logic in the proof document but only left a comment placeholder instead of implementing it. While Type 3 (skeleton) tasks focus on structure, the executor's own proof document (line 273) states: "The `enabled` field is a hidden field that will be handled as part of the structure implementation" - indicating intent to implement it in this task.

The critical issue is that the hidden field logic for the "absent" state MUST be implemented now because:
- The conditional structure determines block presence/absence
- The "enabled" field's value depends on this presence check
- Deferring this creates a partial implementation that doesn't match provider behavior

From executor.md:
> **CRITICAL RULE - EXACT REPLICATION ONLY:** When implementing ANY logic from AzureRM provider, you have TWO options: 1. ✅ Replicate the EXACT behavior, 2. ✅ FAIL the task if exact replication is technically impossible

The executor chose neither - they created a partial implementation that deviates from exact provider behavior.

### Corrections Made

#### Fix 1: Implemented Complete Hidden Field Logic

**Changed Files:**
- `migrate_main.tf`: Implemented three-state logic for `enabled` hidden field

**New Implementation:**
```hcl
{
  diagnosticsProfile = {
    bootDiagnostics = var.boot_diagnostics != null ? {
      enabled = true
      # storage_account_uri = ... # Task #63
    } : {
      enabled    = false
      storageUri = ""
    }
  }
}
```

**Why This is EXACT:**

This now correctly replicates all three provider states:

1. **Block absent (`var.boot_diagnostics == null`):**
   - Provider: Sends `enabled=false, storageUri=""`
   - Shadow: Sends `enabled=false, storageUri=""`
   - ✅ Match

2. **Block present, empty (handled by structure + Task #63):**
   - Provider: Sends `enabled=true, storageUri=""`
   - Shadow: Sends `enabled=true` (Task #63 will handle storageUri)
   - ✅ Match

3. **Block present, with URI (handled by Task #63):**
   - Provider: Sends `enabled=true, storageUri=<value>`
   - Shadow: Sends `enabled=true` (Task #63 will add storageUri)
   - ✅ Match

**Verification:**
- Scenario 1 (absent): `var.boot_diagnostics = null` → `{enabled: false, storageUri: ""}` ✅
- Scenario 2 (empty block): `var.boot_diagnostics = {}` → `{enabled: true}` (Task #63 adds storageUri) ✅
- Scenario 3 (with URI): Task #63 will add the URI while keeping `enabled: true` ✅

**Key Design Decision:**
The `diagnosticsProfile.bootDiagnostics` structure is now ALWAYS present (non-conditional), but its contents change based on block presence. This matches the provider's behavior where the structure is always sent to Azure API, just with different values.

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:
- ✅ All three states of the hidden `enabled` field are correctly implemented
- ✅ The structure always sends `diagnosticsProfile.bootDiagnostics` to match provider behavior
- ✅ The conditional logic correctly distinguishes between absent/present states
- ✅ Task #63 can now safely add `storageUri` field within this structure

**Status:** CORRECTED AND APPROVED ✅

---
