# Task #82 - secret.certificate Block - Structure Skeleton

## Summary

Created structure skeleton for the `secret.certificate` block in `migrate_main.tf`. This nested block maps to `properties.osProfile.secrets[].vaultCertificates` in the Azure API and represents the list of certificates from Key Vault to provision on the VM. Child tasks #83-84 will implement individual arguments.

## Create Phase Verification

**Query Create Method:**

From `resourceWindowsVirtualMachineCreate` and `expandWindowsSecrets()` (already documented in Task #80):

```go
secretsRaw := d.Get("secret").([]interface{})
secrets := expandWindowsSecrets(secretsRaw)

params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		OsProfile: &virtualmachines.OSProfile{
			Secrets: secrets,
		},
	},
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Expand Function Detail:**

```go
func expandWindowsSecrets(input []interface{}) *[]virtualmachines.VaultSecretGroup {
	output := make([]virtualmachines.VaultSecretGroup, 0)

	for _, raw := range input {
		v := raw.(map[string]interface{})

		keyVaultId := v["key_vault_id"].(string)
		certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
		certificates := make([]virtualmachines.VaultCertificate, 0)
		for _, certificateRaw := range certificatesRaw {
			certificateV := certificateRaw.(map[string]interface{})

			store := certificateV["store"].(string)
			url := certificateV["url"].(string)
			certificates = append(certificates, virtualmachines.VaultCertificate{
				CertificateStore: pointer.To(store),
				CertificateURL:   pointer.To(url),
			})
		}

		output = append(output, virtualmachines.VaultSecretGroup{
			SourceVault: &virtualmachines.SubResource{
				Id: pointer.To(keyVaultId),
			},
			VaultCertificates: &certificates,
		})
	}

	return &output
}
```

**Pattern:** Single-phase operation. The certificates are processed as part of the secrets field during the initial Create request and included in the primary `CreateOrUpdateThenPoll` operation.

**Classification:** Create phase - included in primary `local.body.properties.osProfile.secrets[].vaultCertificates`.

**Decision:** Implement in `local.body.properties.osProfile.secrets[].vaultCertificates` during primary Create phase.

## Assignment Path Verification

**Predicted Path:** `properties.osProfile.secrets[].vaultCertificates`

**Go Code Evidence:**

From expand function:
```go
for _, certificateRaw := range certificatesRaw {
	certificateV := certificateRaw.(map[string]interface{})

	store := certificateV["store"].(string)
	url := certificateV["url"].(string)
	certificates = append(certificates, virtualmachines.VaultCertificate{
		CertificateStore: pointer.To(store),
		CertificateURL:   pointer.To(url),
	})
}

output = append(output, virtualmachines.VaultSecretGroup{
	SourceVault: &virtualmachines.SubResource{
		Id: pointer.To(keyVaultId),
	},
	VaultCertificates: &certificates,  // <-- Assignment here
})
```

**Path Trace:**
1. Create `VaultSecretGroup` with `VaultCertificates` field
2. `VaultSecretGroup` is appended to secrets list
3. secrets → `params.Properties.OsProfile.Secrets`
4. `properties.osProfile.secrets[].vaultCertificates` in API

**Verified Path:** `properties.osProfile.secrets[].vaultCertificates` ✅

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

From `windowsSecretSchemaVM()`:

```go
"certificate": {
	Type:     pluginsdk.TypeSet,
	Required: true,
	MinItems: 1,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"store": {
				Type:     pluginsdk.TypeString,
				Required: true,
			},
			"url": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ValidateFunc: keyVaultValidate.NestedItemId,
			},
		},
	},
},
```

**Key Details:**
- **Type:** Set (Required, MinItems: 1)
- **Parent:** secret block
- **Fields:**
  - `store` (Required) - Certificate store name
  - `url` (Required) - Certificate URL with NestedItemId validation

## Azure API Schema

From `Microsoft.Compute/virtualMachines@2024-03-01`:

```
properties.osProfile.secrets: List(ObjectWithOptionalAttrs(map[string]Type{
  "sourceVault": ObjectWithOptionalAttrs(map[string]Type{
    "id": String
  }, []string{"id"}), 
  "vaultCertificates": List(ObjectWithOptionalAttrs(map[string]Type{
    "certificateStore": String, 
    "certificateUrl": String
  }, []string{"certificateStore", "certificateUrl"}))
}, []string{"sourceVault", "vaultCertificates"}))
```

**Structure:**
- `vaultCertificates` is a List of certificate objects
- Each certificate has:
  - `certificateStore` - Store name
  - `certificateUrl` - Certificate URL

## Hidden Fields

**Check Expand Function:**

From the expand function above (lines 159-167), the certificate iteration shows:

```go
for _, certificateRaw := range certificatesRaw {
	certificateV := certificateRaw.(map[string]interface{})

	store := certificateV["store"].(string)
	url := certificateV["url"].(string)
	certificates = append(certificates, virtualmachines.VaultCertificate{
		CertificateStore: pointer.To(store),
		CertificateURL:   pointer.To(url),
	})
}
```

**Hidden Fields Found:** None

The expand function directly maps the input fields to the API structure without adding any hidden values:
- `certificate[].store` → `vaultCertificates[].certificateStore`
- `certificate[].url` → `vaultCertificates[].certificateUrl`

## Mapping

**Terraform → Azure API:**
- `secret[].certificate` → `properties.osProfile.secrets[].vaultCertificates`
- `secret[].certificate[].store` → `properties.osProfile.secrets[].vaultCertificates[].certificateStore`
- `secret[].certificate[].url` → `properties.osProfile.secrets[].vaultCertificates[].certificateUrl`

## Special Handling

### Set to List Conversion

The provider schema defines `certificate` as a **Set** (TypeSet), but the Azure API expects a **List**. The provider's expand function converts the set to a list:

```go
certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
```

In our Terraform implementation, since `var.secret[].certificate` is defined as `set(object(...))`, we need to convert it to a list when building the API payload. This is done using `for` expression which naturally converts sets to lists.

### Required MinItems Constraint

The provider schema requires MinItems: 1 for the certificate set, meaning when the secret block is specified, at least one certificate must be provided. This validation is already enforced by the variable definition in `variables.tf`.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... other properties ...
      var.admin_username != null ? {
        osProfile = merge(
          # ... other osProfile fields ...
          (var.secret != null && length(var.secret) > 0) ? {
            secrets = [
              for secret_item in var.secret : {
                sourceVault = {
                  id = secret_item.key_vault_id  # Already implemented in Task #81
                }
                vaultCertificates = [ # <-
                  for cert in secret_item.certificate : { # <-
                    # certificateStore = ... # Task #83 # <-
                    # certificateUrl = ... # Task #84 # <-
                  } # <-
                ] # <-
              }
            ]
          } : {}
        )
      } : {}
    )
  }
}
```

## Child Tasks Ready for Delegation

The following child tasks are now ready to be implemented:

1. **Task #83** - `secret.certificate.store` (Argument, Required)
   - Maps to: `certificateStore`
   - Type: string
   - Description: Certificate store name on the VM

2. **Task #84** - `secret.certificate.url` (Argument, Required)
   - Maps to: `certificateUrl`
   - Type: string
   - Validation: NestedItemId format (Key Vault certificate URL)

## Edge Case Analysis

### Null Semantics
- `secret_item.certificate == null` → Should not occur due to Required constraint in schema
- `secret_item.certificate == []` (empty set) → Violates MinItems: 1, caught by variable validation

### Empty Collections
- Empty certificate set is prevented by MinItems: 1 constraint
- Variable definition enforces at least one certificate when secret block is used

### Idempotency
- Terraform Set type is unordered, but the for expression converts to a list
- The order in the resulting list may vary between applies if certificates have same hash
- However, Azure API treats vaultCertificates as an unordered collection, so this doesn't affect idempotency
- Each certificate is uniquely identified by its URL, so order doesn't matter

### Safe References
- `for cert in secret_item.certificate` is safe because:
  - The parent `for secret_item in var.secret` only executes when `var.secret != null && length(var.secret) > 0`
  - The certificate field is Required in the parent secret block
  - The set will never be null when secret block is defined

## Deferred Work Completion

**Check `following.md`:** No work deferred TO this task.

**Work deferred FROM this task:** None - this is a pure structure skeleton task with no validation logic.

## Critical Review

### Correctness
- ✅ Structure matches provider's expand function exactly
- ✅ Set to list conversion handled by for expression
- ✅ Nested iteration preserves all certificates
- ✅ Placeholder comments mark work for child tasks

### Provider Behavior Replication
- ✅ Exact mapping: Terraform Set → Go slice → API list
- ✅ No hidden fields added
- ✅ No transformations applied to certificate objects (child tasks will handle fields)
- ✅ Iteration pattern matches expand function logic

### Edge Cases
- ✅ Empty set prevented by MinItems: 1 in variable definition
- ✅ Set to list conversion safe and automatic
- ✅ Parent null checks protect nested iteration
- ✅ Required constraint ensures certificate field always present when secret exists

## Checklist

- ✅ Block skeleton created with for expression
- ✅ Structure matches provider expand function
- ✅ Comment placeholders added for child tasks (#83-84)
- ✅ Hidden fields checked (none found)
- ✅ Mapping documented (Terraform → API)
- ✅ Set to list conversion documented and handled
- ✅ Edge case analysis completed
- ✅ Child tasks listed and ready for delegation
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-review: Only Task #82 structure implemented, no individual arguments added

## Files Modified

1. `migrate_main.tf` - Added certificate block skeleton in `body.properties.osProfile.secrets[].vaultCertificates`
2. `82.secret.certificate.md` - This proof document
3. `track.md` - Status updated to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #82 - secret.certificate

### Validation Results

✅ **Task Type:** Type 3 - Block Structure Skeleton correctly implemented
✅ **ForceNew Logic:** N/A - Structure skeleton task
✅ **Stable Keys:** N/A - No replace_triggers for skeleton task
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Set to list conversion correctly handled by for expression
✅ **Null Handling:** Safe iteration - parent null checks protect nested for loop
✅ **Validations:** N/A - Structure skeleton has no validation logic
✅ **Deferred Work Completion:** No deferred work for this task (checked `following.md`)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, empty collections, idempotency, safe references)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The structure skeleton correctly creates the nested iteration pattern for `vaultCertificates`, matching the provider's `expandWindowsSecrets()` function. Set to list conversion is properly handled by the for expression. Placeholder comments correctly mark work for child tasks #83-84. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Checks:**
- ✅ Skeleton matches Go expand function structure exactly (lines 42-51 in proof)
- ✅ For loop correctly iterates `secret_item.certificate` set
- ✅ Empty object placeholders provided for child task arguments
- ✅ No hidden fields added (verified against expand function)
- ✅ Implementation scope limited to Task #82 only (no other fields added)
- ✅ Proof document complete with all mandatory sections per executor.md

**Status:** APPROVED ✅

---
