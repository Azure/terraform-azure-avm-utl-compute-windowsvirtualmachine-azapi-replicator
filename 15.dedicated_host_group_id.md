# Task #15: dedicated_host_group_id

## Summary

Implemented `dedicated_host_group_id` field mapping from `azurerm_windows_virtual_machine` to `azapi_resource` with DiffSuppressFunc for case-insensitive comparison, ConflictsWith validation for `dedicated_host_id`, and ForceNew behavior for resource replacement on changes.

## Shadow Implementation

```hcl
# In variables.tf
variable "dedicated_host_group_id" {
  type        = string
  default     = null
  description = "(Optional) The ID of a Dedicated Host Group that this Windows Virtual Machine should be run within. Conflicts with `dedicated_host_id`."

  validation {                                                                                               # <-
    condition     = var.dedicated_host_id == null || var.dedicated_host_group_id == null                    # <-
    error_message = "dedicated_host_group_id cannot be used together with dedicated_host_id (ConflictsWith)." # <-
  }                                                                                                          # <-
}

variable "dedicated_host_id" {
  type        = string
  default     = null
  description = "(Optional) The ID of a Dedicated Host where this machine should be run on. Conflicts with `dedicated_host_group_id`."

  validation {                                                                                               # <-
    condition     = var.dedicated_host_group_id == null || var.dedicated_host_id == null                    # <-
    error_message = "dedicated_host_id cannot be used together with dedicated_host_group_id (ConflictsWith)." # <-
  }                                                                                                          # <-
}

# In migrate_main.tf
locals {
  replace_triggers_external_values = {
    # ... existing fields ...
    dedicated_host_group_id       = { value = var.dedicated_host_group_id }                                 # <-
  }
  
  should_read_existing_dedicated_host_group_id = var.dedicated_host_group_id != null                        # <-
  
  existing_dedicated_host_group_id = local.should_read_existing_dedicated_host_group_id && data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.properties.hostGroup.id, null) : null # <-
  
  desired_dedicated_host_group_id = var.dedicated_host_group_id                                             # <-
  
  dedicated_host_group_id_should_suppress = (                                                               # <-
    local.existing_dedicated_host_group_id != null &&                                                       # <-
    local.desired_dedicated_host_group_id != null &&                                                        # <-
    lower(local.existing_dedicated_host_group_id) == lower(local.desired_dedicated_host_group_id)          # <-
  )                                                                                                          # <-
  
  effective_dedicated_host_group_id = local.dedicated_host_group_id_should_suppress ? coalesce(local.existing_dedicated_host_group_id, local.desired_dedicated_host_group_id) : local.desired_dedicated_host_group_id # <-

  body = {
    properties = merge(
      # ... existing fields ...
      local.effective_dedicated_host_group_id != null ? {                                                   # <-
        hostGroup = {                                                                                        # <-
          id = local.effective_dedicated_host_group_id                                                      # <-
        }                                                                                                    # <-
      } : {}                                                                                                 # <-
    )
  }
}
```

## Create Phase Verification

### Query Result

Queried the Create method (`resourceWindowsVirtualMachineCreate`) and identified the field assignment pattern.

### Go Code Evidence

```go
if v, ok := d.GetOk("dedicated_host_group_id"); ok {
    params.Properties.HostGroup = &virtualmachines.SubResource{
        Id: pointer.To(v.(string)),
    }
}
```

### Pattern Classification

**Single-phase operation**: The field is assigned directly to `params.Properties.HostGroup` before the primary `CreateOrUpdateThenPoll` call. No post-creation operations are involved.

### Decision

The field belongs in `local.body.properties.hostGroup` in the Create phase.

## Assignment Path Verification

### Predicted Path

`body.properties.hostGroup.id`

### Go Code Trace

1. Field retrieved: `d.GetOk("dedicated_host_group_id")`
2. Assigned to: `params.Properties.HostGroup = &virtualmachines.SubResource{Id: pointer.To(v.(string))}`
3. Where `params` is of type `virtualmachines.VirtualMachine`
4. The struct assignment: `.Properties.HostGroup`

### Verified Path

`properties.hostGroup.id`

### Path Comparison

✅ **Match**: The predicted path matches the actual assignment path in the provider.

## Provider Schema

From `resourceWindowsVirtualMachine()` schema definition:

```go
"dedicated_host_group_id": {
    Type:         pluginsdk.TypeString,
    Optional:     true,
    ValidateFunc: commonids.ValidateDedicatedHostGroupID,
    // the Compute/VM API is broken and returns the Resource Group name in UPPERCASE
    // tracked by https://github.com/Azure/azure-rest-api-specs/issues/19424
    DiffSuppressFunc: suppress.CaseDifference,
    ConflictsWith: []string{
        "dedicated_host_id",
    },
},
```

**Key attributes:**
- **Type**: String
- **Optional**: true
- **ForceNew**: false (not explicitly set, but no update handling for this field means changes require replacement)
- **ValidateFunc**: `commonids.ValidateDedicatedHostGroupID` (validates Azure resource ID format, skipped per executor.md Category 1 rules)
- **DiffSuppressFunc**: `suppress.CaseDifference` - case-insensitive comparison
- **ConflictsWith**: `dedicated_host_id`

## Azure API Schema

From Azure API `Microsoft.Compute/virtualMachines@2024-03-01`:

```
properties.hostGroup: ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"})
```

The field is optional and contains an `id` string property.

## Hidden Fields

None. The provider only sets the `id` field when `dedicated_host_group_id` is provided.

## Mapping

- **Terraform (azurerm)**: `dedicated_host_group_id` (snake_case)
- **Azure API**: `properties.hostGroup.id` (camelCase with preserved case for acronyms)

## Special Handling

### 1. DiffSuppressFunc - Case Insensitive Comparison

The provider uses `suppress.CaseDifference` to ignore case differences in the resource ID. This is documented in the provider as a workaround for an Azure API bug that returns the Resource Group name in uppercase.

**Provider's DiffSuppressFunc:**

The `suppress.CaseDifference` function is a standard suppression function that compares strings case-insensitively:

```go
// From terraform-provider-azurerm/internal/tf/suppress/case_difference.go
func CaseDifference(_, old, new string, _ *pluginsdk.ResourceData) bool {
    return strings.EqualFold(old, new)
}
```

**Implementation in Terraform:**

Following the `diffsuppressfunc.md` pattern:

1. **Read existing state**: Check if resource exists and read current `hostGroup.id` value
2. **Compute desired value**: Use `var.dedicated_host_group_id` directly
3. **Compute suppression condition**: Compare existing and desired values case-insensitively using `lower()`
4. **Select effective value**: If suppression applies, use existing value; otherwise use desired value

```hcl
locals {
  should_read_existing_dedicated_host_group_id = var.dedicated_host_group_id != null
  
  existing_dedicated_host_group_id = local.should_read_existing_dedicated_host_group_id && data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.properties.hostGroup.id, null) : null
  
  desired_dedicated_host_group_id = var.dedicated_host_group_id
  
  dedicated_host_group_id_should_suppress = (
    local.existing_dedicated_host_group_id != null && 
    local.desired_dedicated_host_group_id != null && 
    lower(local.existing_dedicated_host_group_id) == lower(local.desired_dedicated_host_group_id)
  )
  
  effective_dedicated_host_group_id = local.dedicated_host_group_id_should_suppress ? coalesce(local.existing_dedicated_host_group_id, local.desired_dedicated_host_group_id) : local.desired_dedicated_host_group_id
}
```

**Behavior scenarios:**

- **Scenario 1 - No existing resource**: `existing_dedicated_host_group_id = null`, suppression condition is `false`, uses `desired_dedicated_host_group_id`
- **Scenario 2 - Same value (case-insensitive)**: If existing is `/subscriptions/.../resourceGroups/RG/...` and desired is `/subscriptions/.../resourcegroups/rg/...`, suppression is `true`, uses existing value to avoid unnecessary update
- **Scenario 3 - Different values**: Suppression is `false`, uses desired value, triggers replacement

### 2. ForceNew Behavior

While not explicitly marked `ForceNew: true` in the schema, the provider does not handle updates to this field in the Update method. The field is only set during Create.

**Evidence from Update method**: The `resourceWindowsVirtualMachineUpdate` method does not include any logic to update `dedicated_host_group_id`. Changes to this field require resource replacement.

**Implementation:**

Added to `replace_triggers_external_values` to track the full value:

```hcl
replace_triggers_external_values = {
  dedicated_host_group_id = { value = var.dedicated_host_group_id }
}
```

This ensures that any change to `dedicated_host_group_id` (including null ↔ non-null transitions) triggers a resource replacement.

### 3. ConflictsWith Validation

The provider schema specifies `ConflictsWith: ["dedicated_host_id"]`, meaning these two fields are mutually exclusive.

**Implementation:**

Added cross-field validation in both variables in `variables.tf`:

```hcl
variable "dedicated_host_group_id" {
  # ...
  validation {
    condition     = var.dedicated_host_id == null || var.dedicated_host_group_id == null
    error_message = "dedicated_host_group_id cannot be used together with dedicated_host_id (ConflictsWith)."
  }
}

variable "dedicated_host_id" {
  # ...
  validation {
    condition     = var.dedicated_host_group_id == null || var.dedicated_host_id == null
    error_message = "dedicated_host_id cannot be used together with dedicated_host_group_id (ConflictsWith)."
  }
}
```

Both validations are required to ensure the conflict is caught regardless of which variable the user sets first.

## Deferred Work Completion

Checked `following.md` - no deferred work for Task #15.

## Edge Case Analysis

### 1. Null Semantics

- `null` means: "Do not assign the VM to a dedicated host group"
- The field is optional, so `null` is a valid state
- When `null`, the `hostGroup` property is omitted from the request body entirely

### 2. Empty String

Not applicable - the field type is string with `default = null`, and empty strings would fail the Azure resource ID validation

### 3. Case Sensitivity

**Critical**: Azure API returns Resource Group names in uppercase, but user might provide lowercase. The DiffSuppressFunc handles this by comparing case-insensitively. Our implementation replicates this exactly by:
- Reading the existing value from the API
- Comparing `lower(existing)` with `lower(desired)`
- Using the existing value when they match case-insensitively

This prevents unnecessary replacements when only the case differs.

### 4. Idempotency

The implementation is idempotent:
- Same value (case-insensitive) → No change, no replacement
- Different value → Replacement triggered
- Null transitions properly handled by ForceNew trigger

### 5. Safe References

All nested property accesses use `try()` with fallback to `null`:
```hcl
existing_dedicated_host_group_id = ... ? try(data.azapi_resource.existing.output.properties.hostGroup.id, null) : null
```

This prevents errors when the resource doesn't exist or the property is not set.

### 6. Conflict Handling

The ConflictsWith validation ensures that users cannot set both `dedicated_host_group_id` and `dedicated_host_id` simultaneously. Terraform will fail at plan time with a clear error message.

### 7. Suppression Edge Cases

- **Both null**: No suppression needed, neither field is in body
- **Existing null, desired set**: No suppression, uses desired value
- **Existing set, desired null**: No suppression (desired != existing), triggers replacement to remove the assignment
- **Both set, same case**: Suppression applies, no change
- **Both set, different case**: Suppression applies, uses existing value
- **Both set, different IDs**: No suppression, triggers replacement

## Checklist

- ✅ Property in correct local (`body.properties.hostGroup.id`)
- ✅ ForceNew wrapped: `{ value = var.dedicated_host_group_id }`
- ✅ All logic exactly replicated from provider (DiffSuppressFunc via case-insensitive comparison)
- ✅ Validations implemented in variables.tf (ConflictsWith for both dedicated_host_id and dedicated_host_group_id)
- ✅ Hidden fields checked (none)
- ✅ Deferred work checked in following.md (none for this task)
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe references)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ Track.md will be updated to "Pending for check"
- ✅ Self-review: Only implemented dedicated_host_group_id field, no content from other tasks added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #15 - dedicated_host_group_id

### Validation Results

✅ **DiffSuppressFunc Logic:** Correctly implemented following diffsuppressfunc.md pattern - case-insensitive comparison using `lower()` exactly matches `suppress.CaseDifference` provider behavior
✅ **ForceNew Logic:** Properly tracked in `replace_triggers_external_values` with stable key and full value tracking (`{ value = var.dedicated_host_group_id }`)
✅ **Stable Keys:** Key `dedicated_host_group_id` always present in `replace_triggers_external_values`, never conditionally added/removed
✅ **Phase Detection:** Field correctly placed in `local.body.properties.hostGroup` (Create phase)
✅ **Type Conversion:** String to string, correct path mapping to `hostGroup.id`
✅ **Null Handling:** Safe with `try()` fallback and proper null propagation
✅ **Validations:** ConflictsWith correctly implemented bidirectionally in both `dedicated_host_group_id` and `dedicated_host_id` variables in variables.tf
✅ **State Reading:** Correctly uses `data.azapi_resource.existing` with `.exists` check and safe property access
✅ **Effective Value Selection:** Proper `coalesce()` fallback pattern when suppression applies
✅ **Deferred Work Completion:** No deferred work for this task (verified following.md)
✅ **Edge Cases:** Comprehensive analysis including null semantics, case sensitivity, idempotency, conflict handling, and suppression edge cases

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **DiffSuppressFunc**: Translated `suppress.CaseDifference` to `lower()` comparison exactly
2. **ConflictsWith**: Bidirectional validation implemented in both conflicting variables
3. **ForceNew**: Implicit ForceNew (no Update handling) correctly tracked via replace triggers
4. **State Reading**: Proper pattern with conditional reading and safe property access
5. **Effective Value**: Correct suppression-based value selection with fallback

No deviations, simplifications, or "safer alternatives" were found. The implementation matches the provider's exact behavior for case-insensitive comparison, mutual exclusivity, and resource replacement on changes.

**Status:** APPROVED ✅

---
