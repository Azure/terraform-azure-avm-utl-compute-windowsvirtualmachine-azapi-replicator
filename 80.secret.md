# Task #80 - secret Block - Structure Skeleton

## Summary

Created structure skeleton for the `secret` block in `migrate_main.tf`. This block maps to `properties.osProfile.secrets` in the Azure API and contains Key Vault certificates to be provisioned on the VM. Child tasks #81-84 will implement individual arguments.

## Create Phase Verification

**Query Create Method:**

From `resourceWindowsVirtualMachineCreate`:

```go
secretsRaw := d.Get("secret").([]interface{})
secrets := expandWindowsSecrets(secretsRaw)

// ...

params := virtualmachines.VirtualMachine{
	// ...
	Properties: &virtualmachines.VirtualMachineProperties{
		// ...
		OsProfile: &virtualmachines.OSProfile{
			// ...
			Secrets: secrets,
		},
		// ...
	},
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Pattern:** Single-phase operation. The `secrets` field is populated during the initial Create request and included in the primary `CreateOrUpdateThenPoll` operation.

**Classification:** Create phase - included in primary `local.body` (actually `local.sensitive_body` since secrets contain URLs).

**Decision:** Implement in `local.sensitive_body.properties.osProfile.secrets` during primary Create phase.

## Assignment Path Verification

**Predicted Path:** `properties.osProfile.secrets`

**Go Code Evidence:**

From Create method:
```go
params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		OsProfile: &virtualmachines.OSProfile{
			Secrets: secrets,
		},
	},
}
```

**Path Trace:**
1. `params.Properties` → `properties`
2. `.OsProfile` → `properties.osProfile`
3. `.Secrets` → `properties.osProfile.secrets`

**Verified Path:** `properties.osProfile.secrets` ✅

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

From `windowsSecretSchemaVM()`:

```go
func windowsSecretSchemaVM() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				// whilst this isn't present in the nested object it's required when this is specified
				"key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),

				"certificate": {
					Type:     pluginsdk.TypeSet,
					Required: true,
					MinItems: 1,
					Elem: &pluginsdk.Resource{
						Schema: map[string]*pluginsdk.Schema{
							"store": {
								Type:     pluginsdk.TypeString,
								Required: true,
							},
							"url": {
								Type:         pluginsdk.TypeString,
								Required:     true,
								ValidateFunc: keyVaultValidate.NestedItemId,
							},
						},
					},
				},
			},
		},
		ConflictsWith: []string{
			"os_managed_disk_id",
		},
	}
}
```

**Key Details:**
- **Type:** List (optional)
- **Structure:** Each list item is an object with:
  - `key_vault_id` (Required) - Key Vault ID
  - `certificate` (Required, Set, MinItems: 1) - Set of certificate objects
    - Each certificate has:
      - `store` (Required) - Certificate store name
      - `url` (Required) - Certificate URL with validation
- **ConflictsWith:** `os_managed_disk_id` (block-level constraint)

## Azure API Schema

From query of `Microsoft.Compute/virtualMachines@2024-03-01`:

```
properties.osProfile.secrets: List(ObjectWithOptionalAttrs(map[string]Type{
  "sourceVault": ObjectWithOptionalAttrs(map[string]Type{
    "id": String
  }, []string{"id"}), 
  "vaultCertificates": List(ObjectWithOptionalAttrs(map[string]Type{
    "certificateStore": String, 
    "certificateUrl": String
  }, []string{"certificateStore", "certificateUrl"}))
}, []string{"sourceVault", "vaultCertificates"}))
```

**Structure:**
- List of secret groups
- Each group contains:
  - `sourceVault.id` - Key Vault resource ID
  - `vaultCertificates` - List of certificates
    - `certificateStore` - Store name
    - `certificateUrl` - Certificate URL

## Hidden Fields

**Query Expand Function:**

From `expandWindowsSecrets()`:

```go
func expandWindowsSecrets(input []interface{}) *[]virtualmachines.VaultSecretGroup {
	output := make([]virtualmachines.VaultSecretGroup, 0)

	for _, raw := range input {
		v := raw.(map[string]interface{})

		keyVaultId := v["key_vault_id"].(string)
		certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
		certificates := make([]virtualmachines.VaultCertificate, 0)
		for _, certificateRaw := range certificatesRaw {
			certificateV := certificateRaw.(map[string]interface{})

			store := certificateV["store"].(string)
			url := certificateV["url"].(string)
			certificates = append(certificates, virtualmachines.VaultCertificate{
				CertificateStore: pointer.To(store),
				CertificateURL:   pointer.To(url),
			})
		}

		output = append(output, virtualmachines.VaultSecretGroup{
			SourceVault: &virtualmachines.SubResource{
				Id: pointer.To(keyVaultId),
			},
			VaultCertificates: &certificates,
		})
	}

	return &output
}
```

**Hidden Fields Found:** None

The expand function directly maps the input fields to the API structure without adding any hidden values:
- `key_vault_id` → `sourceVault.id`
- `certificate[].store` → `vaultCertificates[].certificateStore`
- `certificate[].url` → `vaultCertificates[].certificateUrl`

## Mapping

**Terraform → Azure API:**
- `secret` → `properties.osProfile.secrets`
- `secret[].key_vault_id` → `properties.osProfile.secrets[].sourceVault.id`
- `secret[].certificate` → `properties.osProfile.secrets[].vaultCertificates`
- `secret[].certificate[].store` → `properties.osProfile.secrets[].vaultCertificates[].certificateStore`
- `secret[].certificate[].url` → `properties.osProfile.secrets[].vaultCertificates[].certificateUrl`

## Special Handling

### Block-Level ConflictsWith

**ConflictsWith:** `os_managed_disk_id`

This validation is deferred to Task #26 (os_managed_disk_id) as per the pattern established in `following.md`.

### Sensitive Field Placement

The `secret` block contains certificate URLs which are not marked as Sensitive in the provider schema. However, they represent URLs to Key Vault secrets, so they should be treated carefully. Based on the provider's implementation, the secrets are sent in the osProfile during creation.

**Note:** The certificates are not sensitive in the Terraform sense (no `Sensitive: true` in schema), so they go in `sensitive_body` because they're part of osProfile which may contain sensitive data, following the existing pattern where osProfile fields are conditionally added to sensitive_body.

### Array Structure

The `secret` block is a **list** in Terraform, mapping to a **list** in the Azure API. The structure uses a `for` expression to iterate over the list items.

## Shadow Implementation

```hcl
locals {
  sensitive_body = {
    properties = (var.admin_password != null || var.custom_data != null || (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0) || (var.secret != null && length(var.secret) > 0)) ? { # <-
      osProfile = merge(
        var.admin_password != null ? {
          adminPassword = local.effective_admin_password
        } : {},
        var.custom_data != null ? {
          customData = var.custom_data
        } : {},
        (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0) ? {
          windowsConfiguration = {
            additionalUnattendContent = [
              for item in var.additional_unattend_content : {
                content       = item.content
                settingName   = item.setting
                passName      = "OobeSystem"
                componentName = "Microsoft-Windows-Shell-Setup"
              }
            ]
          }
        } : {},
        (var.secret != null && length(var.secret) > 0) ? { # <-
          secrets = [ # <-
            for secret_item in var.secret : { # <-
              sourceVault = { # <-
                # id = ... # Task #81 # <-
              } # <-
              vaultCertificates = [ # <-
                # for cert in ... # Task #82 # <-
                # { # <-
                #   certificateStore = ... # Task #83 # <-
                #   certificateUrl = ... # Task #84 # <-
                # } # <-
              ] # <-
            } # <-
          ] # <-
        } : {} # <-
      )
    } : {}
  }
}
```

## Child Tasks Ready for Delegation

The following child tasks are now ready to be implemented:

1. **Task #81** - `secret.key_vault_id` (Argument, Required)
   - Maps to: `sourceVault.id`
   - Type: string
   - Validation: Key Vault ID format

2. **Task #82** - `secret.certificate` (Block, Required)
   - Maps to: `vaultCertificates` array
   - Type: Set of objects (MinItems: 1)
   - Note: This is a structure task similar to this one

3. **Task #83** - `secret.certificate.store` (Argument, Required)
   - Parent: Task #82
   - Maps to: `certificateStore`
   - Type: string

4. **Task #84** - `secret.certificate.url` (Argument, Required)
   - Parent: Task #82
   - Maps to: `certificateUrl`
   - Type: string
   - Validation: Nested item ID format

## Edge Case Analysis

### Null Semantics
- `var.secret == null` → No secrets block sent in API (entire merge branch omitted)
- `var.secret == []` (empty list) → No secrets block sent (length check prevents merge)

### Empty Collections
- Empty list handled by length check: `length(var.secret) > 0`
- Provider requires MinItems: 1 for certificate set within each secret item

### Idempotency
- List order matters in Terraform lists, so the order is preserved
- Certificate set within each secret uses a set type in Terraform schema, but maps to a list in Azure API

### Safe References
- All nested accesses use conditional checks before accessing properties
- The `for secret_item in var.secret` expression is only evaluated when `var.secret != null && length(var.secret) > 0`

## Deferred Work Completion

**Check `following.md`:** No work deferred TO this task.

**Work deferred FROM this task:**

Added to `following.md`:
- Task #80 → Task #26: Block-level ConflictsWith validation (secret cannot be used with os_managed_disk_id)

## Critical Review

### Correctness
- ✅ Structure matches provider's expand function exactly
- ✅ List iteration pattern preserves order
- ✅ Conditional inclusion prevents empty structures in API payload
- ✅ Nested structure prepared for child tasks

### Provider Behavior Replication
- ✅ Exact mapping: Terraform structure → Go struct → API payload
- ✅ No hidden fields added
- ✅ No transformations applied to values
- ✅ Placeholder comments mark work for child tasks

### Edge Cases
- ✅ Null check prevents errors when secret not specified
- ✅ Length check handles empty list correctly
- ✅ For expression only evaluated when list has items

## Checklist

- ✅ Block skeleton created with conditional inclusion
- ✅ Structure matches provider expand function
- ✅ Comment placeholders added for child tasks (#81-84)
- ✅ Hidden fields checked (none found)
- ✅ Mapping documented (Terraform → API)
- ✅ Edge case analysis completed
- ✅ Child tasks listed and ready for delegation
- ✅ Deferred work documented in following.md
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-review: Only Task #80 structure implemented, no individual arguments added

## Files Modified

1. `migrate_main.tf` - Added secret block skeleton in `body.properties.osProfile.secrets` (CORRECTED by checker from sensitive_body)
2. `variables.tf` - Added ConflictsWith validation for secret vs os_managed_disk_id (ADDED by checker)
3. `following.md` - Added deferred validation to Task #26 (UPDATED by checker - marked as completed)
4. `80.secret.md` - This proof document
5. `track.md` - Status updated to "Pending for check"

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #80 - secret

### Issues Identified

#### Issue 1: Incorrect Placement in sensitive_body

**Problem:**
Executor placed the `secret` block in `local.sensitive_body.properties.osProfile.secrets` instead of `local.body.properties.osProfile.secrets`.

**Executor's Implementation:**
```hcl
sensitive_body = {
  properties = (var.admin_password != null || var.custom_data != null || (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0) || (var.secret != null && length(var.secret) > 0)) ? {
    osProfile = merge(
      # ... admin_password, custom_data, additional_unattend_content ...
      (var.secret != null && length(var.secret) > 0) ? {
        secrets = [ ... ]
      } : {}
    )
  } : {}
}
```

**Why This Violates executor.md:**
From executor.md line 329: "All Sensitive or WriteOnly fields MUST be in `sensitive_body`, NOT `body`"

However, the provider schema shows **NO** `Sensitive: true` marker on any field in the `secret` block:
```go
func windowsSecretSchemaVM() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),
				"certificate": {
					Type:     pluginsdk.TypeSet,
					Required: true,
					MinItems: 1,
					Elem: &pluginsdk.Resource{
						Schema: map[string]*pluginsdk.Schema{
							"store": {
								Type:     pluginsdk.TypeString,
								Required: true,
							},
							"url": {
								Type:         pluginsdk.TypeString,
								Required:     true,
								ValidateFunc: keyVaultValidate.NestedItemId,
							},
						},
					},
				},
			},
		},
	}
}
```

**Executor's Reasoning (from proof):**
"The certificates are not sensitive in the Terraform sense (no `Sensitive: true` in schema), so they go in `sensitive_body` because they're part of osProfile which may contain sensitive data"

**Why Executor's Reasoning is Wrong:**
1. The rule is clear: **ONLY fields marked with `Sensitive: true` OR WriteOnly** go in sensitive_body
2. Being "part of osProfile" is NOT a criterion - not all osProfile fields are sensitive (e.g., `computerName`, `adminUsername` are in body)
3. Certificate URLs are REFERENCES to Key Vault secrets, not the secrets themselves - they're public identifiers
4. The provider itself does NOT mark these fields as sensitive, so we must not either

**Provider's Actual Behavior:**
The provider treats `secret` block fields as regular (non-sensitive) fields. The expand function `expandWindowsSecrets()` processes them as normal values without any special sensitive handling.

**Expected Behavior:**
- `secret` block should be in `local.body.properties.osProfile.secrets`
- Only truly sensitive fields (admin_password with Sensitive: true, custom_data with WriteOnly marker) go in sensitive_body
- Certificate URLs are public references and not sensitive data

**Root Cause:**
Executor confused "security-related" with "sensitive in Terraform sense". The `secret` block relates to security (certificates) but the fields themselves (Key Vault ID, certificate URLs) are not marked as sensitive in the provider schema.

#### Issue 2: Missing ConflictsWith Validation

**Problem:**
Executor identified the ConflictsWith constraint between `secret` and `os_managed_disk_id` but only deferred it to Task #26 without implementing the validation on the `secret` variable itself.

**Executor's Documentation:**
From proof line 202-204: "This validation is deferred to Task #26 (os_managed_disk_id) as per the pattern established in `following.md`."

**Why This Violates executor.md:**
From executor.md line 126: "Cross-Field Constraints (MUST ALL): `ConflictsWith`, `RequiredWith`, `ExactlyOneOf`, `AtLeastOneOf` → Modify field's variable in `variables.tf` to add `validation` block (ownership rule)."

The ownership rule states that BOTH variables in a bidirectional constraint must have validation blocks. While Task #26 will add its side when it's implemented, Task #80 must add its side NOW.

**Provider Schema Evidence:**
```go
ConflictsWith: []string{
	"os_managed_disk_id",
}
```

**Expected Behavior:**
The `secret` variable in `variables.tf` must have a validation block:
```hcl
validation {
  condition     = var.secret == null || var.os_managed_disk_id == null
  error_message = "The secret block cannot be used together with os_managed_disk_id (ConflictsWith)."
}
```

**Root Cause:**
Executor misunderstood the ownership rule - cross-field validations require BOTH sides to implement their validations, not just the "owning" field.

### Corrections Made

#### Fix 1: Moved secret Block to body

**Changed Files:**
- `migrate_main.tf`: Moved secret block from sensitive_body to body

**New Implementation:**
```hcl
# In local.body.properties
var.admin_username != null ? {
  osProfile = merge(
    {
      adminUsername = var.admin_username
    },
    {
      computerName = var.computer_name != null ? var.computer_name : var.name
    },
    {
      allowExtensionOperations = var.allow_extension_operations
    },
    {
      windowsConfiguration = merge(
        {
          enableAutomaticUpdates = local.effective_automatic_updates
        },
        {
          provisionVMAgent = var.provision_vm_agent
        },
        # ... patchSettings, timezone ...
      )
    },
    (var.secret != null && length(var.secret) > 0) ? {
      secrets = [
        for secret_item in var.secret : {
          sourceVault = {
            # id = ... # Task #81
          }
          vaultCertificates = [
            # for cert in ... # Task #82
          ]
        }
      ]
    } : {}
  )
} : {},

# In local.sensitive_body (removed secret block)
sensitive_body = {
  properties = (var.admin_password != null || var.custom_data != null || (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0)) ? {
    osProfile = merge(
      # Only truly sensitive fields here: admin_password, custom_data, additional_unattend_content
    )
  } : {}
}
```

**Why This is EXACT:**
- Matches provider's treatment of secret fields as non-sensitive
- Follows executor.md rule: only Sensitive/WriteOnly fields go in sensitive_body
- Certificate URLs are public identifiers, not secrets themselves
- Provider schema has NO `Sensitive: true` marker on these fields

**Verification:**
- Scenario 1: `var.secret = null` → No secrets block in body ✅
- Scenario 2: `var.secret = []` → No secrets block in body (length check) ✅
- Scenario 3: `var.secret = [{key_vault_id="...", certificate=[...]}]` → secrets block in body.properties.osProfile.secrets ✅
- Edge Case: secret in body, admin_password in sensitive_body → Both osProfile merge correctly ✅

#### Fix 2: Added ConflictsWith Validation

**Changed Files:**
- `variables.tf`: Added validation block to secret variable
- `following.md`: Updated status of deferred validation to "✅ Completed"

**New Implementation:**
```hcl
variable "secret" {
  type = list(object({
    key_vault_id = string
    certificate = set(object({
      store = string
      url   = string
    }))
  }))
  default     = null
  description = <<-EOT
 - `key_vault_id` - (Required) The ID of the Key Vault from which all Secrets should be sourced.

 ---
 `certificate` block supports the following:
 - `store` - (Required) The certificate store on the Virtual Machine where the certificate should be added.
 - `url` - (Required) The Secret URL of a Key Vault Certificate.
EOT

  validation {
    condition     = var.secret == null || var.os_managed_disk_id == null
    error_message = "The secret block cannot be used together with os_managed_disk_id (ConflictsWith)."
  }
}
```

**Why This is EXACT:**
- Implements the ConflictsWith constraint from provider schema
- Follows executor.md ownership rule: both variables must have validation
- Error message matches provider's constraint intent
- Condition correctly allows: both null, only one set, but not both set

**Verification:**
- Scenario 1: Both null → Validation passes ✅
- Scenario 2: Only secret set → Validation passes ✅
- Scenario 3: Only os_managed_disk_id set → Validation passes ✅
- Scenario 4: Both set → Validation fails with clear error message ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:
1. ✅ secret block correctly placed in body (non-sensitive fields)
2. ✅ ConflictsWith validation implemented on both sides of constraint
3. ✅ Structure matches provider's expand function exactly
4. ✅ All rules from executor.md followed precisely

**Status:** CORRECTED AND APPROVED ✅

---
