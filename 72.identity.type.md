# Task #72 - identity.type

## Summary

Implemented the `identity.type` argument within the `identity` block in `azapi_header`. The field is Required when the identity block is present and accepts values: "SystemAssigned", "UserAssigned", or "SystemAssigned, UserAssigned". The field is NOT ForceNew and can be updated on an existing VM. Implementation adds validation in variables.tf and maps directly to Azure API identity.type.

## Shadow Implementation

```hcl
# In migrate_main.tf:
locals {
  azapi_header = {
    type                 = "Microsoft.Compute/virtualMachines@2024-03-01"
    name                 = var.name
    location             = local.location_normalized
    parent_id            = var.resource_group_id
    tags                 = var.tags
    ignore_null_property = true
    retry                = null
    identity = var.identity != null ? {
      type         = var.identity.type  # <-
      # identity_ids = ... # Task #73
    } : null
  }
}
```

```hcl
# In variables.tf:
variable "identity" {
  type = object({
    identity_ids = optional(set(string))
    type         = string
  })
  default     = null
  description = <<-EOT
 - `identity_ids` - (Optional) Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.
 - `type` - (Required) Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
EOT
  
  validation {
    condition     = var.identity == null || var.identity.type != null
    error_message = "When identity is set, the type field is required."
  }
  
  validation {  # <-
    condition     = var.identity == null || contains(["SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned"], var.identity.type)  # <-
    error_message = "The identity type must be one of: SystemAssigned, UserAssigned, SystemAssigned, UserAssigned."  # <-
  }  # <-
}
```

## Create Phase Verification

From `resourceWindowsVirtualMachineCreate`:

```go
identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
if err != nil {
    return fmt.Errorf("expanding `identity`: %+v", err)
}

// ... later in params construction ...

params := virtualmachines.VirtualMachine{
    Name:             pointer.To(id.VirtualMachineName),
    ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
    Location:         location.Normalize(d.Get("location").(string)),
    Identity:         identityExpanded,  // ← Assigned at root level
    Plan:             plan,
    Properties: &virtualmachines.VirtualMachineProperties{
        // ... properties ...
    },
    Tags: tags.Expand(t),
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Pattern:** Single-phase operation. The identity.type is expanded as part of the identity block and assigned to the root level of `VirtualMachine` struct during the primary `CreateOrUpdateThenPoll` call.

**Decision:** Field is processed in the Create phase as part of the primary resource creation. No post-creation operations needed.

## Assignment Path Verification

**Predicted path:** `identity.type` (root level of azapi_resource)

**Go code evidence:**

From the expand function `ExpandSystemAndUserAssignedMap`:

```go
func ExpandSystemAndUserAssignedMap(input []interface{}) (*SystemAndUserAssignedMap, error) {
	identityType := TypeNone
	identityIds := make(map[string]UserAssignedIdentityDetails, 0)

	if len(input) > 0 {
		raw := input[0].(map[string]interface{})
		typeRaw := raw["type"].(string)  // ← Read type field
		if typeRaw == string(TypeSystemAssigned) {
			identityType = TypeSystemAssigned
		}
		if typeRaw == string(TypeSystemAssignedUserAssigned) {
			identityType = TypeSystemAssignedUserAssigned
		}
		if typeRaw == string(TypeUserAssigned) {
			identityType = TypeUserAssigned
		}

		identityIdsRaw := raw["identity_ids"].(*schema.Set).List()
		for _, v := range identityIdsRaw {
			identityIds[v.(string)] = UserAssignedIdentityDetails{
				// intentionally empty since the expand shouldn't send these values
			}
		}
	}

	if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
		return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
	}

	return &SystemAndUserAssignedMap{
		Type:        identityType,  // ← Type is set here
		IdentityIds: identityIds,
	}, nil
}
```

From Create method:

```go
params := virtualmachines.VirtualMachine{
    Identity: identityExpanded,  // ← SystemAndUserAssignedMap containing Type field
    // ...
}
```

**Verified path:** `identity.type` (root level)

**Path comparison:** ✅ Match - The type field is placed at `identity.type` in the root level of azapi_resource (in `azapi_header`), which corresponds to the Azure API structure.

## Provider Schema

From `resourceWindowsVirtualMachine` schema:

```go
"identity": commonschema.SystemAssignedUserAssignedIdentityOptional(),
```

Schema details for the `type` field:

```go
func SystemAssignedUserAssignedIdentityOptional() *schema.Schema {
	return &schema.Schema{
		Type:     schema.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"type": {
					Type:     schema.TypeString,
					Required: true,  // ← Required when block present
					ValidateFunc: validation.StringInSlice([]string{
						string(identity.TypeUserAssigned),
						string(identity.TypeSystemAssigned),
						string(identity.TypeSystemAssignedUserAssigned),
					}, false),  // ← Allowed values
				},
				// ... other fields ...
			},
		},
	}
}
```

**Key observations:**
- Field is **Required** when identity block is present
- Accepts three string values: "UserAssigned", "SystemAssigned", "SystemAssigned, UserAssigned"
- Uses `StringInSlice` validation with case-sensitive matching (false parameter)
- Not ForceNew - can be updated

## Azure API Schema

From AzAPI resource schema at `identity.type`:

```
String
```

From documentation query:

```json
"The Type of Identity which should be used for this azure resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned,UserAssigned`"
```

**Mapping:**
- Provider `identity.type` (string) → Azure API `identity.type` (string)
- Values: "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned"

## Hidden Fields

No hidden fields. The type field is directly passed through from Terraform to Azure API via the expand function.

## Mapping

| Provider Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `identity.type` | `identity.type` | Required string field, 1:1 mapping |

**Name transformation:** None - direct mapping

## Special Handling

### Validation

Added validation in `variables.tf`:

```hcl
validation {
  condition     = var.identity == null || contains(["SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned"], var.identity.type)
  error_message = "The identity type must be one of: SystemAssigned, UserAssigned, SystemAssigned, UserAssigned."
}
```

This replicates the provider's `StringInSlice` validation with exact values.

### Not ForceNew

The identity.type field does NOT have `ForceNew: true` in the provider schema. From the Update method:

```go
if d.HasChange("identity") {
    shouldUpdate = true

    identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %+v", err)
    }
    update.Identity = identityExpanded
}
```

**Evidence:** The Update method handles identity changes, including type changes, without forcing replacement. The entire identity block can be updated on an existing VM.

**Implementation:** No entry in `replace_triggers_external_values` needed.

### Cross-Field Validation (Deferred)

The expand function validates that when `identity_ids` is specified, the type must be either "UserAssigned" or "SystemAssigned, UserAssigned":

```go
if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
    return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
}
```

**Decision:** This cross-field validation will be implemented in Task #73 (identity_ids) as it "owns" the identity_ids field. Recording in following.md.

## Deferred Work Completion

Checked `following.md` - no work deferred to this task.

## Edge Case Analysis

1. **Null semantics:**
   - `var.identity == null` → No identity configured, type field not evaluated
   - `var.identity != null && var.identity.type == "SystemAssigned"` → System-assigned identity only
   - `var.identity != null && var.identity.type == "UserAssigned"` → User-assigned identity only
   - `var.identity != null && var.identity.type == "SystemAssigned, UserAssigned"` → Both types

2. **Boundary conditions:**
   - Empty string: Prevented by validation (not in allowed list)
   - Invalid values: Prevented by validation
   - Case sensitivity: Values are case-sensitive per provider schema

3. **Idempotency:**
   - Direct 1:1 mapping ensures deterministic behavior
   - No transformations applied to the value

4. **Safe references:**
   - Parent block checks `var.identity != null` before accessing type
   - Type field is always present when identity block is set (enforced by existing validation in variables.tf)

5. **Update behavior:**
   - Can change from SystemAssigned to UserAssigned (requires identity_ids)
   - Can change from UserAssigned to SystemAssigned (identity_ids will be ignored)
   - Can change to/from "SystemAssigned, UserAssigned"

## Deferred Work Recording

Recording cross-field validation deferred to Task #73:

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #72 | #73 | Validation | Cross-field validation: identity_ids can only be specified when type is UserAssigned or SystemAssigned, UserAssigned | Pending |

## Checklist

- ✅ Property in correct local (azapi_header.identity.type)
- ✅ Not ForceNew (identity can be updated)
- ✅ Validation IMPLEMENTED in variables.tf (StringInSlice values)
- ✅ Hidden fields checked (none)
- ✅ Deferred work recorded in following.md (cross-field validation to Task #73)
- ✅ Deferred work from following.md checked (none for this task)
- ✅ Critical review (direct mapping, case-sensitive, updateable)
- ✅ Edge Case Analysis completed
- ✅ Proof created
- ✅ Track.md will be updated to Pending for check
- ✅ Self-Review: Only identity.type field implemented, no other fields touched

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #72 - identity.type

### Issues Identified

#### Issue 1: Validation Error Message Contains Duplicate Values

**Problem:**
The validation error message listed values twice instead of clearly communicating all three valid options.

**Executor's Implementation:**
```hcl
validation {
  condition     = var.identity == null || contains(["SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned"], var.identity.type)
  error_message = "The identity type must be one of: SystemAssigned, UserAssigned, SystemAssigned, UserAssigned."
}
```

**Why This Violates executor.md:**
The error message should clearly communicate the three valid values without duplication. The message repeats "SystemAssigned" and "UserAssigned" when it should list: "SystemAssigned", "UserAssigned", or "SystemAssigned, UserAssigned" (the third option being the combined type).

**Expected Behavior:**
- Error message should clearly list all three distinct valid values
- Message should use "or" to separate the last option for clarity
- Format: "SystemAssigned, UserAssigned, or SystemAssigned, UserAssigned"

**Root Cause:**
The error message was constructed by simply concatenating the values without considering that the third valid value is a string containing both words.

### Corrections Made

#### Fix 1: Corrected Validation Error Message

**Changed Files:**
- `variables.tf`: Updated validation error message for identity.type

**New Implementation:**
```hcl
validation {
  condition     = var.identity == null || contains(["SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned"], var.identity.type)
  error_message = "The identity type must be one of: SystemAssigned, UserAssigned, or SystemAssigned, UserAssigned."
}
```

**Why This is EXACT:**
This clearly communicates all three valid values:
1. "SystemAssigned" (system-assigned identity only)
2. "UserAssigned" (user-assigned identity only)
3. "SystemAssigned, UserAssigned" (both types enabled)

The use of "or" before the final option improves clarity and matches standard error message conventions.

**Verification:**
- Scenario 1: `type = "SystemAssigned"` → Validation passes ✅
- Scenario 2: `type = "UserAssigned"` → Validation passes ✅
- Scenario 3: `type = "SystemAssigned, UserAssigned"` → Validation passes ✅
- Scenario 4: `type = "InvalidValue"` → Clear error message with all valid options ✅
- Edge Case: `type = null` when `identity != null` → Caught by Required field validation ✅

### Validation Results

✅ **Field Placement:** Correctly placed in `azapi_header.identity.type` (root level)
✅ **ForceNew Logic:** Correctly identified as NOT ForceNew - identity can be updated
✅ **Stable Keys:** Not applicable - not in replace_triggers_external_values
✅ **Phase Detection:** Correctly placed in Create phase as part of azapi_header
✅ **Type Conversion:** Direct 1:1 string mapping from Terraform to Azure API
✅ **Null Handling:** Correctly handles null identity block with conditional
✅ **Validations:** StringInSlice validation correctly implemented with all three valid values
✅ **Deferred Work Completion:** No deferred work for this task (verified in following.md)
✅ **Deferred Work Recording:** Cross-field validation properly deferred to Task #73 and recorded in following.md
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, case sensitivity, update behavior)

### Compliance Statement

After correction, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The validation correctly enforces the three valid identity types with a clear error message. The field is correctly placed in the root-level identity block, properly handles null cases, and correctly allows updates without forcing replacement.

**Status:** CORRECTED AND APPROVED ✅

---
