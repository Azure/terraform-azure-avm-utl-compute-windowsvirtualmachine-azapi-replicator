# Task #46: os_disk.storage_account_type - Implementation Proof

## Summary

Implemented `os_disk.storage_account_type` as a required nested field within the `os_disk` block, mapping to `properties.storageProfile.osDisk.managedDisk.storageAccountType` in the Azure API. The field has ForceNew behavior and validates the storage account type against allowed OS disk values (excludes UltraSSD_LRS and PremiumV2_LRS which are only for data disks).

## Shadow Implementation

```hcl
# migrate_main.tf
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    os_disk_storage_account_type  = { value = var.os_disk.storage_account_type } # <-
  }
  
  body = merge(
    {
      properties = merge(
        # ... other properties ...
        {
          storageProfile = merge(
            # ... other storage profile properties ...
            {
              osDisk = merge( # <-
                {
                  caching = var.os_disk.caching
                  managedDisk = { # <-
                    storageAccountType = var.os_disk.storage_account_type # <-
                  } # <-
                  # ... other os_disk fields ...
                  createOption = "FromImage"
                  osType       = "Windows"
                }
              )
            }
          )
        }
      )
    }
  )
}

# variables.tf
variable "os_disk" {
  type = object({
    caching                          = string
    # ... other fields ...
    storage_account_type             = string
    # ... other fields ...
  })
  # ... description ...
  nullable    = false

  validation { # <-
    condition = contains([ # <-
      "Standard_LRS", # <-
      "StandardSSD_LRS", # <-
      "Premium_LRS", # <-
      "StandardSSD_ZRS", # <-
      "Premium_ZRS" # <-
    ], var.os_disk.storage_account_type) # <-
    error_message = "The os_disk.storage_account_type must be one of: Standard_LRS, StandardSSD_LRS, Premium_LRS, StandardSSD_ZRS, Premium_ZRS." # <-
  } # <-
}
```

## Create Phase Verification

**Query Result**: Single-phase creation pattern - field is set during primary `CreateOrUpdateThenPoll` operation.

**Go Code Evidence**:
```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... initialization ...
	
	osDiskRaw := d.Get("os_disk").([]interface{})
	osDisk, err := expandVirtualMachineOSDisk(osDiskRaw, virtualmachines.OperatingSystemTypesWindows)
	// ... error handling ...
	
	params.Properties.StorageProfile.OsDisk = osDisk
	
	// ... additional setup ...
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
}
```

**Decision**: Field is assigned to the main `VirtualMachine` struct during Create phase and sent in the primary `CreateOrUpdateThenPoll` operation. This is a single-phase operation, so the field belongs in `local.body`.

## Assignment Path Verification

**Predicted Path**: `os_disk.storage_account_type` → `properties.storageProfile.osDisk.managedDisk.storageAccountType`

**Go Code Evidence - expand function**:
```go
func expandVirtualMachineOSDisk(input []interface{}, osType virtualmachines.OperatingSystemTypes) (*virtualmachines.OSDisk, error) {
	raw := input[0].(map[string]interface{})
	caching := raw["caching"].(string)

	disk := virtualmachines.OSDisk{
		Caching: pointer.To(virtualmachines.CachingTypes(caching)),
		ManagedDisk: &virtualmachines.ManagedDiskParameters{
			StorageAccountType: pointer.To(virtualmachines.StorageAccountTypes(raw["storage_account_type"].(string))),
		},
		// ... other fields ...
		CreateOption: virtualmachines.DiskCreateOptionTypesFromImage,
		OsType:       pointer.To(osType),
	}
	// ... rest of function ...
	return &disk, nil
}
```

**Assignment in Create**:
```go
params.Properties.StorageProfile.OsDisk = osDisk
```

**Verified Path**: 
1. `raw["storage_account_type"]` extracted from Terraform config
2. Assigned to `disk.ManagedDisk.StorageAccountType` (field of type `*virtualmachines.StorageAccountTypes`)
3. `disk` returned as `*virtualmachines.OSDisk`
4. Assigned to `params.Properties.StorageProfile.OsDisk` (field of type `*virtualmachines.OSDisk`)
5. Final path: `properties.storageProfile.osDisk.managedDisk.storageAccountType`

**Path Comparison**: ✅ **MATCH** - The predicted path matches the verified path exactly.

## Provider Schema

**Source**: `virtualMachineOSDiskSchema()` function in azurerm provider

```go
"storage_account_type": {
	Type:     pluginsdk.TypeString,
	Optional: true,
	Computed: true,
	// whilst this appears in the Update block the API returns this when changing:
	// Changing property 'osDisk.managedDisk.storageAccountType' is not allowed
	ForceNew: true,
	ValidateFunc: validation.StringInSlice([]string{
		// note: OS Disks don't support Ultra SSDs or PremiumV2_LRS
		string(virtualmachines.StorageAccountTypesPremiumLRS),
		string(virtualmachines.StorageAccountTypesStandardLRS),
		string(virtualmachines.StorageAccountTypesStandardSSDLRS),
		string(virtualmachines.StorageAccountTypesStandardSSDZRS),
		string(virtualmachines.StorageAccountTypesPremiumZRS),
	}, false),
	DiffSuppressFunc: func(_, oldVal, newVal string, d *schema.ResourceData) bool {
		// When specifying an existing disk to use as the O/S disk, this value cannot be specified
		// so we must suppress the Diff/ForceNew
		existingDiskId, _ := pluginsdk.GoValueFromTerraformValue[string](d.GetRawConfig().AsValueMap()["os_managed_disk_id"])
		return pointer.From(existingDiskId) != ""
	},
	// ConflictsWith: []string{"os_managed_disk_id"},
	ExactlyOneOf: []string{
		"os_managed_disk_id",
		"os_disk.0.storage_account_type",
	},
},
```

**Key Properties**:
- **Type**: String
- **Optional**: true
- **Computed**: true (API returns value if not specified)
- **ForceNew**: true (changing this property forces new resource)
- **DiffSuppressFunc**: Suppresses diff when `os_managed_disk_id` is set (because existing disk's storage type cannot be changed)
- **ExactlyOneOf**: Either `os_managed_disk_id` or `os_disk.storage_account_type` must be specified
- **ValidateFunc**: Must be one of: `Premium_LRS`, `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_ZRS`

**Important Comment**: "OS Disks don't support Ultra SSDs or PremiumV2_LRS" - these storage types are only valid for data disks.

## Azure API Schema

**Query Path**: `body.properties.storageProfile.osDisk.managedDisk.storageAccountType`

**Type**: `String` (optional field within `managedDisk` object)

**Documentation**: 
> "Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk. (Possible values: Standard_LRS,Premium_LRS,StandardSSD_LRS,UltraSSD_LRS,Premium_ZRS,StandardSSD_ZRS,PremiumV2_LRS)"

**API Full Schema for managedDisk**:
```
ObjectWithOptionalAttrs(map[string]Type{
  "diskEncryptionSet": ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"}),
  "id": String,
  "securityProfile": ObjectWithOptionalAttrs(map[string]Type{
    "diskEncryptionSet": ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"}),
    "securityEncryptionType": String
  }, []string{"diskEncryptionSet", "securityEncryptionType"}),
  "storageAccountType": String
}, []string{"diskEncryptionSet", "id", "securityProfile", "storageAccountType"})
```

## Hidden Fields

None. The field is explicitly defined in the provider schema.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `os_disk.storage_account_type` | `properties.storageProfile.osDisk.managedDisk.storageAccountType` | Parent `managedDisk` object created to hold this field |

**Casing**: `storage_account_type` (snake_case) → `storageAccountType` (camelCase)

## Special Handling

### 1. ForceNew Behavior

**Implementation**: Added to `replace_triggers_external_values` with full value tracking:
```hcl
os_disk_storage_account_type = { value = var.os_disk.storage_account_type }
```

**Evidence from Provider**:
```go
ForceNew: true,
// Comment: whilst this appears in the Update block the API returns this when changing:
// Changing property 'osDisk.managedDisk.storageAccountType' is not allowed
```

**Reasoning**: The Azure API explicitly prevents changes to this property after VM creation. Any change must trigger resource replacement.

### 2. Validation

**Implementation**: Added validation block to `os_disk` variable in `variables.tf`:
```hcl
validation {
  condition = contains([
    "Standard_LRS",
    "StandardSSD_LRS",
    "Premium_LRS",
    "StandardSSD_ZRS",
    "Premium_ZRS"
  ], var.os_disk.storage_account_type)
  error_message = "The os_disk.storage_account_type must be one of: Standard_LRS, StandardSSD_LRS, Premium_LRS, StandardSSD_ZRS, Premium_ZRS."
}
```

**Rationale**: Replicate the exact validation from the provider. Note that `UltraSSD_LRS` and `PremiumV2_LRS` are explicitly excluded as they are only valid for data disks, not OS disks.

### 3. DiffSuppressFunc Handling

**MANDATORY: Per executor.md lines 36-39, when DiffSuppressFunc is present, must read diffsuppressfunc.md and follow its rules.**

**Provider DiffSuppressFunc**:
```go
DiffSuppressFunc: func(_, oldVal, newVal string, d *schema.ResourceData) bool {
	// When specifying an existing disk to use as the O/S disk, this value cannot be specified
	// so we must suppress the Diff/ForceNew
	existingDiskId, _ := pluginsdk.GoValueFromTerraformValue[string](d.GetRawConfig().AsValueMap()["os_managed_disk_id"])
	return pointer.From(existingDiskId) != ""
},
```

**Analysis**: This DiffSuppressFunc suppresses the diff when `os_managed_disk_id` is specified. The logic is: `return os_managed_disk_id != ""` (returns true to suppress when the field is set).

**Critical Context**: Task #26 (`os_managed_disk_id`) is marked as **Failed** in track.md. This field will NEVER exist in this replicator module.

**Terraform Implementation (per diffsuppressfunc.md)**:

```hcl
# Step 1: Read existing state if needed
locals {
  should_read_existing_os_disk_storage_account_type = var.os_disk.storage_account_type != null
  
  existing_os_disk_storage_account_type = local.should_read_existing_os_disk_storage_account_type && data.azapi_resource.existing.exists ? 
    try(data.azapi_resource.existing.output.properties.storageProfile.osDisk.managedDisk.storageAccountType, null) : null
  
  # Step 2: Desired value
  desired_os_disk_storage_account_type = var.os_disk.storage_account_type
  
  # Step 3: Replicate DiffSuppressFunc condition
  # Original Go: return pointer.From(existingDiskId) != ""
  # Since os_managed_disk_id (Task #26) is Failed and will never exist in this module,
  # the condition is always false (never suppress)
  os_disk_storage_account_type_should_suppress = false
  
  # Step 4: Effective value selection
  effective_os_disk_storage_account_type = local.os_disk_storage_account_type_should_suppress ? 
    coalesce(local.existing_os_disk_storage_account_type, local.desired_os_disk_storage_account_type) : 
    local.desired_os_disk_storage_account_type
}

# Step 5: Use in body
locals {
  body = {
    properties = {
      storageProfile = {
        osDisk = {
          managedDisk = {
            storageAccountType = local.effective_os_disk_storage_account_type
          }
        }
      }
    }
  }
}
```

**Behavior Review**:
- **Scenario 1 (Create)**: No existing resource → `should_suppress = false` → use desired value → field set correctly ✅
- **Scenario 2 (Update)**: Existing resource, change value → `should_suppress = false` (os_managed_disk_id never exists) → use desired value → ForceNew triggered correctly ✅
- **Scenario 3 (Update, no change)**: Existing resource, same value → Terraform detects no change → no update/replacement ✅

**Decision**: DiffSuppressFunc correctly replicated per diffsuppressfunc.md. Since `os_managed_disk_id` will never exist in this module, suppression is always `false`, and standard ForceNew behavior applies.

### 4. ExactlyOneOf Constraint

**Provider Schema**:
```go
ExactlyOneOf: []string{
	"os_managed_disk_id",
	"os_disk.0.storage_account_type",
},
```

**Analysis**: This constraint ensures either `os_managed_disk_id` (for attaching existing disk) OR `os_disk.storage_account_type` (for creating new disk) is specified, but not both.

**Module Context**: Since `os_managed_disk_id` is not supported in this module (task #26 is Failed), the constraint effectively becomes a requirement for `storage_account_type`. The field is already marked as required (`storage_account_type = string`) in the `os_disk` object type.

**Decision**: No additional cross-field validation needed. The type system enforces that `storage_account_type` must be provided.

## Deferred Work Completion

**Check of following.md**: No work was deferred to Task #46.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Field Type**: Required field (`storage_account_type = string`, not `optional(string)`)
- **Null Handling**: Field cannot be null. Terraform will enforce this at plan time.
- **API Behavior**: Field must be specified when creating a new OS disk (CreateOption = "FromImage")

### Boundary Conditions
- **Empty String**: Validation prevents empty string - must be one of the 5 allowed values
- **Invalid Values**: Validation catches typos and invalid storage types
- **Data Disk Types**: `UltraSSD_LRS` and `PremiumV2_LRS` are explicitly excluded per provider validation

### Idempotency
- **Deterministic**: Value is passed directly from variable to API, no transformations
- **Consistent**: Same input always produces same output
- **No Ordering**: Single string value, no ordering concerns

### Safe References
- **Direct Access**: `var.os_disk.storage_account_type` is safe because `os_disk` is required (`nullable = false`)
- **No Nested Optionals**: Field is at second level of object, accessed safely

### Edge Cases Identified

1. **Case Sensitivity**: The Azure API expects exact casing (e.g., `Premium_LRS` not `premium_lrs`). Our validation enforces exact string matches.

2. **Computed Value**: The field is marked as `Computed: true` in the provider, meaning the API can return a value even if not explicitly set. However, for new disk creation (CreateOption = "FromImage"), the field must be explicitly specified. Our module enforces this by making it required.

3. **ForceNew Behavior**: Any change to this field requires VM replacement. The `replace_triggers_external_values` correctly tracks the full value to ensure Terraform detects changes.

4. **Managed Disk Wrapper**: The field must be nested within a `managedDisk` object. Our implementation creates this wrapper structure correctly with `managedDisk = { storageAccountType = ... }`.

5. **ZRS Availability**: `StandardSSD_ZRS` and `Premium_ZRS` are zone-redundant storage options that may not be available in all regions. However, region-specific validation is the responsibility of the Azure API, not this module.

## Checklist

- ✅ Property in correct local (`local.body.properties.storageProfile.osDisk.managedDisk.storageAccountType`)
- ✅ ForceNew wrapped: `os_disk_storage_account_type = { value = var.os_disk.storage_account_type }`
- ✅ All logic exactly replicated from provider (validation, ForceNew)
- ✅ Validation implemented in variables.tf (5 allowed storage types)
- ✅ No TODO comments needed (field already exists in variable)
- ✅ Hidden fields checked (none)
- ✅ Deferred work in following.md: None to defer
- ✅ Deferred work from following.md: None deferred to this task
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ track.md will be updated to Pending for check
- ✅ Self-Review: Only storage_account_type implemented, no other fields added

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #46 - os_disk.storage_account_type

### Issues Identified

#### Issue 1: DiffSuppressFunc Not Properly Implemented

**Problem:**
The executor acknowledged the `DiffSuppressFunc` but dismissed it with justification that it's "not applicable" because the module is for creating new VMs. This violated executor.md's mandatory blocking condition.

**Executor's Original Approach:**
The proof document stated:
> "Replicator Module Context: Since this module is for creating new VMs from images (not attaching existing disks), the DiffSuppressFunc logic is not applicable..."
> "Decision: No special handling needed beyond standard ForceNew behavior."

This violated executor.md lines 36-39:
```
⚠️ CRITICAL: DiffSuppressFunc Detection
If schema shows `DiffSuppressFunc` for current field, STOP and read `diffsuppressfunc.md` FIRST.
```

**Why This Violates executor.md:**
- Executor DID NOT stop and read `diffsuppressfunc.md` when they saw DiffSuppressFunc
- Executor made their own decision about whether to apply DiffSuppressFunc based on "module context"
- Executor used justification/reasoning to bypass a mandatory rule
- This is exactly the type of "executor's explanations" that checker.md warns against (lines 38-39)

**Provider's DiffSuppressFunc**:
```go
DiffSuppressFunc: func(_, oldVal, newVal string, d *schema.ResourceData) bool {
	existingDiskId, _ := pluginsdk.GoValueFromTerraformValue[string](d.GetRawConfig().AsValueMap()["os_managed_disk_id"])
	return pointer.From(existingDiskId) != ""
},
```

**Root Cause:**
Executor violated the blocking condition by not following diffsuppressfunc.md's required pattern. Even though the conclusion (suppression = false) was correct, the implementation method was wrong.

### Corrections Made

#### Fix 1: Implement DiffSuppressFunc Pattern from diffsuppressfunc.md

**Changed Files:**
- `migrate_main.tf`: Added DiffSuppressFunc suppression logic locals
- `46.os_disk.storage_account_type.md`: Replaced Section 3 with proper DiffSuppressFunc analysis

**New Implementation in migrate_main.tf:**
```hcl
locals {
  # Step 1: Read existing state (required by diffsuppressfunc.md)
  should_read_existing_os_disk_storage_account_type = var.os_disk.storage_account_type != null
  
  existing_os_disk_storage_account_type = local.should_read_existing_os_disk_storage_account_type && 
    data.azapi_resource.existing.exists ? 
    try(data.azapi_resource.existing.output.properties.storageProfile.osDisk.managedDisk.storageAccountType, null) : null
  
  # Step 2: Desired value
  desired_os_disk_storage_account_type = var.os_disk.storage_account_type
  
  # Step 3: Replicate DiffSuppressFunc condition exactly
  # Original Go: return pointer.From(existingDiskId) != ""
  # Since os_managed_disk_id (Task #26) is Failed and never exists, condition is always false
  os_disk_storage_account_type_should_suppress = false
  
  # Step 4: Effective value selection (per diffsuppressfunc.md template)
  effective_os_disk_storage_account_type = local.os_disk_storage_account_type_should_suppress ? 
    coalesce(local.existing_os_disk_storage_account_type, local.desired_os_disk_storage_account_type) : 
    local.desired_os_disk_storage_account_type
}

# Step 5: Use effective value in body
locals {
  body = {
    properties = {
      storageProfile = {
        osDisk = {
          managedDisk = {
            storageAccountType = local.effective_os_disk_storage_account_type  # Changed from var.os_disk.storage_account_type
          }
        }
      }
    }
  }
}
```

**Why This is EXACT:**
1. Follows diffsuppressfunc.md's 5-step pattern exactly:
   - ✅ Derive desired value
   - ✅ Gather existing state
   - ✅ Mirror Go conditions (suppression = false because os_managed_disk_id never exists)
   - ✅ Select effective value using coalesce template
   - ✅ Populate request body with effective value
2. The conclusion (suppression = false) is the SAME as executor's, but the METHOD is now correct
3. Proof document now shows all required diffsuppressfunc.md elements (lines 86-95)

**Verification:**
- Scenario 1 (Create): No existing → should_suppress = false → use desired → ✅ Works correctly
- Scenario 2 (Update, change): Existing resource → should_suppress = false → use desired → ForceNew triggers ✅
- Scenario 3 (Update, no change): Existing resource, same value → Terraform detects no change → no update ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:
- ✅ DiffSuppressFunc handled per diffsuppressfunc.md mandatory pattern
- ✅ All 5 steps of diffsuppressfunc.md template implemented
- ✅ Suppression logic correctly analyzed (always false since os_managed_disk_id never exists)
- ✅ Effective value selection uses required coalesce pattern
- ✅ ForceNew behavior preserved through replace_triggers_external_values
- ✅ Validation correctly implemented (5 allowed storage types)

**Status:** CORRECTED AND APPROVED ✅

---
