# Task #74 - os_image_notification Block - Structure Skeleton

## Summary

Created the structure skeleton for the root-level `os_image_notification` block, which maps to `properties.scheduledEventsProfile.osImageNotificationProfile` in the Azure API. The block is optional (MaxItems: 1) and contains configuration for OS image upgrade notifications. A hidden field `enable` is set to `true` when the block is present.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... other properties ...
        var.os_image_notification != null ? {                           # <-
          scheduledEventsProfile = {                                     # <-
            osImageNotificationProfile = {                               # <-
              enable = true                                              # <-
              # notBeforeTimeout = ... # Task #75                        # <-
            }                                                            # <-
          }                                                              # <-
        } : {}                                                           # <-
      )
    }
  )
}
```

## Create Phase Verification

### Querying Create Method

**Query**: `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_windows_virtual_machine", entrypoint_name="create")`

### Provider Create Method Evidence

```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	var osImageNotificationProfile *virtualmachines.OSImageNotificationProfile
	var terminateNotificationProfile *virtualmachines.TerminateNotificationProfile

	if v, ok := d.GetOk("os_image_notification"); ok {
		osImageNotificationProfile = expandOsImageNotificationProfile(v.([]interface{}))
	}

	if v, ok := d.GetOk("termination_notification"); ok {
		terminateNotificationProfile = expandTerminateNotificationProfile(v.([]interface{}))
	}

	if terminateNotificationProfile != nil || osImageNotificationProfile != nil {
		params.Properties.ScheduledEventsProfile = &virtualmachines.ScheduledEventsProfile{
			OsImageNotificationProfile:   osImageNotificationProfile,
			TerminateNotificationProfile: terminateNotificationProfile,
		}
	}
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
	// ...
}
```

### Create Phase Pattern

**Pattern**: Single-phase (primary CreateOrUpdateThenPoll only)

**Decision**: This block is processed during the primary Create operation - no post-creation operations required. The `os_image_notification` field is read from Terraform state, expanded via `expandOsImageNotificationProfile`, and included in the primary `params.Properties.ScheduledEventsProfile` structure before the main `CreateOrUpdateThenPoll` call.

**Implementation Location**: `local.body.properties.scheduledEventsProfile.osImageNotificationProfile`

## Assignment Path Verification

### Predicted Path
`properties.scheduledEventsProfile.osImageNotificationProfile`

### Go Code Evidence - Tracing Assignments

**Step 1 - Variable Declaration:**
```go
var osImageNotificationProfile *virtualmachines.OSImageNotificationProfile
```

**Step 2 - Expand Function Call:**
```go
if v, ok := d.GetOk("os_image_notification"); ok {
    osImageNotificationProfile = expandOsImageNotificationProfile(v.([]interface{}))
}
```

**Step 3 - Assignment to ScheduledEventsProfile:**
```go
if terminateNotificationProfile != nil || osImageNotificationProfile != nil {
    params.Properties.ScheduledEventsProfile = &virtualmachines.ScheduledEventsProfile{
        OsImageNotificationProfile:   osImageNotificationProfile,
        TerminateNotificationProfile: terminateNotificationProfile,
    }
}
```

**Step 4 - params.Properties Assignment:**
The `params` variable is of type `virtualmachines.VirtualMachine` and its `Properties` field is populated with `ScheduledEventsProfile` before the CreateOrUpdateThenPoll call.

### Verified Path
`properties.scheduledEventsProfile.osImageNotificationProfile`

### Path Comparison
✅ **MATCH** - The predicted path matches the verified path from Go code tracing.

## Provider Schema

**Query**: `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_windows_virtual_machine", entrypoint_name="schema")`

```go
"os_image_notification": virtualMachineOsImageNotificationSchema(),
```

**Schema Function**:
```go
func virtualMachineOsImageNotificationSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"timeout": {
					Type:     pluginsdk.TypeString,
					Optional: true,
					ValidateFunc: validation.StringInSlice([]string{
						"PT15M",
					}, false),
					Default: "PT15M",
				},
			},
		},
	}
}
```

**Evidence**:
- **Type**: List (MaxItems: 1) - Optional block
- **Fields**: 
  - `timeout`: Optional string with default "PT15M", validated to only accept "PT15M"

## Azure API Schema

**Query**: `query_azapi_resource_schema(resource_type="Microsoft.Compute/virtualMachines", api_version="2024-03-01", path="properties.scheduledEventsProfile")`

**Result**: The query failed, indicating the Azure API schema does not expose `scheduledEventsProfile` as a documented schema path. This is likely because it's a complex nested structure.

**Manual Verification from Go SDK**:
From the expand function and create method, the Azure API structure is:
```
properties.scheduledEventsProfile.osImageNotificationProfile
  ├─ enable (boolean)
  └─ notBeforeTimeout (string)
```

## Hidden Fields

### Hidden Field Discovery

**Query**: `expandOsImageNotificationProfile` function

```go
func expandOsImageNotificationProfile(input []interface{}) *virtualmachines.OSImageNotificationProfile {
	if len(input) == 0 {
		return &virtualmachines.OSImageNotificationProfile{
			Enable: pointer.To(false),
		}
	}

	raw := input[0].(map[string]interface{})
	timeout := raw["timeout"].(string)

	return &virtualmachines.OSImageNotificationProfile{
		Enable:           pointer.To(true),
		NotBeforeTimeout: &timeout,
	}
}
```

### Hidden Field Analysis

**Hidden Field Found**: `enable` (boolean)

**Evidence**:
1. The `enable` field is NOT present in the Terraform schema (only `timeout` is defined)
2. The expand function ALWAYS sets `Enable`:
   - When `os_image_notification` is null: `Enable: false` (not processed in this task - handled when block is absent)
   - When `os_image_notification` is present: `Enable: true`
3. This is a required field in the Azure API that the provider manages automatically

**Implementation**: The skeleton includes `enable = true` when `var.os_image_notification != null`

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `os_image_notification` (block) | `properties.scheduledEventsProfile.osImageNotificationProfile` | Optional block, MaxItems: 1 |
| (hidden) | `enable` | Always `true` when block is present |
| `timeout` | `notBeforeTimeout` | Task #75 - snake_case to camelCase |

**Naming Convention**: 
- Provider: `os_image_notification.timeout`
- Azure API: `scheduledEventsProfile.osImageNotificationProfile.notBeforeTimeout`
- Conversion: snake_case → camelCase, with `timeout` becoming `notBeforeTimeout`

## Special Handling

### Block Presence Logic

The skeleton uses conditional logic:
```hcl
var.os_image_notification != null ? {
  scheduledEventsProfile = {
    osImageNotificationProfile = {
      enable = true
      # notBeforeTimeout = ... # Task #75
    }
  }
} : {}
```

**Rationale**:
- When `var.os_image_notification` is `null`, the entire `scheduledEventsProfile` is omitted
- When present, `enable` is hardcoded to `true` (as per expand function logic)
- The `notBeforeTimeout` field will be implemented by Task #75

### ForceNew Analysis

**Schema Check**: The `os_image_notification` block does NOT have `ForceNew: true` in its schema definition.

**CustomizeDiff Check**: No CustomizeDiff logic found for this field in the resource function.

**Conclusion**: This field does NOT require ForceNew handling. No entry needed in `replace_triggers_external_values`.

### Sensitive Fields

**Schema Check**: No fields in the `os_image_notification` block are marked as `Sensitive: true`.

**Conclusion**: No sensitive field handling required.

### Validation

**Schema Validation**: The `timeout` field has validation:
```go
ValidateFunc: validation.StringInSlice([]string{
    "PT15M",
}, false),
Default: "PT15M",
```

**Implementation Status**: Validation will be implemented in Task #75 (the `timeout` argument task).

### Default Value

The `timeout` field has a default value of `"PT15M"`. This will be handled in Task #75 using the `optional(string, "PT15M")` syntax in the variable definition.

## Deferred Work Completion

**Check**: Reviewed `following.md` for any work deferred to Task #74.

**Result**: No entries found in `following.md` that defer work to this task.

## Child Task Delegation

Based on the provider schema, the `os_image_notification` block has the following child task:

### Child Task Ready for Delegation

| Task # | Path | Type | Status |
|--------|------|------|--------|
| 75 | `os_image_notification.timeout` | Argument | Ready - skeleton created |

**Justification**: The block skeleton has been created with the proper conditional structure and hidden `enable` field. Task #75 can now implement the `timeout` argument by replacing the comment placeholder with the actual field assignment.

## Critical Review & Edge Case Analysis

### Null Semantics

**Question**: What does `var.os_image_notification == null` mean?

**Answer**: When `null`, the entire `scheduledEventsProfile.osImageNotificationProfile` structure is omitted from the API request. This means OS image notifications are not configured for the VM.

**Edge Case**: The expand function shows that when the block is empty (length 0), it would set `Enable: false`. However, in our implementation, we use `var.os_image_notification != null` as the condition, which means we either:
- Include the entire `osImageNotificationProfile` with `enable = true` (when not null)
- Omit it completely (when null)

This matches the Terraform behavior where an optional block is either present or absent.

### Empty Object Edge Case

**Scenario**: What if `var.os_image_notification = {}`?

**Analysis**: In Terraform, if the user specifies `os_image_notification {}` (empty block), the variable will be a non-null object with default values. Since `timeout` has `optional(string, "PT15M")` in the variable definition (will be added in Task #75), the empty block will automatically use the default value.

**Implementation**: The `!= null` check correctly handles this - an empty block `{}` is not null and will include the structure with `enable = true`.

### Idempotency

**Question**: Is the implementation idempotent?

**Answer**: Yes. The skeleton structure is deterministic:
- When `var.os_image_notification` is null → structure omitted
- When present → always produces the same structure with `enable = true`
- No order-dependent operations
- No dynamic lookups or state dependencies

### Safe References

**Question**: Are nested field accesses safe?

**Answer**: Yes. The implementation uses:
1. Top-level null check: `var.os_image_notification != null`
2. Direct field access will be used in Task #75: `var.os_image_notification.timeout`

The null check at the block level prevents accessing fields on a null object.

### Boundary Conditions

**Scenario 1**: Block is null
- **Behavior**: Structure omitted from API payload
- **Correctness**: ✅ Matches provider behavior

**Scenario 2**: Block is present with default timeout
- **Behavior**: Sets `enable = true` and includes `notBeforeTimeout` with default "PT15M"
- **Correctness**: ✅ Matches expand function logic

**Scenario 3**: Multiple blocks specified
- **Prevention**: Provider schema has `MaxItems: 1`, variable type is `object` (not list), cannot specify multiple blocks
- **Correctness**: ✅ Schema prevents this scenario

## Checklist

- ✅ **Block skeleton created** with conditional structure
- ✅ **Hidden field identified** (`enable = true`)
- ✅ **Comment placeholder added** for Task #75 (timeout field)
- ✅ **Assignment path verified** via Go code tracing
- ✅ **Create phase verified** (single-phase, primary create operation)
- ✅ **ForceNew checked** (not required)
- ✅ **Sensitive fields checked** (none)
- ✅ **Validation identified** (deferred to Task #75)
- ✅ **Default value identified** (deferred to Task #75)
- ✅ **Deferred work checked** (none for this task)
- ✅ **Child task identified** (Task #75 ready for delegation)
- ✅ **Critical review completed** (null semantics, edge cases, idempotency, safe refs)
- ✅ **Edge case analysis documented**
- ✅ **Proof document created**
- ✅ **Self-review completed** - Only added structure skeleton for Task #74, no implementation of child argument

## Self-Review

**Question**: Did I add ONLY what Task #74 requires?

**Answer**: ✅ Yes. I added:
1. The block skeleton structure with conditional presence
2. The hidden `enable` field (required by expand function)
3. Comment placeholder for Task #75

I did NOT implement:
- The `timeout` argument (belongs to Task #75)
- Any validation logic (belongs to Task #75)
- Any other fields or blocks

**Question**: Did I add any hidden fields that belong to `__check_*_hidden_fields__` tasks?

**Answer**: ✅ No. The `enable` field is specific to this block and discovered through the expand function for `os_image_notification`. It's not a root-level hidden field. The root hidden fields were already handled in Task #43.

**Question**: Did I add fields from other tasks?

**Answer**: ✅ No. Only the `os_image_notification` block skeleton was added.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #74 - os_image_notification

### Validation Results

✅ **Block Skeleton:** Correctly created conditional structure with proper path `properties.scheduledEventsProfile.osImageNotificationProfile`
✅ **Hidden Fields:** Identified and implemented `enable = true` from expand function
✅ **Phase Detection:** Correctly placed in `local.body` (Create phase, single-phase operation)
✅ **Assignment Path:** Verified path matches Go code tracing exactly
✅ **ForceNew Logic:** No ForceNew required (not in schema or CustomizeDiff) - correctly not added to replace_triggers_external_values
✅ **Stable Keys:** Not applicable (no ForceNew handling)
✅ **Type Conversion:** Not applicable (block structure task)
✅ **Null Handling:** Correct conditional logic `var.os_image_notification != null`
✅ **Validations:** None required at block level (deferred to Task #75)
✅ **Sensitive Fields:** None in this block
✅ **Nested Merge:** Proper structure, no duplicate parent keys
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null, empty object, idempotency, safe refs)
✅ **Self-Review:** Confirmed only skeleton added, no child argument implementation

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The block skeleton correctly:
1. Creates the proper conditional structure based on block presence
2. Implements the hidden `enable` field as discovered in the expand function
3. Uses the correct assignment path matching the Go SDK structure
4. Provides comment placeholder for child Task #75
5. Follows Type 3 (Block Structure Skeleton) requirements exactly

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
