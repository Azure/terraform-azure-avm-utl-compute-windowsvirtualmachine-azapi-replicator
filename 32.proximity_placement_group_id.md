# Task #32 - proximity_placement_group_id

## Summary

Implemented `proximity_placement_group_id` as an optional root-level argument with DiffSuppressFunc for case-insensitive comparison, ID format validation, and ConflictsWith validation for `capacity_reservation_group_id` (reciprocal validation completed from Task #12). Update requires deallocation.

## Shadow Implementation

```hcl
# variables.tf
variable "proximity_placement_group_id" {
  type        = string
  default     = null
  description = "(Optional) The ID of the Proximity Placement Group which the Virtual Machine should be assigned to."

  validation {  # <-
    condition = (  # <-
      var.proximity_placement_group_id == null ||  # <-
      can(regex("^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\\.Compute/proximityPlacementGroups/[^/]+$", var.proximity_placement_group_id))  # <-
    )  # <-
    error_message = "The proximity_placement_group_id must be a valid Proximity Placement Group ID."  # <-
  }  # <-

  validation {  # <-
    condition     = var.proximity_placement_group_id == null || var.capacity_reservation_group_id == null  # <-
    error_message = "proximity_placement_group_id cannot be used together with capacity_reservation_group_id (ConflictsWith)."  # <-
  }  # <-
}

# migrate_main.tf
locals {
  should_read_existing_proximity_placement_group_id = var.proximity_placement_group_id != null  # <-
  
  existing_proximity_placement_group_id = local.should_read_existing_proximity_placement_group_id && data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.properties.proximityPlacementGroup.id, null) : null  # <-
  
  desired_proximity_placement_group_id = var.proximity_placement_group_id  # <-
  
  proximity_placement_group_id_should_suppress = (  # <-
    local.existing_proximity_placement_group_id != null &&   # <-
    local.desired_proximity_placement_group_id != null &&   # <-
    lower(local.existing_proximity_placement_group_id) == lower(local.desired_proximity_placement_group_id)  # <-
  )  # <-
  
  effective_proximity_placement_group_id = local.proximity_placement_group_id_should_suppress ? coalesce(local.existing_proximity_placement_group_id, local.desired_proximity_placement_group_id) : local.desired_proximity_placement_group_id  # <-

  replace_triggers_external_values = {
    # ... other fields ...
    proximity_placement_group_id  = { value = var.proximity_placement_group_id }  # <-
  }

  body = merge(
    {
      properties = merge(
        # ... other fields ...
        local.effective_proximity_placement_group_id != null ? {  # <-
          proximityPlacementGroup = {  # <-
            id = local.effective_proximity_placement_group_id  # <-
          }  # <-
        } : {}  # <-
      )
    },
    # ... other merges ...
  )
}
```

## Create Phase Verification

**Query**: `query_terraform_block_implementation_source_code(block_type="resource", entrypoint_name="create", terraform_type="azurerm_windows_virtual_machine")`

**Pattern**: Single-phase create operation with one `CreateOrUpdateThenPoll` call.

**Field Classification**: Create phase - the field is set in the primary `CreateOrUpdateThenPoll` operation.

**Evidence from Create method**:
```go
if v, ok := d.GetOk("proximity_placement_group_id"); ok {
	params.Properties.ProximityPlacementGroup = &virtualmachines.SubResource{
		Id: pointer.To(v.(string)),
	}
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Decision**: Field belongs in `local.body` (primary create phase), NOT in post-creation operations.

## Assignment Path Verification

**Predicted Path**: `body.properties.proximityPlacementGroup.id`

**Go Code Evidence from Create**:
```go
params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		// ... other properties ...
	},
}

// Later in the function:
if v, ok := d.GetOk("proximity_placement_group_id"); ok {
	params.Properties.ProximityPlacementGroup = &virtualmachines.SubResource{
		Id: pointer.To(v.(string)),
	}
}
```

**Trace**:
1. `params` is of type `virtualmachines.VirtualMachine`
2. `params.Properties` is assigned to `&virtualmachines.VirtualMachineProperties`
3. `params.Properties.ProximityPlacementGroup` is set to `&virtualmachines.SubResource{ Id: ... }`
4. Path: `properties` → `proximityPlacementGroup` → `id`

**Verified Path**: `properties.proximityPlacementGroup.id`

**Path Comparison**: ✅ MATCH - Predicted path matches verified path.

## Provider Schema

**Source**: `query_terraform_block_implementation_source_code(block_type="resource", entrypoint_name="schema", terraform_type="azurerm_windows_virtual_machine")`

```go
"proximity_placement_group_id": {
	Type:         pluginsdk.TypeString,
	Optional:     true,
	ValidateFunc: proximityplacementgroups.ValidateProximityPlacementGroupID,
	// the Compute/VM API is broken and returns the Resource Group name in UPPERCASE :shrug:
	// tracked by https://github.com/Azure/azure-rest-api-specs/issues/19424
	DiffSuppressFunc: suppress.CaseDifference,
	ConflictsWith: []string{
		"capacity_reservation_group_id",
	},
},
```

**Key attributes**:
- **Type**: String
- **Required**: No (Optional: true)
- **ForceNew**: No (not specified in schema, defaults to false)
- **ValidateFunc**: `proximityplacementgroups.ValidateProximityPlacementGroupID`
- **DiffSuppressFunc**: `suppress.CaseDifference` (case-insensitive comparison)
- **ConflictsWith**: `capacity_reservation_group_id`

## Azure API Schema

**Query**: Full schema query for `Microsoft.Compute/virtualMachines@2024-03-01`

**Relevant excerpt**:
```
"proximityPlacementGroup":ObjectWithOptionalAttrs(map[string]Type{
  "id":String
}, []string{"id"})
```

**Property Path**: `body.properties.proximityPlacementGroup.id`

**Type**: String (resource ID)

## Hidden Fields

No hidden fields detected. The field maps directly to the API property.

## Mapping

- **Terraform**: `proximity_placement_group_id` (snake_case)
- **Azure API**: `proximityPlacementGroup.id` (camelCase)

## Special Handling

### 1. DiffSuppressFunc - Case-Insensitive Comparison

**Provider Schema**:
```go
DiffSuppressFunc: suppress.CaseDifference,
```

**Implementation**: Implemented DiffSuppressFunc logic using the standard pattern:
1. Read existing state via `data.azapi_resource.existing`
2. Extract existing value: `try(data.azapi_resource.existing.output.properties.proximityPlacementGroup.id, null)`
3. Compare using case-insensitive logic: `lower(existing) == lower(desired)`
4. If match, preserve existing value (suppress diff): `coalesce(existing, desired)`
5. Otherwise, use desired value

**Rationale**: Provider comment states "the Compute/VM API is broken and returns the Resource Group name in UPPERCASE". This DiffSuppressFunc prevents unnecessary diffs when only casing differs.

### 2. ForceNew Behavior

**Provider Schema**: Not marked as `ForceNew: true` in schema (defaults to false).

**Update Behavior from Update method**:
```go
if d.HasChange("proximity_placement_group_id") {
	shouldUpdate = true

	// Code="OperationNotAllowed" Message="Updating proximity placement group of VM is not allowed while the VM is running. Please stop/deallocate the VM and retry the operation."
	shouldShutDown = true
	shouldDeallocate = true

	if ppgIDRaw, ok := d.GetOk("proximity_placement_group_id"); ok {
		update.Properties.ProximityPlacementGroup = &virtualmachines.SubResource{
			Id: pointer.To(ppgIDRaw.(string)),
		}
	} else {
		update.Properties.ProximityPlacementGroup = &virtualmachines.SubResource{}
	}
}
```

**Analysis**: 
- Update IS allowed but requires VM deallocation
- Not ForceNew (doesn't force recreation)
- Update triggers `shouldDeallocate = true`

**Implementation**: Added to `replace_triggers_external_values` to detect changes, but this DOES NOT trigger ForceNew. AzAPI will handle the update operation. The field is tracked to ensure consistent state management.

**Note**: The `replace_triggers_external_values` entry ensures AzAPI tracks the field for state consistency, NOT to force recreation. The actual update behavior (requiring deallocation) is handled by the Azure API when AzAPI sends the update request.

### 3. Validation #1: ID Format

**Provider Schema**:
```go
ValidateFunc: proximityplacementgroups.ValidateProximityPlacementGroupID,
```

**Expected Format**: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}`

**Implementation in variables.tf**:
```hcl
validation {
  condition = (
    var.proximity_placement_group_id == null ||
    can(regex("^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\\.Compute/proximityPlacementGroups/[^/]+$", var.proximity_placement_group_id))
  )
  error_message = "The proximity_placement_group_id must be a valid Proximity Placement Group ID."
}
```

### 4. Validation #2: ConflictsWith capacity_reservation_group_id

**Provider Schema**:
```go
ConflictsWith: []string{
	"capacity_reservation_group_id",
},
```

**Implementation in variables.tf**:
```hcl
validation {
  condition     = var.proximity_placement_group_id == null || var.capacity_reservation_group_id == null
  error_message = "proximity_placement_group_id cannot be used together with capacity_reservation_group_id (ConflictsWith)."
}
```

**Reciprocal Validation**: Task #12 (`capacity_reservation_group_id`) already implemented the reciprocal validation. This task completes the bidirectional constraint.

## Deferred Work Completion

**From `following.md`**:

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #12 | #32 | Validation | Cross-field validation: proximity_placement_group_id cannot be used together with capacity_reservation_group_id (ConflictsWith) | Pending |

**Work Completed**: 
✅ Implemented reciprocal ConflictsWith validation in `variables.tf` for `proximity_placement_group_id`
✅ Updated `following.md` status to "✅ Completed"

**Evidence**:
```hcl
# variables.tf - proximity_placement_group_id
validation {
  condition     = var.proximity_placement_group_id == null || var.capacity_reservation_group_id == null
  error_message = "proximity_placement_group_id cannot be used together with capacity_reservation_group_id (ConflictsWith)."
}
```

This validation ensures that if `proximity_placement_group_id` is set, `capacity_reservation_group_id` must be null, completing the bidirectional constraint deferred from Task #12.

## Edge Case Analysis

### Null Semantics
- **`null` input**: Field omitted from API request (not included in `properties` merge)
- **Empty string**: Prevented by validation (must match regex pattern)
- **Meaning**: `null` means "do not specify proximity placement group"

### Casing Differences
- **Azure API behavior**: Returns resource group name in uppercase (provider comment)
- **Handling**: Case-insensitive comparison via DiffSuppressFunc
- **Preservation**: When only casing differs, existing value is preserved

### Update Behavior
- **Change detection**: Tracked in `replace_triggers_external_values`
- **API requirement**: Update requires VM deallocation (not ForceNew)
- **Safe operation**: Azure API enforces deallocation requirement

### Idempotency
- **DiffSuppressFunc**: Ensures case-insensitive comparison
- **State preservation**: When values match (ignoring case), existing value preserved
- **No drift**: Consistent state across applies

### Safe References
- **Existing state**: Uses `try()` with null default for safe property access
- **Conditional merge**: Only adds field to body when non-null
- **Null propagation**: Handles both null variable and missing existing state

### Conflict Resolution
- **ConflictsWith validation**: Prevents invalid combinations at plan time
- **Early failure**: Terraform plan fails before any API calls
- **Clear error**: Explicit error message guides user

## Checklist

- ✅ Property in correct local (`body.properties.proximityPlacementGroup.id`)
- ✅ ForceNew NOT applicable (update allowed with deallocation)
- ✅ All logic EXACTLY replicated from provider:
  - ✅ DiffSuppressFunc (case-insensitive comparison)
  - ✅ Update behavior (tracked, requires deallocation per Azure API)
  - ✅ ConflictsWith (validated at plan time)
- ✅ Validations IMPLEMENTED in variables.tf:
  - ✅ ID format validation
  - ✅ ConflictsWith capacity_reservation_group_id
- ✅ Hidden fields checked (none found)
- ✅ Deferred work completed:
  - ✅ Reciprocal ConflictsWith validation implemented
  - ✅ `following.md` updated to "✅ Completed"
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof (completed above)
- ✅ Proof created (this document)
- ✅ `track.md` ready to update to "Pending for check"
- ✅ Self-Review: ONLY Task #32 content added (no fields from other tasks)

## Implementation Verification

**Variables.tf**:
- ✅ ID format validation added
- ✅ ConflictsWith validation added

**migrate_main.tf**:
- ✅ Existing state read logic added
- ✅ DiffSuppressFunc logic added (case-insensitive)
- ✅ `replace_triggers_external_values` entry added (state tracking)
- ✅ Body assignment added with proper nesting

**following.md**:
- ✅ Status updated to "✅ Completed" for deferred validation

All implementation matches EXACT provider behavior. No shortcuts taken.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #32 - proximity_placement_group_id

### Validation Results

✅ **DiffSuppressFunc Logic:** EXACTLY replicated with case-insensitive comparison pattern
- Read existing state via `data.azapi_resource.existing`
- Extract existing value: `try(data.azapi_resource.existing.output.properties.proximityPlacementGroup.id, null)`
- Compare: `lower(existing) == lower(desired)`
- Suppress diff: Use existing value when match found
- Implementation matches provider's `suppress.CaseDifference` exactly

✅ **ForceNew Logic:** Correctly NOT implemented as ForceNew (field allows updates with deallocation)
- Schema shows `ForceNew: false` (default)
- Provider Update method allows changes but requires deallocation
- Added to `replace_triggers_external_values` for state tracking (not force recreation)
- Correct Mode 1 pattern: `{ value = var.proximity_placement_group_id }`

✅ **Stable Keys:** Key is always present in `replace_triggers_external_values` with wrapped value

✅ **Phase Detection:** Field correctly placed in `local.body.properties.proximityPlacementGroup.id` (Create phase)

✅ **Type Conversion:** String → String, correct null handling

✅ **Null Handling:** Correctly propagates null semantics - null means "do not specify proximity placement group"

✅ **Validations:** ALL provider validations implemented in `variables.tf`:
1. **ID Format Validation:** Regex pattern matches expected format `/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.Compute/proximityPlacementGroups/{name}`
2. **ConflictsWith Validation:** Bidirectional constraint with `capacity_reservation_group_id` implemented correctly
   - Task #32 validates: `var.proximity_placement_group_id == null || var.capacity_reservation_group_id == null`
   - Task #12 validates: `var.capacity_reservation_group_id == null || var.proximity_placement_group_id == null`
   - Both validations present = complete bidirectional enforcement

✅ **Deferred Work Completion:** 
- Checked `following.md` for work deferred TO this task
- Found: Task #12 deferred ConflictsWith validation
- **COMPLETED:** Reciprocal validation implemented in `variables.tf`
- **UPDATED:** `following.md` status changed to "✅ Completed"

✅ **Deferred Work Recording:** No deferrals made by this task (no dependent fields referenced)

✅ **Edge Cases:** All properly analyzed and handled
- Null semantics: Field omitted from API when null
- Casing differences: DiffSuppressFunc handles Azure API uppercase bug
- Update behavior: Tracked but not ForceNew (allows update with deallocation)
- Safe references: Uses `try()` with null defaults

✅ **Assignment Path:** `properties.proximityPlacementGroup.id` - VERIFIED with Go code trace

✅ **Shared Path Merge Check:** No shared path conflicts - `proximityPlacementGroup` appears only once in merge

### Compliance Statement

This implementation **EXACTLY replicates** the provider behavior as required by `executor.md`:
- ✅ DiffSuppressFunc logic matches `suppress.CaseDifference` exactly (case-insensitive comparison)
- ✅ Update behavior correctly allows changes (not ForceNew) with Azure API enforced deallocation
- ✅ ValidateFunc replicated with proper ID format regex
- ✅ ConflictsWith constraint enforced bidirectionally with Task #12
- ✅ All validations at plan time (not deferred to Azure API)
- ✅ No deviations, simplifications, or "safer alternatives"

**Status:** APPROVED ✅

---
