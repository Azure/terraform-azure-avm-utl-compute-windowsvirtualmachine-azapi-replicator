# Task #77: plan.name Argument Implementation

## Summary
Implemented the `plan.name` argument as a Required field within the plan block. The field is ForceNew and maps directly to the Azure API's plan.name property at the root level of the VirtualMachine resource.

## Shadow Implementation

```hcl
locals {
  replace_triggers_external_values = {
    # ... existing fields ...
    plan_name = { value = var.plan != null ? var.plan.name : null }  # <-
  }
  
  body = merge(
    {
      properties = merge(
        # ... existing properties ...
      )
    },
    # ... existing root-level fields ...
    var.plan != null ? {
      plan = {
        name = var.plan.name  # <-
        # product = ... # Task #78
        # publisher = ... # Task #79
      }
    } : {}
  )
}
```

## Create Phase Verification

**Query Create Method:**

```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ...
  planRaw := d.Get("plan").([]interface{})
  plan := expandPlan(planRaw)
  
  // ...
  params := virtualmachines.VirtualMachine{
    Name:             pointer.To(id.VirtualMachineName),
    ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
    Location:         location.Normalize(d.Get("location").(string)),
    Identity:         identityExpanded,
    Plan:             plan,  // <-- Assigned to Plan field at root of VirtualMachine
    Properties: &virtualmachines.VirtualMachineProperties{
      // ... properties ...
    },
    Tags: tags.Expand(t),
  }
  // ...
  if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
  }
  // ...
}
```

**Pattern:** Single-phase creation. The `plan` field (including `plan.name`) is assigned during the primary `CreateOrUpdateThenPoll` operation.

**Classification:** This field is set before the primary create operation → belongs in `local.body`.

**Decision:** Implement in `local.body.plan.name` at root level (not inside properties).

## Assignment Path Verification

**Predicted Path:** `body.plan.name`

**Go Code Evidence:**

```go
// From expandPlan function:
func expandPlan(input []interface{}) *virtualmachines.Plan {
  if len(input) == 0 || input[0] == nil {
    return nil
  }

  raw := input[0].(map[string]interface{})

  return &virtualmachines.Plan{
    Name:      pointer.To(raw["name"].(string)),  // <-- Maps "name" field
    Product:   pointer.To(raw["product"].(string)),
    Publisher: pointer.To(raw["publisher"].(string)),
  }
}

// In resourceWindowsVirtualMachineCreate:
planRaw := d.Get("plan").([]interface{})
plan := expandPlan(planRaw)  // <-- Returns *virtualmachines.Plan

params := virtualmachines.VirtualMachine{
  Plan: plan,  // <-- Direct assignment to Plan field at VirtualMachine struct root
  Properties: &virtualmachines.VirtualMachineProperties{
    // ...
  },
}
```

**Struct Assignment Trace:**
1. `raw["name"].(string)` extracts the name value from Terraform config
2. `pointer.To(raw["name"].(string))` creates pointer to string
3. Assigned to `Plan.Name` field in returned struct
4. The `Plan` struct is assigned directly to `params.Plan` (not `params.Properties.Plan`)
5. `params` is of type `virtualmachines.VirtualMachine`
6. The `Plan` field is at the root level of the VirtualMachine struct, not inside Properties

**Verified Path:** `body.plan.name` (root level, NOT `body.properties.plan.name`)

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

**Go Source (planSchema function):**

```go
func planSchema() *pluginsdk.Schema {
  return &pluginsdk.Schema{
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
      Schema: map[string]*pluginsdk.Schema{
        "name": {
          Type:     pluginsdk.TypeString,
          Required: true,  // <-- Required field
          ForceNew: true,  // <-- ForceNew field
        },
        "product": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
        "publisher": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
      },
    },
  }
}
```

**Key Schema Properties:**
- **Type:** String
- **Required:** true
- **ForceNew:** true
- **Validations:** None found in provider source code

## Azure API Schema

**Query Result:**
From the full schema query in Task #76, the plan object structure is:

```
"plan": ObjectWithOptionalAttrs(map[string]Type{
  "name": String,
  "product": String,
  "promotionCode": String,
  "publisher": String
}, []string{"name", "product", "promotionCode", "publisher"})
```

**Property Path:** `body.plan.name`

**Field Type:** String

**Note:** All fields in the Azure API plan object are optional, but the provider enforces Required on name, product, and publisher. The provider does not expose the `promotionCode` field.

## Hidden Fields

**Expand Function Analysis:**

```go
func expandPlan(input []interface{}) *virtualmachines.Plan {
  if len(input) == 0 || input[0] == nil {
    return nil
  }

  raw := input[0].(map[string]interface{})

  return &virtualmachines.Plan{
    Name:      pointer.To(raw["name"].(string)),
    Product:   pointer.To(raw["product"].(string)),
    Publisher: pointer.To(raw["publisher"].(string)),
  }
}
```

**Hidden Fields Found:** None

The expand function directly maps the three schema fields (name, product, publisher) without adding any hidden/hardcoded values. The Azure API's `promotionCode` field is not set by the provider.

## Mapping

**Terraform → Azure API:**
- `plan.name` (string) → `plan.name` (string)

**Naming:** Direct mapping, no transformation needed (already camelCase in both).

## Special Handling

### ForceNew

**Provider Schema:** 
- The entire `plan` block is `ForceNew: true`
- The `plan.name` field is also `ForceNew: true`

**Implementation:**

Since `plan.name` is a Required field within an Optional block, I track it with a null-safe accessor:

```hcl
replace_triggers_external_values = {
  plan_name = { value = var.plan != null ? var.plan.name : null }
}
```

**Rationale:**
- When `var.plan == null`: The plan object doesn't exist, so plan_name trigger is null
- When `var.plan != null`: The plan.name field is guaranteed to exist (Required), so we track its value
- Changes to the name value will trigger replacement
- The key "plan_name" is always present (stable key pattern)

### Update Behavior

**Update Method Analysis:**

The Update method was searched for any references to "plan" field:

```go
func resourceWindowsVirtualMachineUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ... extensive update logic ...
  // NO MENTION of "plan" field anywhere
  // ...
}
```

**Finding:** The plan field is NOT mentioned in the Update method at all. This confirms that plan is ForceNew-only and cannot be updated in-place.

**Validation:** No update-time validations or restrictions found for plan.name.

## Deferred Work Completion

**Check following.md:**
No work was deferred to Task #77 in the following.md file.

## Edge Case Analysis

### Null Semantics
- **When `var.plan == null`:** The entire plan block is omitted from body (via empty map merge), and plan_name in replace_triggers is null
- **When `var.plan != null`:** The name field is Required (cannot be null/empty), so `var.plan.name` will always have a value
- **Terraform Validation:** The Required constraint on name ensures it's set when plan block is defined

### Boundary Conditions
- **Empty String:** The provider schema has no minimum length validation, so an empty string is technically allowed
- **Special Characters:** No character restrictions found in provider source
- **Unicode:** String type supports Unicode characters
- **Case Sensitivity:** No case normalization in expand function, so case-sensitive comparison

### Idempotency
- **Value Tracking:** The ForceNew trigger tracks the full value of `var.plan.name`
- **No Transformation:** Direct assignment without any transformation ensures idempotent behavior
- **Stable Key:** The "plan_name" key in replace_triggers is always present

### Safe References
- **Null Check:** `var.plan != null` check ensures safe access to `var.plan.name` in body
- **ForceNew Guard:** `var.plan != null ? var.plan.name : null` safely handles null plan in replace_triggers
- **No Nested Access:** Direct access to `.name` property (one level deep, safe)

### Azure API Compatibility
- **Direct Mapping:** The value is passed directly to Azure API without transformation
- **Type Match:** String to String mapping (exact type match)
- **No Hidden Fields:** Only the three provider-exposed fields are sent (name, product, publisher)

## Validation

**Provider Schema Validations:** None found

**Cross-Field Validations:** None found

The provider schema for `plan.name` has:
- `Required: true` - enforced by Terraform's type system when plan block is present
- `ForceNew: true` - implemented via replace_triggers_external_values
- No custom validation functions
- No ConflictsWith/RequiredWith/AtLeastOneOf constraints

Since the field is Required within the plan block, and the plan block itself is validated by Terraform's type system, no additional validations are needed in variables.tf.

## Checklist

- ✅ Property in correct local (body.plan.name at root level, not in properties)
- ✅ ForceNew tracked: `plan_name = { value = var.plan != null ? var.plan.name : null }`
- ✅ ALL logic EXACTLY replicated from provider (direct value assignment, no transformations)
- ✅ Validations reviewed: None required (Required constraint handled by Terraform type system)
- ✅ Hidden fields checked: None found in expandPlan function
- ✅ Deferred work in following.md: Not applicable (no deferring in this task)
- ✅ Deferred work from following.md: None deferred to Task #77
- ✅ Critical review: Null-safe access, stable keys, direct mapping
- ✅ Edge Case Analysis: Documented null semantics, boundary conditions, idempotency
- ✅ Proof created
- ✅ track.md ready to update to "Pending for check"
- ✅ Self-Review: Only plan.name implementation added, no other fields added

## Implementation Verification

**Files Modified:**
1. `migrate_main.tf`:
   - Added `plan_name` to `replace_triggers_external_values` with stable key pattern
   - Replaced comment placeholder with `name = var.plan.name` in plan block

**Files NOT Modified:**
- `variables.tf` - plan variable already exists with correct structure
- `migrate_variables.tf` - no new variables needed
- `migrate_validation.tf` - no validations needed

**Scope Verification:**
- ✅ Only implemented plan.name (this task)
- ✅ Did NOT implement plan.product (Task #78)
- ✅ Did NOT implement plan.publisher (Task #79)
- ✅ Did NOT add any hidden fields
- ✅ Did NOT add fields from other tasks

## Final Notes

This implementation EXACTLY replicates the provider behavior:
1. Direct value mapping from `var.plan.name` to `body.plan.name`
2. ForceNew tracking via replace_triggers with stable key pattern
3. Null-safe access using conditional check on parent block
4. No validations (relies on Terraform's Required type constraint)
5. No transformations or modifications to the value

The implementation follows Type 4 (Block Argument) task rules from executor.md:
- Parent skeleton verified (created by Task #76)
- Schema queried and analyzed
- Create phase verified (single-phase, primary operation)
- Assignment path traced and verified
- ForceNew implemented with stable keys
- Comment placeholder replaced in skeleton
- No sensitive handling needed (not marked sensitive)
- Edge cases analyzed
- Proof document created

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #77 - plan.name

### Validation Results

✅ **ForceNew Logic:** Correctly implemented using Mode 1 (Direct Value Tracking) with stable key pattern: `plan_name = { value = var.plan != null ? var.plan.name : null }`

✅ **Stable Keys:** The key "plan_name" is always present in `replace_triggers_external_values` (value changes from null to string or string to string, but key remains)

✅ **Phase Detection:** Field correctly placed in `local.body.plan.name` (root level, not in properties) - verified by Create method showing direct assignment to `params.Plan`

✅ **Type Conversion:** Direct mapping String → String, no conversion needed

✅ **Null Handling:** Correctly implements null-safe access: `var.plan != null ? var.plan.name : null` in ForceNew and `var.plan != null ? { plan = { name = var.plan.name } } : {}` in body

✅ **Validations:** None required - field is Required within the plan block, enforced by Terraform's type system. No custom ValidateFunc found in provider schema.

✅ **Deferred Work Completion:** No deferred work for this task (verified following.md)

✅ **Deferred Work Recording:** No deferrals made by this task (appropriate - plan.name is self-contained)

✅ **Edge Cases:** Properly analyzed - null semantics (null plan vs non-null plan), boundary conditions (empty string, special chars), idempotency (direct value tracking), safe references (null check before access)

✅ **Sensitive/WriteOnly Check:** Field is NOT marked Sensitive in provider schema, correctly placed in `body` (not `sensitive_body`)

✅ **Shared Path Merge Check:** No shared paths - plan block is a single conditional merge at root level, no duplicate keys

✅ **Assignment Path Verification:** Correctly traced - `params.Plan` is assigned at VirtualMachine root level, not inside Properties. Implementation matches: `body.plan.name` (not `body.properties.plan.name`)

✅ **Schema Compliance:** Matches provider schema exactly:
- Required: true (enforced by Terraform when plan block exists)
- ForceNew: true (implemented in replace_triggers)
- Type: String (matches)

✅ **Expand Function Analysis:** Reviewed expandPlan function - no hidden fields, direct mapping of name/product/publisher only

✅ **Value Design Intent:** ForceNew trigger tracks FULL value of `var.plan.name`, not just presence. This correctly detects changes like `"plan1"` → `"plan2"`, not just `null` → `"plan1"`.

✅ **Terraform Syntax:** Only valid parameters used - `value` field in replace_triggers entry (correct Terraform/AzAPI syntax)

✅ **Scope Verification:** Only plan.name implemented (Task #77), does NOT implement plan.product (Task #78) or plan.publisher (Task #79)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **Direct Value Mapping:** `var.plan.name` → `body.plan.name` with no transformations
2. **ForceNew Tracking:** Stable key pattern with full value tracking
3. **Null Safety:** Conditional check on parent block prevents accessing undefined properties
4. **No Validations Needed:** Required constraint handled by Terraform's type system (plan.name is Required field within the plan object type)
5. **Correct Nesting:** Root level assignment (not in properties) matches provider's struct assignment
6. **No Hidden Fields:** expandPlan function only maps the three exposed fields

No deviations, simplifications, or "safer alternatives" were found. The implementation follows executor.md rules precisely:
- Type 4 (Block Argument) workflow followed
- Parent skeleton verified (Task #76)
- Create phase verified (single-phase, primary operation)
- Assignment path traced correctly
- ForceNew implemented with stable keys per executor.md lines 208-211
- No validations needed (Required handled by type system)

**Status:** APPROVED ✅

---
