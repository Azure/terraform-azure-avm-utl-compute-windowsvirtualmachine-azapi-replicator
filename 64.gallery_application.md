# Task #64 - gallery_application Block Structure Skeleton

## Summary
Created structure skeleton for `gallery_application` block with conditional rendering based on whether the list is non-null and non-empty. The skeleton includes comment placeholders for all 6 child arguments to be implemented by Tasks #65-70.

## Shadow Implementation
```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... other properties ...
        {
          diagnosticsProfile = {
            bootDiagnostics = var.boot_diagnostics != null ? merge(
              {
                enabled = true
              },
              var.boot_diagnostics.storage_account_uri != null ? {
                storageUri = var.boot_diagnostics.storage_account_uri
              } : {}
            ) : {
              enabled    = false
              storageUri = ""
            }
          }
        },
        var.gallery_application != null && length(var.gallery_application) > 0 ? {  # <-
          applicationProfile = {  # <-
            galleryApplications = [  # <-
              for app in var.gallery_application : {  # <-
                # packageReferenceId = ... # Task #65  # <-
                # enableAutomaticUpgrade = ... # Task #66  # <-
                # configurationReference = ... # Task #67  # <-
                # order = ... # Task #68  # <-
                # tags = ... # Task #69  # <-
                # treatFailureAsDeploymentFailure = ... # Task #70  # <-
              }  # <-
            ]  # <-
          }  # <-
        } : {}  # <-
      )
    }
  )
}
```

## Provider Schema

From `VirtualMachineGalleryApplicationSchema()` in `internal/services/compute/virtual_machine.go`:

```go
func VirtualMachineGalleryApplicationSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 100,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"version_id": {
					Type:         pluginsdk.TypeString,
					Required:     true,
					ValidateFunc: galleryapplicationversions.ValidateApplicationVersionID,
				},

				"automatic_upgrade_enabled": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  false,
				},

				// Example: https://mystorageaccount.blob.core.windows.net/configurations/settings.config
				"configuration_blob_uri": {
					Type:         pluginsdk.TypeString,
					Optional:     true,
					ValidateFunc: validation.IsURLWithHTTPorHTTPS,
				},

				"order": {
					Type:         pluginsdk.TypeInt,
					Optional:     true,
					Default:      0,
					ValidateFunc: validation.IntBetween(0, math.MaxInt32),
				},

				// NOTE: Per the service team, "this is a pass through value that we just add to the model but don't depend on. It can be any string."
				"tag": {
					Type:         pluginsdk.TypeString,
					Optional:     true,
					ValidateFunc: validation.StringIsNotEmpty,
				},

				"treat_failure_as_deployment_failure_enabled": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  false,
				},
			},
		},
		ConflictsWith: []string{
			"os_managed_disk_id",
		},
	}
}
```

**Key Details:**
- **Type:** List (MaxItems: 100)
- **Required:** No (Optional: true)
- **Child Arguments:**
  - `version_id` - Required string
  - `automatic_upgrade_enabled` - Optional bool (Default: false)
  - `configuration_blob_uri` - Optional string
  - `order` - Optional int (Default: 0)
  - `tag` - Optional string
  - `treat_failure_as_deployment_failure_enabled` - Optional bool (Default: false)

## Create Phase Verification

From `resourceWindowsVirtualMachineCreate()` in the Create method:

```go
params := virtualmachines.VirtualMachine{
	Name:             pointer.To(id.VirtualMachineName),
	ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
	Location:         location.Normalize(d.Get("location").(string)),
	Identity:         identityExpanded,
	Plan:             plan,
	Properties: &virtualmachines.VirtualMachineProperties{
		ApplicationProfile: &virtualmachines.ApplicationProfile{
			GalleryApplications: expandVirtualMachineGalleryApplication(d.Get("gallery_application").([]interface{})),
		},
		// ... other properties
	},
	Tags: tags.Expand(t),
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Pattern:** Single-phase creation
- The `gallery_application` block is part of the primary `CreateOrUpdateThenPoll` operation
- No post-creation operations for this field
- Assignment happens before the primary create call

**Decision:** This field belongs in `local.body.properties.applicationProfile.galleryApplications` (Create phase)

## Assignment Path Verification

**Predicted Path:** `properties.applicationProfile.galleryApplications`

**Go Code Evidence:**

1. **Field assignment in Create method:**
```go
Properties: &virtualmachines.VirtualMachineProperties{
    ApplicationProfile: &virtualmachines.ApplicationProfile{
        GalleryApplications: expandVirtualMachineGalleryApplication(d.Get("gallery_application").([]interface{})),
    },
}
```

2. **Struct construction shows:**
   - `Properties` → `ApplicationProfile` → `GalleryApplications`
   - Direct assignment without intermediate pointer assignments

**Verified Path:** `properties.applicationProfile.galleryApplications` ✅

**Path Comparison:** Predicted path matches verified path exactly.

## Hidden Fields Detection

From `expandVirtualMachineGalleryApplication()` function:

```go
func expandVirtualMachineGalleryApplication(input []interface{}) *[]virtualmachines.VMGalleryApplication {
	out := make([]virtualmachines.VMGalleryApplication, 0)
	if len(input) == 0 {
		return &out
	}

	for _, v := range input {
		config := v.(map[string]interface{})
		app := &virtualmachines.VMGalleryApplication{
			PackageReferenceId:              config["version_id"].(string),
			ConfigurationReference:          pointer.To(config["configuration_blob_uri"].(string)),
			Order:                           pointer.To(int64(config["order"].(int))),
			Tags:                            pointer.To(config["tag"].(string)),
			EnableAutomaticUpgrade:          pointer.To(config["automatic_upgrade_enabled"].(bool)),
			TreatFailureAsDeploymentFailure: pointer.To(config["treat_failure_as_deployment_failure_enabled"].(bool)),
		}

		out = append(out, *app)
	}

	return &out
}
```

**Analysis:**
- All fields in the expand function correspond to schema fields:
  - `PackageReferenceId` ← `version_id` (schema field)
  - `ConfigurationReference` ← `configuration_blob_uri` (schema field)
  - `Order` ← `order` (schema field)
  - `Tags` ← `tag` (schema field)
  - `EnableAutomaticUpgrade` ← `automatic_upgrade_enabled` (schema field)
  - `TreatFailureAsDeploymentFailure` ← `treat_failure_as_deployment_failure_enabled` (schema field)

**Hidden Fields:** None detected ✅

## Validation Analysis

### Schema-Level Validations

From the provider schema:

```go
ConflictsWith: []string{
    "os_managed_disk_id",
}
```

**Analysis:**
- `gallery_application` has `ConflictsWith: ["os_managed_disk_id"]`
- Task #26 (os_managed_disk_id) has status "Failed" in track.md
- The variable `var.os_managed_disk_id` does not exist yet

**Decision:**
- **DEFERRED to Task #26:** Cross-field validation that gallery_application and os_managed_disk_id cannot be used together
- Recorded in `following.md` for implementation when Task #26's variable is created
- Since this is a Type 3 (Block Structure Skeleton) task with no actual field values, and the referenced variable doesn't exist, deferral is the correct approach per executor.md rules

## Mapping (snake_case → camelCase)

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `gallery_application` | `applicationProfile.galleryApplications` | Block becomes array under applicationProfile |
| `version_id` | `packageReferenceId` | Task #65 |
| `automatic_upgrade_enabled` | `enableAutomaticUpgrade` | Task #66 |
| `configuration_blob_uri` | `configurationReference` | Task #67 |
| `order` | `order` | Task #68 (same name) |
| `tag` | `tags` | Task #69 (singular → plural) |
| `treat_failure_as_deployment_failure_enabled` | `treatFailureAsDeploymentFailure` | Task #70 |

## Special Handling

### Conditional Rendering
The block uses a condition to check both:
1. `var.gallery_application != null` - Variable is set
2. `length(var.gallery_application) > 0` - List has items

This ensures the `applicationProfile` object is only created when there are actual gallery applications to configure.

### List Transformation
Uses `for` expression to transform Terraform list into array of API objects:
```hcl
for app in var.gallery_application : {
  # fields populated by child tasks
}
```

### Empty Object Fallback
When condition is false, returns empty object `{}` to ensure the merge operation doesn't fail and the block is omitted from the API payload.

## Edge Case Analysis

**Null Semantics:**
- `null` → applicationProfile not included in API payload (correct - field is optional)
- Empty list `[]` → applicationProfile not included (correct - no applications to install)

**Boundary Conditions:**
- MaxItems: 100 enforced by provider schema validation
- Empty list handled correctly (condition prevents creating empty applicationProfile)

**Idempotency:**
- List order is preserved by Terraform list ordering
- Each item in list is independent
- Safe for multiple applies

**Safe References:**
- Length check prevents accessing empty list
- Null check prevents accessing undefined variable
- For loop safely iterates over validated non-empty list

## Child Tasks Ready for Delegation

All child argument tasks are now ready for implementation:

| Task # | Field | Type | Required | Delegatable |
|--------|-------|------|----------|-------------|
| #65 | version_id | Argument | Yes | ✅ Ready |
| #66 | automatic_upgrade_enabled | Argument | No | ✅ Ready |
| #67 | configuration_blob_uri | Argument | No | ✅ Ready |
| #68 | order | Argument | No | ✅ Ready |
| #69 | tag | Argument | No | ✅ Ready |
| #70 | treat_failure_as_deployment_failure_enabled | Argument | No | ✅ Ready |

## Deferred Work

### Validations Deferred to Other Tasks

**Deferred to Task #26 (os_managed_disk_id):**
- Cross-field validation: `gallery_application` and `os_managed_disk_id` are mutually exclusive (ConflictsWith)
- Reason: Task #26 has status "Failed" - variable doesn't exist yet
- Recorded in `following.md` for completion when Task #26's variable is available

## Checklist

- ✅ Skeleton structure created with conditional logic
- ✅ Comment placeholders added for all 6 child fields
- ✅ Hidden fields checked (none found)
- ✅ Assignment path verified from Go source
- ✅ Create phase verified (single-phase, part of primary create)
- ✅ Conditional rendering handles null and empty list cases
- ✅ Edge cases analyzed (null semantics, boundaries, idempotency)
- ✅ Validations analyzed - ConflictsWith deferred to Task #26 (variable doesn't exist)
- ✅ Deferred work recorded in following.md
- ✅ Proof document created
- ✅ Track.md ready for status update

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #64 - gallery_application

### Issues Identified

#### Issue 1: Missing ConflictsWith Validation Documentation and Deferral

**Problem:**
The executor implemented the skeleton correctly but failed to document and defer the ConflictsWith validation found in the provider schema.

**Provider Schema Evidence:**
```go
func VirtualMachineGalleryApplicationSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 100,
		Elem: &pluginsdk.Resource{
			// ... schema fields ...
		},
		ConflictsWith: []string{
			"os_managed_disk_id",
		},
	}
}
```

**Why This Violates executor.md:**
From executor.md line 122-126:
> **Category 2 - Cross-Field Constraints (MUST ALL):**
> `ConflictsWith`, `RequiredWith`, `ExactlyOneOf`, `AtLeastOneOf` → Modify field's variable in `variables.tf` to add `validation` block (ownership rule). If referenced var doesn't exist, document & defer to later task that creates that variable.

The executor must identify ALL cross-field constraints and either implement them or defer them with proper documentation.

**Expected Behavior:**
- Identify the ConflictsWith constraint in schema
- Check if `var.os_managed_disk_id` exists (Task #26 status = Failed, so it doesn't exist)
- Document the deferral in proof document
- Record the deferral in `following.md`

**Root Cause:**
Executor completed the skeleton implementation but didn't perform comprehensive validation analysis as required by executor.md.

### Corrections Made

#### Fix 1: Added Validation Analysis Section to Proof Document

**Changed Files:**
- `64.gallery_application.md`: Added "Validation Analysis" section documenting the ConflictsWith constraint and deferral decision

**New Content Added:**
```markdown
## Validation Analysis

### Schema-Level Validations

From the provider schema:

```go
ConflictsWith: []string{
    "os_managed_disk_id",
}
```

**Analysis:**
- `gallery_application` has `ConflictsWith: ["os_managed_disk_id"]`
- Task #26 (os_managed_disk_id) has status "Failed" in track.md
- The variable `var.os_managed_disk_id` does not exist yet

**Decision:**
- **DEFERRED to Task #26:** Cross-field validation that gallery_application and os_managed_disk_id cannot be used together
- Recorded in `following.md` for implementation when Task #26's variable is created
- Since this is a Type 3 (Block Structure Skeleton) task with no actual field values, and the referenced variable doesn't exist, deferral is the correct approach per executor.md rules
```

**Why This is Correct:**
This documents the validation requirement, explains why it cannot be implemented now (referenced variable doesn't exist), and records the deferral for future completion.

#### Fix 2: Recorded Deferral in following.md

**Changed Files:**
- `following.md`: Added row for deferred validation

**New Row Added:**
```markdown
| #64 | #26 | Validation | Cross-field validation: gallery_application cannot be used with os_managed_disk_id (ConflictsWith) | Pending |
```

**Why This is Correct:**
Per executor.md lines 95-103, when deferring work to other tasks, it must be recorded in `following.md` with clear description and proper task references.

#### Fix 3: Updated Checklist in Proof Document

**Changed Files:**
- `64.gallery_application.md`: Enhanced checklist to reflect validation work

**Updates Made:**
- Added: `✅ Validations analyzed - ConflictsWith deferred to Task #26 (variable doesn't exist)`
- Added: `✅ Deferred work recorded in following.md`

**Why This is Correct:**
The checklist must reflect all work performed, including validation analysis and deferral recording.

#### Fix 4: Added Deferred Work Section

**Changed Files:**
- `64.gallery_application.md`: Added "Deferred Work" section before checklist

**New Section:**
```markdown
## Deferred Work

### Validations Deferred to Other Tasks

**Deferred to Task #26 (os_managed_disk_id):**
- Cross-field validation: `gallery_application` and `os_managed_disk_id` are mutually exclusive (ConflictsWith)
- Reason: Task #26 has status "Failed" - variable doesn't exist yet
- Recorded in `following.md` for completion when Task #26's variable is available
```

**Why This is Correct:**
Clear documentation of what was deferred, why, and where it was recorded ensures traceability.

### Verification

**Implementation Correctness:**
- ✅ Skeleton structure correctly implements conditional rendering
- ✅ Assignment path `properties.applicationProfile.galleryApplications` is correct
- ✅ Comment placeholders for all 6 child tasks are present
- ✅ No code changes needed to migrate_main.tf - structure is correct
- ✅ Hidden fields analysis complete (none found)

**Validation Completeness:**
- ✅ ConflictsWith constraint identified from provider schema
- ✅ Deferral decision correct (referenced variable doesn't exist)
- ✅ Deferral documented in proof document
- ✅ Deferral recorded in following.md

**Edge Cases:**
- ✅ Null handling correct (`var.gallery_application != null`)
- ✅ Empty list handling correct (`length(var.gallery_application) > 0`)
- ✅ Safe references (null check before length check)
- ✅ Idempotency maintained (list ordering preserved)

### Compliance Statement

After corrections, this implementation now EXACTLY follows executor.md requirements:
- ✅ Skeleton structure created per Type 3 task requirements
- ✅ All validations identified and analyzed
- ✅ Cross-field constraints properly deferred with documentation
- ✅ Deferral tracking in following.md per executor.md lines 95-103
- ✅ Comprehensive proof document with all required sections

**Status:** CORRECTED AND APPROVED ✅

---
