# Task #4 - network_interface_ids - Proof Document

## Summary

Migrated the `network_interface_ids` argument from `azurerm_windows_virtual_machine` to `azapi_resource`. This field is Required and updatable (with deallocation). The provider automatically marks the first network interface as primary.

## Shadow Implementation

```hcl
# In migrate_main.tf
locals {
  body = {
    properties = merge(
      {
        networkProfile = {  # <-
          networkInterfaces = [  # <-
            for i, nic_id in var.network_interface_ids : {  # <-
              id = nic_id  # <-
              properties = {  # <-
                primary = i == 0  # <-
              }
            }
          ]
        }
      }
    )
  }
}
```

## Create Phase Verification

**Query:** Used `query_terraform_block_implementation_source_code` with `entrypoint_name=create`.

**Pattern:** Single-phase operation (one `CreateOrUpdateThenPoll` call).

**Field Classification:** Create phase - field is assigned before primary `CreateOrUpdateThenPoll`.

**Go Code Evidence:**
```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	networkInterfaceIdsRaw := d.Get("network_interface_ids").([]interface{})
	networkInterfaceIds := expandVirtualMachineNetworkInterfaceIDs(networkInterfaceIdsRaw)
	
	params := virtualmachines.VirtualMachine{
		// ...
		Properties: &virtualmachines.VirtualMachineProperties{
			// ...
			NetworkProfile: &virtualmachines.NetworkProfile{
				NetworkInterfaces: &networkInterfaceIds,
			},
			// ...
		},
		// ...
	}
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
	// ...
}
```

**Decision:** Implement in `local.body` (Create phase).

## Assignment Path Verification

**Predicted Path:** `body.properties.networkProfile.networkInterfaces`

**Go Code Evidence:**
```go
// In Create function
params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		NetworkProfile: &virtualmachines.NetworkProfile{
			NetworkInterfaces: &networkInterfaceIds,
		},
	},
}
```

**Tracing:**
1. `params.Properties` → `&virtualmachines.VirtualMachineProperties{...}` (adds `properties` nesting)
2. `params.Properties.NetworkProfile` → `&virtualmachines.NetworkProfile{...}` (adds `networkProfile` nesting)
3. `params.Properties.NetworkProfile.NetworkInterfaces` → `&networkInterfaceIds` (field assignment)

**Verified Path:** `properties.networkProfile.networkInterfaces`

**Path Comparison:** ✅ Match - predicted path matches verified path.

## Provider Schema

**Schema Definition:**
```go
"network_interface_ids": {
	Type:     pluginsdk.TypeList,
	Required: true,
	MinItems: 1,
	Elem: &pluginsdk.Schema{
		Type:         pluginsdk.TypeString,
		ValidateFunc: commonids.ValidateNetworkInterfaceID,
	},
},
```

**Schema Details:**
- **Type:** `TypeList` (list of strings)
- **Required:** `true`
- **ForceNew:** `false` (can be updated)
- **MinItems:** `1` (at least one network interface required)
- **Validation:** `commonids.ValidateNetworkInterfaceID` (validates network interface ID format)

## Azure API Schema

**Path:** `body.properties.networkProfile.networkInterfaces`

**Type:** `List(ObjectWithOptionalAttrs(map[string]Type{"id":String, "properties":ObjectWithOptionalAttrs(map[string]Type{"deleteOption":String, "primary":Bool}, []string{"deleteOption", "primary"})}, []string{"id", "properties"}))`

**Description:** "Specifies the list of resource Ids for the network interfaces associated with the virtual machine."

**Structure:**
- Array of objects
- Each object has:
  - `id` (string): Network interface resource ID
  - `properties` (object, optional):
    - `primary` (bool, optional): Indicates if this is the primary network interface
    - `deleteOption` (string, optional): Delete option for the network interface

## Hidden Fields

None. The provider only sets `id` and `properties.primary` fields. The `deleteOption` field is not managed by the provider for this resource.

## Mapping

| Provider Field | Azure API Path |
|----------------|----------------|
| `network_interface_ids` | `properties.networkProfile.networkInterfaces` |

**Transformation:**
- Provider: List of strings (network interface IDs)
- API: Array of objects with `id` and `properties.primary`
- First element (index 0) gets `primary = true`, others get `primary = false`

## Special Handling

### Expand Function

**Go Code:**
```go
func expandVirtualMachineNetworkInterfaceIDs(input []interface{}) []virtualmachines.NetworkInterfaceReference {
	output := make([]virtualmachines.NetworkInterfaceReference, 0)

	for i, v := range input {
		output = append(output, virtualmachines.NetworkInterfaceReference{
			Id: pointer.To(v.(string)),
			Properties: &virtualmachines.NetworkInterfaceReferenceProperties{
				Primary: pointer.To(i == 0),
			},
		})
	}

	return output
}
```

**Logic:**
- Iterates through the list of network interface IDs
- For each ID at index `i`:
  - Sets `Id` to the network interface ID
  - Sets `Properties.Primary` to `true` if index is 0, `false` otherwise

**Implementation:** Use `for` expression with index to replicate this behavior exactly.

### Validation

**Validation from Schema:**
- `MinItems: 1` - At least one network interface required

**Implementation:** The variable already has validation in `variables.tf`:
```hcl
variable "network_interface_ids" {
  type        = list(string)
  description = "(Required). A list of Network Interface IDs which should be attached to this Virtual Machine. The first Network Interface ID in this list will be the Primary Network Interface on the Virtual Machine."
  nullable    = false
}
```

The `nullable = false` ensures the list is not null. However, we need to add validation for minimum items.

**Additional Validation Needed:**
```hcl
validation {
  condition     = length(var.network_interface_ids) >= 1
  error_message = "At least one Network Interface ID must be provided."
}
```

### Update Behavior

**From Update Method:**
```go
if d.HasChange("network_interface_ids") {
	shouldUpdate = true

	// Code="CannotAddOrRemoveNetworkInterfacesFromARunningVirtualMachine"
	// Message="Secondary network interfaces cannot be added or removed from a running virtual machine.
	shouldShutDown = true

	// @tombuildsstuff: after testing shutting it down isn't sufficient - we need a full deallocation
	shouldDeallocate = true

	networkInterfaceIdsRaw := d.Get("network_interface_ids").([]interface{})
	networkInterfaceIds := expandVirtualMachineNetworkInterfaceIDs(networkInterfaceIdsRaw)

	update.Properties.NetworkProfile = &virtualmachines.NetworkProfile{
		NetworkInterfaces: &networkInterfaceIds,
	}
}
```

**Update Behavior:**
- Field CAN be updated (not ForceNew)
- Update requires VM to be deallocated
- Update is performed via standard Update API

**Implementation:** No ForceNew handling needed - this field is updatable. AzAPI will handle the update naturally.

## Deferred Work Completion

Checked `following.md` - file does not exist. No deferred work to complete.

## Critical Review & Edge Case Analysis

### Null Semantics

- **Input:** `var.network_interface_ids` is `nullable = false`, so it cannot be null
- **Minimum:** Schema enforces `MinItems: 1`, so at least one NIC must be provided
- **Meaning:** Field is always present and non-empty

### Boundary Conditions

- **Empty list:** Prevented by validation (`length >= 1`)
- **Single NIC:** Works correctly - marked as primary (index 0)
- **Multiple NICs:** First is primary, rest are not primary
- **Order matters:** First NIC in list becomes primary NIC on VM

### Idempotency

- **Same order:** Produces identical API payload - idempotent ✅
- **Different order:** Produces different payload (different primary) - NOT idempotent by design
- **Provider behavior:** Order-dependent behavior is intentional - first NIC is always primary

### Safe References

- **Index access:** Using `for i, nic_id in var.network_interface_ids` safely iterates with index
- **Comparison:** `i == 0` safely identifies first element
- **No null checks needed:** Variable is non-nullable and validated for minimum length

### Edge Cases

1. **Single NIC:** `["nic1"]` → `[{id: "nic1", properties: {primary: true}}]` ✅
2. **Two NICs:** `["nic1", "nic2"]` → First gets `primary: true`, second gets `primary: false` ✅
3. **Reordering:** Changing order changes which NIC is primary - expected behavior ✅

## Checklist

- ✅ Property in correct local (`body.properties.networkProfile.networkInterfaces`)
- ✅ ForceNew NOT needed (field is updatable)
- ✅ Logic EXACTLY replicated from provider (primary = index 0)
- ✅ Validation IMPLEMENTED in variables.tf (length >= 1)
- ✅ No TODO comment needed (not a sensitive field migration)
- ✅ Hidden fields checked (none - only id and primary managed)
- ✅ Deferred work checked (none applicable)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof (above)
- ✅ Proof created (this document)
- ✅ track.md ready to be updated to Pending for check
- ✅ Self-Review: Only implemented network_interface_ids (Task #4), no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #4 - network_interface_ids

### Validation Results

✅ **ForceNew Logic:** Not required - field is updatable (ForceNew: false in schema)
✅ **Stable Keys:** networkProfile appears only once in merge - no shared path conflicts
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** Correct conversion from list(string) to array of objects with id and properties.primary
✅ **Null Handling:** Variable is non-nullable, no null checks needed in implementation
✅ **Validations:** MinItems: 1 validation correctly implemented in variables.tf (length >= 1)
✅ **Primary Logic:** Exact replication - `primary = i == 0` matches provider's expand function
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** Comprehensive analysis including single NIC, multiple NICs, and reordering scenarios

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The expand function's logic of marking the first network interface (index 0) as primary is precisely replicated using `for i, nic_id in var.network_interface_ids` with `primary = i == 0`. The required validation for minimum items is correctly implemented. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
