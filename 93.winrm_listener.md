# Task #93 - winrm_listener - Structure Skeleton

## Summary

Created the structure skeleton for the `winrm_listener` block in the Windows Configuration. This block is a set of listeners for WinRM configuration with comment placeholders for individual fields to be implemented by child tasks #94 (protocol) and #95 (certificate_url).

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      var.admin_username != null ? {
        osProfile = merge(
          {
            windowsConfiguration = merge(
              # ... other windowsConfiguration fields ...
              var.winrm_listener != null && length(var.winrm_listener) > 0 ? {  # <-
                winRM = {  # <-
                  listeners = [  # <-
                    for listener in var.winrm_listener : {  # <-
                      # protocol = ... # Task #94  # <-
                      # certificateUrl = ... # Task #95  # <-
                    }  # <-
                  ]  # <-
                }  # <-
              } : {}  # <-
            )
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Create Method Query

From `resourceWindowsVirtualMachineCreate`:

```go
params.Properties.OsProfile = &virtualmachines.OSProfile{
    AdminPassword:            pointer.To(d.Get("admin_password").(string)),
    AdminUsername:            pointer.To(d.Get("admin_username").(string)),
    ComputerName:             pointer.To(computerName),
    AllowExtensionOperations: pointer.To(allowExtensionOperations),
    WindowsConfiguration: &virtualmachines.WindowsConfiguration{
        ProvisionVMAgent:       pointer.To(provisionVMAgent),
        EnableAutomaticUpdates: pointer.To(autoUpdatesEnabled),
        WinRM:                  expandWinRMListener(d.Get("winrm_listener").(*pluginsdk.Set).List()),
    },
    Secrets: secrets,
}
```

### Pattern Classification

**Pattern:** Single-phase create operation

**Field Assignment:** The `winrm_listener` field is expanded and assigned to `WindowsConfiguration.WinRM` during the primary `CreateOrUpdateThenPoll` operation in the Create method.

**Decision:** This block belongs in `local.body.properties.osProfile.windowsConfiguration.winRM` (Create phase).

## Assignment Path Verification

### Predicted Path

`body.properties.osProfile.windowsConfiguration.winRM.listeners`

### Provider Code Evidence

```go
// From resourceWindowsVirtualMachineCreate
params := virtualmachines.VirtualMachine{
    Properties: &virtualmachines.VirtualMachineProperties{
        OsProfile: &virtualmachines.OSProfile{
            WindowsConfiguration: &virtualmachines.WindowsConfiguration{
                WinRM: expandWinRMListener(d.Get("winrm_listener").(*pluginsdk.Set).List()),
            },
        },
    },
}

// From expandWinRMListener in shared_schema.go
func expandWinRMListener(input []interface{}) *virtualmachines.WinRMConfiguration {
	listeners := make([]virtualmachines.WinRMListener, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		listener := virtualmachines.WinRMListener{
			Protocol: pointer.To(virtualmachines.ProtocolTypes(raw["protocol"].(string))),
		}

		certificateUrl := raw["certificate_url"].(string)
		if certificateUrl != "" {
			listener.CertificateURL = pointer.To(certificateUrl)
		}

		listeners = append(listeners, listener)
	}

	return &virtualmachines.WinRMConfiguration{
		Listeners: &listeners,
	}
}
```

### Verified Path

Following the assignments:
1. `params.Properties` = `&virtualmachines.VirtualMachineProperties{...}` → adds `properties` nesting
2. `Properties.OsProfile` = `&virtualmachines.OSProfile{...}` → adds `osProfile` nesting
3. `OsProfile.WindowsConfiguration` = `&virtualmachines.WindowsConfiguration{...}` → adds `windowsConfiguration` nesting
4. `WindowsConfiguration.WinRM` = `expandWinRMListener(...)` → adds `winRM` nesting
5. `WinRMConfiguration.Listeners` = `&listeners` → adds `listeners` array

**Final verified path:** `properties.osProfile.windowsConfiguration.winRM.listeners`

### Path Comparison

✅ **MATCH** - Predicted and verified paths are identical.

## Provider Schema

From `winRmListenerSchemaVM()` in `shared_schema.go`:

```go
func winRmListenerSchemaVM() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeSet,
		Optional: true,
		// Whilst the SDK allows you to modify this, the API does not:
		//   Code="PropertyChangeNotAllowed"
		//   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
		//   Target="windowsConfiguration.winRM.listeners"
		ForceNew: true,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"protocol": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
					ValidateFunc: validation.StringInSlice([]string{
						string(virtualmachines.ProtocolTypesHTTP),
						string(virtualmachines.ProtocolTypesHTTPS),
					}, false),
				},

				"certificate_url": {
					Type:         pluginsdk.TypeString,
					Optional:     true,
					ForceNew:     true,
					ValidateFunc: keyVaultValidate.NestedItemId,
				},
			},
		},
		ConflictsWith: []string{
			"os_managed_disk_id",
		},
	}
}
```

**Key characteristics:**
- **Type:** `TypeSet` (set of objects)
- **Optional:** true
- **ForceNew:** true (entire block)
- **Fields:**
  - `protocol`: Required, ForceNew, validated against HTTP/HTTPS
  - `certificate_url`: Optional, ForceNew, validated as Key Vault nested item ID

## Azure API Schema

Query result for `body.properties.osProfile.windowsConfiguration.winRM`:

```
ObjectWithOptionalAttrs(
  map[string]Type{
    "listeners": List(
      ObjectWithOptionalAttrs(
        map[string]Type{
          "certificateUrl": String,
          "protocol": String
        },
        []string{"certificateUrl", "protocol"}
      )
    )
  },
  []string{"listeners"}
)
```

**Azure API Structure:**
- `winRM.listeners` is an array of listener objects
- Each listener has:
  - `protocol`: String (optional in API schema)
  - `certificateUrl`: String (optional in API schema)

## Hidden Fields Check

### Expand Function Analysis

From `expandWinRMListener`:

```go
func expandWinRMListener(input []interface{}) *virtualmachines.WinRMConfiguration {
	listeners := make([]virtualmachines.WinRMListener, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		listener := virtualmachines.WinRMListener{
			Protocol: pointer.To(virtualmachines.ProtocolTypes(raw["protocol"].(string))),
		}

		certificateUrl := raw["certificate_url"].(string)
		if certificateUrl != "" {
			listener.CertificateURL = pointer.To(certificateUrl)
		}

		listeners = append(listeners, listener)
	}

	return &virtualmachines.WinRMConfiguration{
		Listeners: &listeners,
	}
}
```

**Analysis:**
- ✅ No hidden fields detected
- The expand function only processes `protocol` and `certificate_url` from the schema
- No additional fields are hardcoded or added
- The function creates a clean `WinRMConfiguration` with `Listeners` array

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|-------------------------|----------------------|
| `winrm_listener`        | `winRM`             |
| `listeners` array       | `listeners` array   |
| `protocol`              | `protocol`          |
| `certificate_url`       | `certificateUrl`    |

## Special Handling

### ForceNew

**Provider Schema:**
- Block-level: `ForceNew: true`
- `protocol`: `ForceNew: true`
- `certificate_url`: `ForceNew: true`

**Comment from provider source:**
```go
// Whilst the SDK allows you to modify this, the API does not:
//   Code="PropertyChangeNotAllowed"
//   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
//   Target="windowsConfiguration.winRM.listeners"
```

**Implementation:** ForceNew for this block and all its fields will be handled by child tasks #94 and #95 when they implement the individual arguments.

### Validation

**From provider schema:**
- `protocol`: `StringInSlice(["Http", "Https"], false)` - enforces valid protocol values
- `certificate_url`: `keyVaultValidate.NestedItemId` - validates Key Vault certificate URL format

**Implementation:** Validations will be implemented by child tasks #94 (protocol) and #95 (certificate_url).

### Conditional Logic

The block is conditionally included only when:
```hcl
var.winrm_listener != null && length(var.winrm_listener) > 0
```

This ensures the `winRM` configuration is only added when users provide at least one listener.

## Child Task Readiness

The following child tasks are now **READY FOR DELEGATION**:

- **Task #94** - `winrm_listener.protocol` (Argument, Required)
- **Task #95** - `winrm_listener.certificate_url` (Argument, Optional)

Both tasks can now proceed as the parent block skeleton structure is in place.

## Edge Case Analysis

### Null Semantics

**When `winrm_listener` is `null`:**
- The entire `winRM` configuration is omitted from the request
- Azure API will not configure WinRM listeners (default behavior)
- Meaning: "Do not configure WinRM"

**When `winrm_listener` is an empty set `[]`:**
- Terraform validation: TypeSet with no minimum items allows empty sets
- However, our condition `length(var.winrm_listener) > 0` prevents sending empty arrays
- Empty set behaves the same as `null` - omits the `winRM` configuration

### Empty Collections

**Empty `winrm_listener` set:**
- Condition check prevents empty arrays from being sent
- Behavior: same as `null`, no WinRM configuration sent

### Safe References

**Conditional block creation:**
```hcl
var.winrm_listener != null && length(var.winrm_listener) > 0 ? {
  winRM = { ... }
} : {}
```

- ✅ Null-safe: checks `!= null` before accessing
- ✅ Empty-safe: checks `length() > 0` before processing
- ✅ Uses `for` loop to iterate, which handles empty collections safely

### Idempotency

**Set ordering:**
- Terraform `set` type handles uniqueness and ordering internally
- Each listener is uniquely identified by its `protocol` and `certificate_url` combination
- Re-applying the same configuration will produce identical API requests
- ✅ Idempotent: same input always produces same output

## Checklist

- ✅ Block skeleton created in `migrate_main.tf`
- ✅ Comment placeholders added for each child field (Tasks #94, #95)
- ✅ Conditional logic implemented (only when `winrm_listener` is non-null and non-empty)
- ✅ Proper nesting within `windowsConfiguration` merge
- ✅ Hidden fields checked (none found)
- ✅ Assignment path verified against provider source code
- ✅ Create phase pattern identified (single-phase, Create operation)
- ✅ Child tasks documented as ready for delegation
- ✅ Edge case analysis completed
- ✅ Null semantics documented
- ✅ Safe references ensured
- ✅ Idempotency confirmed
- ✅ Proof document created
- ✅ Track.md will be updated to `Pending for check`

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2025-12-24  
**Task:** #93 - winrm_listener

### Validation Results

✅ **Skeleton Structure:** Properly created with conditional logic and comment placeholders for child tasks  
✅ **Assignment Path:** Correctly verified as `properties.osProfile.windowsConfiguration.winRM.listeners`  
✅ **Create Phase:** Correctly identified as single-phase Create operation, placed in `local.body`  
✅ **Nesting:** Properly nested within `windowsConfiguration` merge (no key conflicts)  
✅ **Null Handling:** Safe conditional checks (`!= null` and `length() > 0`)  
✅ **Hidden Fields:** Expand function analyzed, no hidden fields found  
✅ **ForceNew Logic:** Documented as ForceNew at block level, correctly deferred to child tasks #94 and #95  
✅ **Validations:** Protocol and certificate_url validations correctly deferred to child tasks  
✅ **Stable Keys:** `winRM` key properly conditionally included in merge  
✅ **Shared Path Merge:** No duplicate keys in `windowsConfiguration` merge - all conditions add unique keys  
✅ **Deferred Work Completion:** No deferred work for this task in `following.md`  
✅ **Edge Cases:** Null semantics, empty collections, and idempotency properly analyzed  

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The skeleton structure is properly created with:
- Correct conditional inclusion logic matching provider's expand function behavior
- Proper nesting path verified against Go source code
- Comment placeholders for child tasks (not prematurely implementing child fields)
- Safe null handling and edge case coverage

No deviations, simplifications, or "safer alternatives" were found. This is a proper Type 3 block structure skeleton implementation.

**Status:** APPROVED ✅

---
