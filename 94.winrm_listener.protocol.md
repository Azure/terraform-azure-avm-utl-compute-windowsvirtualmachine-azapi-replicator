# Task #94 - winrm_listener.protocol - Block Argument

## Summary

Implemented the `protocol` argument within the `winrm_listener` block. This Required, ForceNew field specifies the WinRM listener protocol and accepts either "Http" or "Https" as valid values. The field is validated in `variables.tf` and the entire `winrm_listener` set is tracked for ForceNew behavior.

## Shadow Implementation

```hcl
# In variables.tf
variable "winrm_listener" {  # <-
  type = set(object({  # <-
    certificate_url = optional(string)  # <-
    protocol        = string  # <-
  }))  # <-
  default     = null  # <-
  description = <<-EOT  # <-
 - `certificate_url` - (Optional) The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.  # <-
 - `protocol` - (Required) Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.  # <-
EOT  # <-

  validation {  # <-
    condition = var.winrm_listener == null || alltrue([  # <-
      for listener in var.winrm_listener : contains(["Http", "Https"], listener.protocol)  # <-
    ])  # <-
    error_message = "The protocol must be either 'Http' or 'Https'."  # <-
  }  # <-
}  # <-

# In migrate_main.tf
locals {  # <-
  replace_triggers_external_values = {  # <-
    # ... other fields ...  # <-
    winrm_listener = { value = var.winrm_listener }  # <-
    # ... other fields ...  # <-
  }  # <-

  body = {  # <-
    properties = merge(  # <-
      var.admin_username != null ? {  # <-
        osProfile = merge(  # <-
          {  # <-
            windowsConfiguration = merge(  # <-
              # ... other windowsConfiguration fields ...  # <-
              var.winrm_listener != null && length(var.winrm_listener) > 0 ? {  # <-
                winRM = {  # <-
                  listeners = [  # <-
                    for listener in var.winrm_listener : {  # <-
                      protocol = listener.protocol  # <-
                      # certificateUrl = ... # Task #95  # <-
                    }  # <-
                  ]  # <-
                }  # <-
              } : {}  # <-
            )  # <-
          }  # <-
        )  # <-
      } : {}  # <-
    )  # <-
  }  # <-
}  # <-
```

## Create Phase Verification

### Create Method Query

From `resourceWindowsVirtualMachineCreate` in the azurerm provider:

```go
params.Properties.OsProfile = &virtualmachines.OSProfile{
    AdminPassword:            pointer.To(d.Get("admin_password").(string)),
    AdminUsername:            pointer.To(d.Get("admin_username").(string)),
    ComputerName:             pointer.To(computerName),
    AllowExtensionOperations: pointer.To(allowExtensionOperations),
    WindowsConfiguration: &virtualmachines.WindowsConfiguration{
        ProvisionVMAgent:       pointer.To(provisionVMAgent),
        EnableAutomaticUpdates: pointer.To(autoUpdatesEnabled),
        WinRM:                  expandWinRMListener(d.Get("winrm_listener").(*pluginsdk.Set).List()),
    },
    Secrets: secrets,
}
```

### Pattern Classification

**Pattern:** Single-phase create operation

**Field Assignment:** The `protocol` field is part of the `winrm_listener` block, which is expanded via `expandWinRMListener()` and assigned to `WindowsConfiguration.WinRM` during the primary `CreateOrUpdateThenPoll` operation in the Create method.

**Decision:** This field belongs in `local.body.properties.osProfile.windowsConfiguration.winRM.listeners[*].protocol` (Create phase).

## Assignment Path Verification

### Predicted Path

`body.properties.osProfile.windowsConfiguration.winRM.listeners[*].protocol`

### Provider Code Evidence

```go
// From resourceWindowsVirtualMachineCreate
params := virtualmachines.VirtualMachine{
    Properties: &virtualmachines.VirtualMachineProperties{
        OsProfile: &virtualmachines.OSProfile{
            WindowsConfiguration: &virtualmachines.WindowsConfiguration{
                WinRM: expandWinRMListener(d.Get("winrm_listener").(*pluginsdk.Set).List()),
            },
        },
    },
}

// From expandWinRMListener in shared_schema.go
func expandWinRMListener(input []interface{}) *virtualmachines.WinRMConfiguration {
	listeners := make([]virtualmachines.WinRMListener, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		listener := virtualmachines.WinRMListener{
			Protocol: pointer.To(virtualmachines.ProtocolTypes(raw["protocol"].(string))),
		}

		certificateUrl := raw["certificate_url"].(string)
		if certificateUrl != "" {
			listener.CertificateURL = pointer.To(certificateUrl)
		}

		listeners = append(listeners, listener)
	}

	return &virtualmachines.WinRMConfiguration{
		Listeners: &listeners,
	}
}
```

### Verified Path

Following the assignments:
1. `params.Properties` = `&virtualmachines.VirtualMachineProperties{...}` → adds `properties` nesting
2. `Properties.OsProfile` = `&virtualmachines.OSProfile{...}` → adds `osProfile` nesting
3. `OsProfile.WindowsConfiguration` = `&virtualmachines.WindowsConfiguration{...}` → adds `windowsConfiguration` nesting
4. `WindowsConfiguration.WinRM` = `expandWinRMListener(...)` → adds `winRM` nesting
5. `WinRMConfiguration.Listeners` = `&listeners` → adds `listeners` array
6. Each `WinRMListener.Protocol` = `pointer.To(virtualmachines.ProtocolTypes(raw["protocol"].(string)))` → adds `protocol` field

**Final verified path:** `properties.osProfile.windowsConfiguration.winRM.listeners[*].protocol`

### Path Comparison

✅ **MATCH** - Predicted and verified paths are identical.

## Provider Schema

From `winRmListenerSchemaVM()` in `shared_schema.go`:

```go
func winRmListenerSchemaVM() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeSet,
		Optional: true,
		// Whilst the SDK allows you to modify this, the API does not:
		//   Code="PropertyChangeNotAllowed"
		//   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
		//   Target="windowsConfiguration.winRM.listeners"
		ForceNew: true,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"protocol": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
					ValidateFunc: validation.StringInSlice([]string{
						string(virtualmachines.ProtocolTypesHTTP),
						string(virtualmachines.ProtocolTypesHTTPS),
					}, false),
				},

				"certificate_url": {
					Type:         pluginsdk.TypeString,
					Optional:     true,
					ForceNew:     true,
					ValidateFunc: keyVaultValidate.NestedItemId,
				},
			},
		},
		ConflictsWith: []string{
			"os_managed_disk_id",
		},
	}
}
```

**Key characteristics:**
- **Type:** `TypeString`
- **Required:** true
- **ForceNew:** true (both block-level and field-level)
- **Validation:** `StringInSlice(["Http", "Https"], false)` - case-sensitive validation

**Comment from provider source:**
```go
// Whilst the SDK allows you to modify this, the API does not:
//   Code="PropertyChangeNotAllowed"
//   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
//   Target="windowsConfiguration.winRM.listeners"
```

This confirms the entire `winRM.listeners` array is immutable after creation.

## Azure API Schema

Query result for `body.properties.osProfile.windowsConfiguration.winRM.listeners`:

```
List(ObjectWithOptionalAttrs(
  map[string]Type{
    "certificateUrl": String,
    "protocol": String
  },
  []string{"certificateUrl", "protocol"}
))
```

**Azure API Structure:**
- `listeners` is an array of listener objects
- Each listener has a `protocol` field of type String
- The `protocol` field is marked as optional in the API schema (both fields are in the optional list)

## Hidden Fields Check

From `expandWinRMListener`:

```go
func expandWinRMListener(input []interface{}) *virtualmachines.WinRMConfiguration {
	listeners := make([]virtualmachines.WinRMListener, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		listener := virtualmachines.WinRMListener{
			Protocol: pointer.To(virtualmachines.ProtocolTypes(raw["protocol"].(string))),
		}

		certificateUrl := raw["certificate_url"].(string)
		if certificateUrl != "" {
			listener.CertificateURL = pointer.To(certificateUrl)
		}

		listeners = append(listeners, listener)
	}

	return &virtualmachines.WinRMConfiguration{
		Listeners: &listeners,
	}
}
```

**Analysis:**
- ✅ No hidden fields detected for the `protocol` field
- The expand function directly extracts `protocol` from the Terraform configuration
- No additional fields, defaults, or transformations are applied
- The value is passed through with only a type cast to `virtualmachines.ProtocolTypes`

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|-------------------------|----------------------|
| `protocol`              | `protocol`           |

**Note:** Both sides use the same name - no transformation needed.

## Special Handling

### Validation - IMPLEMENTED

**From provider schema:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(virtualmachines.ProtocolTypesHTTP),    // "Http"
    string(virtualmachines.ProtocolTypesHTTPS),   // "Https"
}, false),
```

**Implementation in `variables.tf`:**
```hcl
validation {
  condition = var.winrm_listener == null || alltrue([
    for listener in var.winrm_listener : contains(["Http", "Https"], listener.protocol)
  ])
  error_message = "The protocol must be either 'Http' or 'Https'."
}
```

**Validation Details:**
- ✅ Exact replication of provider validation
- ✅ Case-sensitive: "Http" and "Https" (capital H, lowercase remaining)
- ✅ Applied to all listeners in the set
- ✅ Handles null case (when winrm_listener is not specified)
- ✅ Uses `alltrue()` to ensure all listeners have valid protocols

### ForceNew - IMPLEMENTED

**From provider schema:**
- Block-level: `ForceNew: true`
- Field-level: `protocol` has `ForceNew: true`

**Implementation:**
```hcl
replace_triggers_external_values = {
  winrm_listener = { value = var.winrm_listener }
}
```

**ForceNew Strategy:**
- ✅ Tracks the entire `winrm_listener` set (not individual fields)
- ✅ Wrapped in `{ value = ... }` to ensure stable key
- ✅ Any change to the set (including protocol changes) triggers replacement
- ✅ Matches provider behavior where the entire `winRM.listeners` array is immutable

**Why track the entire set:**
1. The provider schema has `ForceNew: true` at the block level
2. The Azure API comment explicitly states the entire `winRM.listeners` property is immutable
3. Individual listener changes cannot be applied - the entire array must be replaced

### ConflictsWith Handling

**From provider schema:**
```go
ConflictsWith: []string{
    "os_managed_disk_id",
},
```

**Implementation:** Deferred to Task #26 (os_managed_disk_id), as noted in Task #93 (parent block). The `os_managed_disk_id` variable doesn't exist yet, so cross-field validation will be implemented when that variable is created.

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #94:
- ✅ No deferred work found for this task

## Edge Case Analysis

### Null Semantics

**When `winrm_listener` is `null`:**
- The validation condition `var.winrm_listener == null || alltrue([...])` returns `true` (short-circuits)
- The block structure conditional `var.winrm_listener != null && length(var.winrm_listener) > 0` returns `false`
- Result: No `winRM` configuration is sent to Azure API
- Meaning: "Do not configure WinRM listeners"

**When `protocol` is missing from a listener object:**
- Terraform type system enforces the `protocol` field is required (not `optional()`)
- Users cannot create a listener without specifying protocol
- This matches the provider schema where `protocol` is `Required: true`

### Value Constraints

**Valid values:**
- "Http" - HTTP protocol (port 5985 by default)
- "Https" - HTTPS protocol (port 5986 by default)

**Invalid values:**
- ❌ "http" (lowercase) - will be rejected by validation
- ❌ "https" (lowercase) - will be rejected by validation
- ❌ "HTTP" (all caps) - will be rejected by validation
- ❌ "HTTPS" (all caps) - will be rejected by validation
- ❌ Any other string - will be rejected by validation

**Validation is case-sensitive:** Matches provider's `StringInSlice([], false)` where `false` means case-sensitive.

### Set Behavior

**Uniqueness:**
- Terraform `set` type ensures uniqueness based on all object fields
- Two listeners with same protocol but different certificate_url are distinct
- Two listeners with identical protocol AND certificate_url would be deduplicated

**Ordering:**
- Sets have no guaranteed order in Terraform
- The `for` loop iterates in deterministic order (Terraform's internal sorting)
- Re-applying the same configuration produces identical API requests
- ✅ Idempotent behavior

### Safe References

**In validation block:**
```hcl
var.winrm_listener == null || alltrue([
  for listener in var.winrm_listener : contains(["Http", "Https"], listener.protocol)
])
```
- ✅ Null-safe: checks `== null` before iterating
- ✅ Empty-safe: `alltrue([])` returns `true` for empty lists
- ✅ The iteration only happens when `winrm_listener` is not null

**In body construction:**
```hcl
var.winrm_listener != null && length(var.winrm_listener) > 0 ? {
  winRM = {
    listeners = [
      for listener in var.winrm_listener : {
        protocol = listener.protocol
      }
    ]
  }
} : {}
```
- ✅ Null-safe: checks `!= null` before accessing
- ✅ Empty-safe: checks `length() > 0` before processing
- ✅ Safe field access: `listener.protocol` is guaranteed to exist (required field)

### Idempotency

**Configuration stability:**
- Same input always produces same output
- Set ordering is deterministic within Terraform
- No randomness or time-dependent values
- ✅ Idempotent: re-applying produces identical API calls

**ForceNew tracking:**
- Tracks the entire `winrm_listener` set value
- Changes to any part of any listener trigger replacement
- No partial updates possible (matches Azure API behavior)
- ✅ Consistent replacement behavior

## Checklist

- ✅ Property implemented in `migrate_main.tf` (replaced comment placeholder for Task #94)
- ✅ ForceNew tracking added to `replace_triggers_external_values` (entire set tracked)
- ✅ Validation IMPLEMENTED in `variables.tf` (StringInSlice with ["Http", "Https"])
- ✅ Field correctly placed in `local.body.properties.osProfile.windowsConfiguration.winRM.listeners[*]`
- ✅ Create phase verified (single-phase, assigned during primary CreateOrUpdateThenPoll)
- ✅ Assignment path verified (matches predicted path exactly)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked in `following.md` (none for this task)
- ✅ Edge case analysis completed (null semantics, validation, set behavior, safe references, idempotency)
- ✅ EXACT replication of provider behavior (no simplifications or conservative approaches)
- ✅ Proof document created
- ✅ Ready to update `track.md` to `Pending for check`

---

**Implementation Status:** ✅ COMPLETE - Ready for checker validation

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #94 - winrm_listener.protocol

### Validation Results

✅ **ForceNew Logic:** Block-level ForceNew correctly implemented by tracking entire `winrm_listener` set in replace_triggers_external_values
✅ **Stable Keys:** Key `winrm_listener` is always present in replace_triggers_external_values (wrapped in `{ value = ... }`)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** String type correctly passed through (no conversion needed)
✅ **Null Handling:** Correctly propagates null semantics - null winrm_listener omits entire winRM configuration
✅ **Validations:** StringInSlice validation exactly replicated in variables.tf with case-sensitive ["Http", "Https"]
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** Block-level ConflictsWith validation was missing from Task #93's deferrals - corrected by adding entry in following.md (Task #93 → Task #26)
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, set behavior, validation, safe references, idempotency)

### Issues Identified and Corrected

#### Issue 1: Missing Deferral Recording from Task #93

**Problem:**
Task #93 (parent block skeleton) identified a block-level ConflictsWith constraint between `winrm_listener` and `os_managed_disk_id` but did NOT record the deferral in `following.md`. The provider schema shows:

```go
ConflictsWith: []string{
    "os_managed_disk_id",
},
```

This is a block-level constraint (on the winrm_listener schema itself, not on individual fields), so Task #93 should have either implemented the validation or deferred it with proper tracking.

**Why This Violates executor.md:**
From executor.md section on "Deferring Sub-Tasks to Later Tasks":
> When you encounter work that references fields owned by other tasks, you may defer implementation to the owning task. When deferring:
> 1. **Record in `following.md`:** Add a row to the tracking table

Task #93 identified the ConflictsWith but never recorded the deferral.

**Root Cause:**
Task #93 executor completed the skeleton but didn't properly track the deferred block-level validation. This is NOT Task #94's responsibility (field-level task), but as checker, I must ensure completeness.

**Correction Made:**
Added missing deferral entry to `following.md`:
```markdown
| #93 | #26 | Validation | Cross-field validation: winrm_listener cannot be used with os_managed_disk_id (ConflictsWith) | Pending |
```

**Why This is Correct:**
- Block-level ConflictsWith belongs to the block skeleton task (#93)
- Since `os_managed_disk_id` variable doesn't exist yet (Task #26 pending), validation must be deferred
- Proper tracking in following.md ensures Task #26 will implement the reciprocal validation

**Verification:**
- Changed file: `following.md`
- Entry added following existing pattern
- Status set to "Pending" (will be completed by Task #26)

### Compliance Statement

After correction, Task #94's implementation EXACTLY replicates the provider behavior as required by `executor.md`. The protocol field is correctly validated with case-sensitive StringInSlice, properly nested in the osProfile.windowsConfiguration.winRM.listeners array, and tracked for ForceNew at the set level. No deviations, simplifications, or approximations were found.

**Status:** CORRECTED AND APPROVED ✅

---
