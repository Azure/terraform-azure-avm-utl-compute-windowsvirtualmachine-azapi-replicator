# Task #50 - os_disk.secure_vm_disk_encryption_set_id - COMPLETED

## Summary

Successfully migrated the block argument `os_disk.secure_vm_disk_encryption_set_id` from `azurerm_windows_virtual_machine` to `azapi_resource`. This field is Optional with ForceNew: true. It can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`. The field conflicts with `disk_encryption_set_id`. Implementation replicates exact provider behavior including all validations.

## Shadow Implementation

```hcl
# variables.tf
variable "os_disk" {
  type = object({
    # ... other fields ...
    secure_vm_disk_encryption_set_id = optional(string)  # <-
    # ... other fields ...
  })
  
  validation {
    condition     = var.os_disk.disk_encryption_set_id == null || var.os_disk.secure_vm_disk_encryption_set_id == null  # <-
    error_message = "os_disk.disk_encryption_set_id cannot be used together with os_disk.secure_vm_disk_encryption_set_id (ConflictsWith)."  # <-
  }
  
  validation {  # <-
    condition     = var.os_disk.secure_vm_disk_encryption_set_id == null || var.os_disk.security_encryption_type == "DiskWithVMGuestState"  # <-
    error_message = "os_disk.secure_vm_disk_encryption_set_id can only be specified when os_disk.security_encryption_type is set to 'DiskWithVMGuestState'."  # <-
  }  # <-
}

# migrate_main.tf
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    os_disk_secure_vm_disk_encryption_set_id = { value = var.os_disk.secure_vm_disk_encryption_set_id }  # <-
  }
  
  body = {
    properties = merge(
      {
        storageProfile = merge(
          {
            osDisk = merge(
              {
                caching = var.os_disk.caching
                managedDisk = merge(
                  {
                    storageAccountType = local.effective_os_disk_storage_account_type
                  },
                  local.effective_os_disk_disk_encryption_set_id != null ? {
                    diskEncryptionSet = {
                      id = local.effective_os_disk_disk_encryption_set_id
                    }
                  } : {},
                  var.os_disk.secure_vm_disk_encryption_set_id != null ? {  # <-
                    securityProfile = {  # <-
                      diskEncryptionSet = {  # <-
                        id = var.os_disk.secure_vm_disk_encryption_set_id  # <-
                      }  # <-
                    }  # <-
                  } : {}  # <-
                )
              },
              # ... other fields ...
            )
          }
        )
      }
    )
  }
}
```

## Create Phase Verification

**Query:** Queried `resourceWindowsVirtualMachineCreate` to determine field processing phase.

**Pattern:** Single-phase resource creation.

**Go Code Evidence:**
```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	osDiskRaw := d.Get("os_disk").([]interface{})
	osDisk, err := expandVirtualMachineOSDisk(osDiskRaw, virtualmachines.OperatingSystemTypesWindows)
	if err != nil {
		return fmt.Errorf("expanding `os_disk`: %+v", err)
	}
	// ... setup other fields ...
	
	params.Properties.StorageProfile.OsDisk = osDisk
	
	// ... more setup ...
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
	
	d.SetId(id.ID())
	return resourceWindowsVirtualMachineRead(d, meta)
}
```

**Classification:** The field is expanded in `expandVirtualMachineOSDisk` and assigned to `params.Properties.StorageProfile.OsDisk` before the primary `CreateOrUpdateThenPoll` call. No additional operations follow the primary create.

**Decision:** Field belongs in `local.body` (Create phase, single-phase resource creation).

## Assignment Path Verification

**Predicted Path:** `properties.storageProfile.osDisk.managedDisk.securityProfile.diskEncryptionSet.id`

**Go Code Evidence from expandVirtualMachineOSDisk:**
```go
func expandVirtualMachineOSDisk(input []interface{}, osType virtualmachines.OperatingSystemTypes) (*virtualmachines.OSDisk, error) {
	raw := input[0].(map[string]interface{})
	// ... other field processing ...
	
	disk := virtualmachines.OSDisk{
		// ... other fields ...
		ManagedDisk: &virtualmachines.ManagedDiskParameters{
			StorageAccountType: pointer.To(virtualmachines.StorageAccountTypes(raw["storage_account_type"].(string))),
		},
		// ... other fields ...
	}
	
	securityEncryptionType := raw["security_encryption_type"].(string)
	if securityEncryptionType != "" {
		disk.ManagedDisk.SecurityProfile = &virtualmachines.VMDiskSecurityProfile{
			SecurityEncryptionType: pointer.To(virtualmachines.SecurityEncryptionTypes(securityEncryptionType)),
		}
	}
	if secureVMDiskEncryptionId := raw["secure_vm_disk_encryption_set_id"].(string); secureVMDiskEncryptionId != "" {
		if virtualmachines.SecurityEncryptionTypesDiskWithVMGuestState != virtualmachines.SecurityEncryptionTypes(securityEncryptionType) {
			return nil, fmt.Errorf("`secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`")
		}
		disk.ManagedDisk.SecurityProfile.DiskEncryptionSet = &virtualmachines.SubResource{
			Id: pointer.To(secureVMDiskEncryptionId),
		}
	}
	// ... other field processing ...
	
	return &disk, nil
}
```

**Assignment Trace:**
1. Field read from Terraform: `raw["secure_vm_disk_encryption_set_id"].(string)`
2. Assigned to: `disk.ManagedDisk.SecurityProfile.DiskEncryptionSet.Id`
3. Function returns `*virtualmachines.OSDisk` which is `disk`
4. In Create: `params.Properties.StorageProfile.OsDisk = osDisk`
5. Note: `SecurityProfile` is created when `security_encryption_type` is set, but the field can also be set independently if the validation passes

**Final Path:** `properties.storageProfile.osDisk.managedDisk.securityProfile.diskEncryptionSet.id`

**Path Comparison:** ✅ Predicted path matches verified path exactly.

## Provider Schema

**Source:** From `virtualMachineOSDiskSchema()` function in azurerm provider:

```go
"secure_vm_disk_encryption_set_id": {
	Type:          pluginsdk.TypeString,
	Optional:      true,
	ForceNew:      true,
	ValidateFunc:  validate.DiskEncryptionSetID,
	ConflictsWith: []string{"os_disk.0.disk_encryption_set_id"},
},
```

**Key Properties:**
- **Type**: String
- **Optional**: true
- **ForceNew**: true (changing this forces resource replacement)
- **ValidateFunc**: `validate.DiskEncryptionSetID` (validates Azure resource ID format)
- **ConflictsWith**: `os_disk.0.disk_encryption_set_id`

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachines@2024-03-01`

**Property Path:** `properties.storageProfile.osDisk.managedDisk.securityProfile.diskEncryptionSet.id`

**Type:** String (Azure Resource ID reference to Disk Encryption Set)

**Note:** The Azure API schema query failed, but the path is confirmed from the Go SDK source code structure and the provider implementation.

## Hidden Fields

None. This is a standard user-configurable field.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| secure_vm_disk_encryption_set_id | managedDisk.securityProfile.diskEncryptionSet.id | Nested within securityProfile |

## Special Handling

### ForceNew Behavior

**Provider Schema:** `ForceNew: true` - changing this field requires resource replacement.

**Implementation:**
```hcl
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    os_disk_secure_vm_disk_encryption_set_id = { value = var.os_disk.secure_vm_disk_encryption_set_id }
  }
}
```

**Rationale:** Wrapped in `{ value = ... }` to ensure stable key. Tracks full value to detect any change (null → non-null, non-null → null, or value change).

### ConflictsWith Validation

**Provider Schema:** `ConflictsWith: []string{"os_disk.0.disk_encryption_set_id"}`

**Implementation in variables.tf:**
```hcl
validation {
  condition     = var.os_disk.disk_encryption_set_id == null || var.os_disk.secure_vm_disk_encryption_set_id == null
  error_message = "os_disk.disk_encryption_set_id cannot be used together with os_disk.secure_vm_disk_encryption_set_id (ConflictsWith)."
}
```

**Note:** This is the reciprocal validation deferred from Task #47 (completed in this task).

### security_encryption_type Dependency Validation

**Provider Logic from expandVirtualMachineOSDisk:**
```go
if secureVMDiskEncryptionId := raw["secure_vm_disk_encryption_set_id"].(string); secureVMDiskEncryptionId != "" {
	if virtualmachines.SecurityEncryptionTypesDiskWithVMGuestState != virtualmachines.SecurityEncryptionTypes(securityEncryptionType) {
		return nil, fmt.Errorf("`secure_vm_disk_encryption_set_id` can only be specified when `security_encryption_type` is set to `DiskWithVMGuestState`")
	}
	disk.ManagedDisk.SecurityProfile.DiskEncryptionSet = &virtualmachines.SubResource{
		Id: pointer.To(secureVMDiskEncryptionId),
	}
}
```

**Implementation in variables.tf:**
```hcl
validation {
  condition     = var.os_disk.secure_vm_disk_encryption_set_id == null || var.os_disk.security_encryption_type == "DiskWithVMGuestState"
  error_message = "os_disk.secure_vm_disk_encryption_set_id can only be specified when os_disk.security_encryption_type is set to 'DiskWithVMGuestState'."
}
```

**Rationale:** Replicates exact provider validation logic. The field can only be used for Confidential VMs with `DiskWithVMGuestState` encryption type.

**Deferred Work:** Recorded in `following.md` - Task #51 (security_encryption_type) must be aware of this validation.

### Nested Structure with merge()

**Challenge:** The field goes into `managedDisk.securityProfile.diskEncryptionSet.id`, which may or may not exist depending on whether `security_encryption_type` is set.

**Implementation Strategy:**
```hcl
managedDisk = merge(
  {
    storageAccountType = local.effective_os_disk_storage_account_type
  },
  local.effective_os_disk_disk_encryption_set_id != null ? {
    diskEncryptionSet = {
      id = local.effective_os_disk_disk_encryption_set_id
    }
  } : {},
  var.os_disk.secure_vm_disk_encryption_set_id != null ? {
    securityProfile = {
      diskEncryptionSet = {
        id = var.os_disk.secure_vm_disk_encryption_set_id
      }
    }
  } : {}
)
```

**Rationale:** 
- Uses conditional `merge()` to add `securityProfile` only when the field is set
- The `securityProfile` structure is created independently here
- Task #51 will also need to add to `securityProfile.securityEncryptionType`, so it will need to merge with this structure
- This approach allows both fields to coexist in the same `securityProfile` object

## Deferred Work Completion

**Deferred From:** Task #47 (os_disk.disk_encryption_set_id)

**Work Item:** Implement reciprocal ConflictsWith validation

**Implementation:**
```hcl
validation {
  condition     = var.os_disk.disk_encryption_set_id == null || var.os_disk.secure_vm_disk_encryption_set_id == null
  error_message = "os_disk.disk_encryption_set_id cannot be used together with os_disk.secure_vm_disk_encryption_set_id (ConflictsWith)."
}
```

**Evidence:** Added to `variables.tf` validation blocks for `os_disk` variable.

**Status Update:** Updated `following.md` line 22 from "Pending" to "✅ Completed".

**New Deferred Work:** Added deferred work to Task #51 (security_encryption_type) for cross-field validation dependency.

## Critical Review & Edge Case Analysis

### Null Semantics
- **null:** Field not set, `securityProfile.diskEncryptionSet` not included in API request
- **Non-null string:** Disk Encryption Set ID is specified, `securityProfile.diskEncryptionSet.id` sent to API
- **Empty string:** Not allowed by Terraform (optional string type treats empty string as non-null)

### Edge Cases

1. **Setting secure_vm_disk_encryption_set_id without security_encryption_type:**
   - ✅ Validation catches: `error_message = "os_disk.secure_vm_disk_encryption_set_id can only be specified when os_disk.security_encryption_type is set to 'DiskWithVMGuestState'."`
   - Note: security_encryption_type defaults to null/empty, so validation will fail

2. **Setting both disk_encryption_set_id and secure_vm_disk_encryption_set_id:**
   - ✅ Validation catches: `error_message = "os_disk.disk_encryption_set_id cannot be used together with os_disk.secure_vm_disk_encryption_set_id (ConflictsWith)."`

3. **Changing the field value after creation:**
   - ✅ ForceNew trigger in `replace_triggers_external_values` detects change
   - Resource replacement occurs as required by provider behavior

4. **Setting security_encryption_type to a value other than DiskWithVMGuestState:**
   - ✅ Validation catches at plan time
   - Only "DiskWithVMGuestState" is permitted when using this field

5. **securityProfile merge conflict with security_encryption_type (Task #51):**
   - ⚠️ Task #51 will need to merge with this structure
   - Both tasks create `securityProfile` independently
   - Task #51 must use nested merge to combine: `securityProfile = merge({ diskEncryptionSet = ... }, { securityEncryptionType = ... })`

### Idempotency
- ✅ Field value tracked in ForceNew triggers, ensures consistent replacement behavior
- ✅ No order-dependent logic
- ✅ Conditional merge ensures clean structure when field is null

### Safe References
- ✅ All nested access uses safe conditional: `var.os_disk.secure_vm_disk_encryption_set_id != null ? { ... } : {}`
- ✅ No direct property access without null checks

### Coordination with Task #51
**Important:** Task #51 (security_encryption_type) must be aware that:
1. `securityProfile` structure may already exist if `secure_vm_disk_encryption_set_id` is set
2. Task #51 needs to merge both fields into the same `securityProfile` object
3. Both fields can be set simultaneously (no conflict), but they must coexist in the same structure

## Checklist

- ✅ Property in correct local (`local.body.properties.storageProfile.osDisk.managedDisk.securityProfile.diskEncryptionSet.id`)
- ✅ ForceNew wrapped: `{ value = var.os_disk.secure_vm_disk_encryption_set_id }`
- ✅ All logic EXACTLY replicated from provider (ConflictsWith, security_encryption_type dependency validation)
- ✅ Validations IMPLEMENTED in variables.tf (both ConflictsWith and security_encryption_type dependency)
- ✅ Hidden fields checked: None
- ✅ Deferred work completed: Reciprocal ConflictsWith validation from Task #47
- ✅ Deferred work recorded: New validation dependency deferred to Task #51
- ✅ Critical review completed (null, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis included in proof
- ✅ Proof document created (50.os_disk.secure_vm_disk_encryption_set_id.md)
- ✅ track.md status will be updated to "Pending for check"
- ✅ Self-Review: Implementation adds ONLY Task #50 requirements, no content from other tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #50 - os_disk.secure_vm_disk_encryption_set_id

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) - correctly wrapped as `{ value = var.os_disk.secure_vm_disk_encryption_set_id }` to track full value changes (null ↔ non-null, value changes)

✅ **Stable Keys:** All keys in `replace_triggers_external_values` are stable. The key `os_disk_secure_vm_disk_encryption_set_id` is always present, with value wrapped in object to detect all transitions.

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase resource creation verified with Go code evidence from `resourceWindowsVirtualMachineCreate`)

✅ **Type Conversion:** Correct - Terraform `optional(string)` maps directly to Azure API string type at path `properties.storageProfile.osDisk.managedDisk.securityProfile.diskEncryptionSet.id`

✅ **Null Handling:** Correctly propagates null semantics - when field is null, `securityProfile.diskEncryptionSet` structure is not included in merge (empty object returned)

✅ **Validations:** All provider validations implemented exactly:
  - ConflictsWith `disk_encryption_set_id` (line 148-150 in variables.tf) ✅
  - RequiredWith `security_encryption_type == "DiskWithVMGuestState"` (line 152-155 in variables.tf) ✅
  - ValidateFunc for DiskEncryptionSetID format is skipped per executor.md rules (Azure Resource ID format validations are verified by resource references)

✅ **Deferred Work Completion:** Task #47 deferred reciprocal ConflictsWith validation to this task. Validation correctly implemented (line 148-150) and `following.md` line 22 updated to "✅ Completed"

✅ **Deferred Work Recording:** New validation dependency on `security_encryption_type` properly recorded in `following.md` line 23 for Task #51, with clear description and "Pending" status

✅ **Edge Cases:** All edge cases properly analyzed:
  - Setting field without security_encryption_type → validation catches ✅
  - Setting both disk_encryption_set_id and secure_vm_disk_encryption_set_id → validation catches ✅
  - Changing field value after creation → ForceNew triggers replacement ✅
  - security_encryption_type set to value other than "DiskWithVMGuestState" → validation catches ✅

✅ **Merge Structure:** No duplicate parent keys at same level within `managedDisk` merge:
  - `storageAccountType` appears once
  - `diskEncryptionSet` appears once (for regular encryption)
  - `securityProfile` appears once (for secure VM encryption)
  All keys are distinct at the same merge level - no shallow merge overwrite issue

### ⚠️ CRITICAL NOTE FOR TASK #51

**Task #51 (security_encryption_type) implementer MUST be aware:**

The current implementation creates `securityProfile` conditionally when `secure_vm_disk_encryption_set_id` is set. Task #51 must NOT create a second independent `securityProfile` key at the same merge level, as this would cause a shallow merge overwrite violation.

**REQUIRED APPROACH for Task #51:**
When implementing `security_encryption_type`, Task #51 must refactor BOTH fields into a single nested merge structure:

```hcl
# CORRECT pattern Task #51 must implement:
(var.os_disk.secure_vm_disk_encryption_set_id != null || var.os_disk.security_encryption_type != null) ? {
  securityProfile = merge(
    var.os_disk.secure_vm_disk_encryption_set_id != null ? {
      diskEncryptionSet = { id = var.os_disk.secure_vm_disk_encryption_set_id }
    } : {},
    var.os_disk.security_encryption_type != null ? {
      securityEncryptionType = var.os_disk.security_encryption_type
    } : {}
  )
} : {}

# WRONG pattern Task #51 must AVOID:
var.os_disk.secure_vm_disk_encryption_set_id != null ? {
  securityProfile = { diskEncryptionSet = {...} }
} : {},
var.os_disk.security_encryption_type != null ? {
  securityProfile = { securityEncryptionType = ... }  # ❌ DUPLICATE KEY - second overwrites first!
} : {}
```

This refactoring is deferred to Task #51 because that task owns the `security_encryption_type` field and will have full context to implement the proper nested merge structure for both fields.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. All validations match provider logic, ForceNew behavior is correctly implemented, and deferred work was properly completed and recorded. The merge structure is correct for THIS task's scope, with clear instructions documented for Task #51 to maintain correctness.

**Status:** APPROVED ✅

---
