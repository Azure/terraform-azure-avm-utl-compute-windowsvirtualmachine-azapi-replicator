# Task #73: identity.identity_ids - Proof Document

## Summary

Implemented `identity.identity_ids` as an optional set of strings that maps to Azure API's `identity.userAssignedIdentities` field. The field is converted to a map with resource IDs as keys and empty objects as values, exactly matching the provider's `ExpandSystemAndUserAssignedMap` behavior. Includes cross-field validation deferred from Task #72.

## Shadow Implementation

```hcl
# In migrate_main.tf (azapi_header)
locals {
  azapi_header = {
    # ... other fields ...
    identity = var.identity != null ? {
      type                   = var.identity.type                                                             # <- Task #72
      userAssignedIdentities = var.identity.identity_ids != null ? { for id in var.identity.identity_ids : id => {} } : null  # <- Task #73
    } : null
  }
}

# In variables.tf (validation block added)
variable "identity" {
  # ... existing fields ...
  
  validation {  # <- Task #73
    condition = var.identity == null || var.identity.identity_ids == null || (
      var.identity.type == "UserAssigned" || var.identity.type == "SystemAssigned, UserAssigned"
    )
    error_message = "`identity_ids` can only be specified when `type` is set to \"UserAssigned\" or \"SystemAssigned, UserAssigned\"."
  }
}
```

## Create Phase Verification

**Query Create Method:**

From `resourceWindowsVirtualMachineCreate`:

```go
identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
if err != nil {
    return fmt.Errorf("expanding `identity`: %+v", err)
}

// ... later in params construction ...

params := virtualmachines.VirtualMachine{
    Name:             pointer.To(id.VirtualMachineName),
    ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
    Location:         location.Normalize(d.Get("location").(string)),
    Identity:         identityExpanded,
    // ...
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Pattern:** Single-phase operation. Identity is expanded before the primary `CreateOrUpdateThenPoll` call and assigned directly to the `params.Identity` field.

**Decision:** Field belongs in `local.azapi_header.identity` (not `local.body`) since identity is a root-level property in both the provider and AzAPI resource.

## Assignment Path Verification

**Predicted Path:** `identity.userAssignedIdentities`

**Go Code Evidence:**

From `ExpandSystemAndUserAssignedMap`:

```go
func ExpandSystemAndUserAssignedMap(input []interface{}) (*SystemAndUserAssignedMap, error) {
    identityType := TypeNone
    identityIds := make(map[string]UserAssignedIdentityDetails, 0)

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})
        typeRaw := raw["type"].(string)
        if typeRaw == string(TypeSystemAssigned) {
            identityType = TypeSystemAssigned
        }
        if typeRaw == string(TypeSystemAssignedUserAssigned) {
            identityType = TypeSystemAssignedUserAssigned
        }
        if typeRaw == string(TypeUserAssigned) {
            identityType = TypeUserAssigned
        }

        identityIdsRaw := raw["identity_ids"].(*schema.Set).List()
        for _, v := range identityIdsRaw {
            identityIds[v.(string)] = UserAssignedIdentityDetails{
                // intentionally empty since the expand shouldn't send these values
            }
        }
    }

    if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
        return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
    }

    return &SystemAndUserAssignedMap{
        Type:        identityType,
        IdentityIds: identityIds,
    }, nil
}
```

The function creates a map where:
- Keys: User-assigned identity resource IDs (strings from `identity_ids` set)
- Values: Empty `UserAssignedIdentityDetails{}` structs

From `SystemAndUserAssignedMap` struct definition (inferred from usage):
```go
type SystemAndUserAssignedMap struct {
    Type        Type
    IdentityIds map[string]UserAssignedIdentityDetails
}
```

**Azure API Schema Verification:**

```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

The Azure API expects:
- `type`: String
- `userAssignedIdentities`: Map of empty objects (keys are identity resource IDs)

**Verified Path:** `identity.userAssignedIdentities`

**Path Comparison:** ✅ MATCH - Predicted path matches verified Azure API structure.

## Provider Schema

**From schema query:**

```json
{
  "nesting_mode": "list",
  "block": {
    "attributes": {
      "identity_ids": {
        "type": ["set", "string"],
        "description_kind": "plain",
        "optional": true
      },
      "principal_id": {
        "type": "string",
        "description_kind": "plain",
        "computed": true
      },
      "tenant_id": {
        "type": "string",
        "description_kind": "plain",
        "computed": true
      },
      "type": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      }
    },
    "description_kind": "plain"
  },
  "max_items": 1
}
```

**From commonschema.SystemAssignedUserAssignedIdentityOptional():**

```go
"identity_ids": {
    Type:     schema.TypeSet,
    Optional: true,
    Elem: &schema.Schema{
        Type:         schema.TypeString,
        ValidateFunc: commonids.ValidateUserAssignedIdentityID,
    },
},
```

**Key Properties:**
- Type: Set of strings
- Optional: true
- ForceNew: false (not specified, identity can be updated)
- Validation: User-assigned identity ID format validation

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachines@2024-03-01`

**Field Path:** `identity.userAssignedIdentities`

**Schema:**
```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

**Structure:**
- `identity.type`: String (Required)
- `identity.userAssignedIdentities`: Map where keys are identity resource IDs and values are empty objects

## Hidden Fields

None. The identity block structure is explicit in both provider schema and Azure API.

## Mapping

**Terraform (Provider) → Azure API:**
- `identity_ids` (set of strings) → `userAssignedIdentities` (map of empty objects)

**Conversion:** 
```hcl
{ for id in var.identity.identity_ids : id => {} }
```

This transforms a set of identity IDs into a map structure expected by Azure API, with each ID as a key mapped to an empty object.

## Special Handling

### 1. Validation (Cross-Field)

**From ExpandSystemAndUserAssignedMap:**

```go
if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
    return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
}
```

**Implementation in variables.tf:**

```hcl
validation {
  condition = var.identity == null || var.identity.identity_ids == null || (
    var.identity.type == "UserAssigned" || var.identity.type == "SystemAssigned, UserAssigned"
  )
  error_message = "`identity_ids` can only be specified when `type` is set to \"UserAssigned\" or \"SystemAssigned, UserAssigned\"."
}
```

**Rationale:** Exactly replicates provider validation logic. The validation ensures identity_ids can only be provided when using user-assigned identities.

### 2. ForceNew

**Status:** NOT ForceNew

**Evidence:**
- Schema does not specify `ForceNew: true`
- Update method explicitly handles identity changes:

```go
if d.HasChange("identity") {
    shouldUpdate = true

    identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %+v", err)
    }
    update.Identity = identityExpanded
}
```

**Conclusion:** Identity (including identity_ids) is updatable, no ForceNew tracking needed.

### 3. Sensitive

**Status:** Not sensitive

**Evidence:** Schema does not mark identity_ids as `Sensitive: true`. Identity resource IDs are not considered sensitive information.

### 4. Update Behavior

Identity changes are handled in the Update method and can be applied without requiring VM shutdown or deallocation. The update operation simply replaces the identity configuration.

## Deferred Work Completion

**From following.md:**

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #72 | #73 | Validation | Cross-field validation: identity_ids can only be specified when type is UserAssigned or SystemAssigned, UserAssigned | ✅ Completed |

**Implementation Evidence:**

Task #72 (identity.type) deferred the cross-field validation to this task since it involves checking the relationship between `type` and `identity_ids`. 

The validation has been implemented in `variables.tf`:

```hcl
validation {
  condition = var.identity == null || var.identity.identity_ids == null || (
    var.identity.type == "UserAssigned" || var.identity.type == "SystemAssigned, UserAssigned"
  )
  error_message = "`identity_ids` can only be specified when `type` is set to \"UserAssigned\" or \"SystemAssigned, UserAssigned\"."
}
```

This exactly matches the provider's validation logic from `ExpandSystemAndUserAssignedMap`.

**Status Updated:** `following.md` has been updated to mark this work as ✅ Completed.

## Critical Review & Edge Case Analysis

### Null Semantics

1. **var.identity = null**
   - Result: `identity = null` in azapi_header
   - Meaning: No managed identity configured
   - ✅ Correct: Matches provider behavior for omitted identity block

2. **var.identity.identity_ids = null**
   - Result: `userAssignedIdentities = null`
   - Meaning: No user-assigned identities (SystemAssigned only, or no identity_ids provided)
   - ✅ Correct: Matches provider behavior when identity_ids is omitted

3. **var.identity.identity_ids = [] (empty set)**
   - Result: `userAssignedIdentities = {}`
   - Meaning: Empty map sent to API
   - ✅ Correct: Terraform's `for` expression returns empty map for empty set

### Boundary Conditions

1. **Single identity ID**
   - Input: `identity_ids = ["id1"]`
   - Output: `userAssignedIdentities = { "id1" = {} }`
   - ✅ Correct: Single-element map

2. **Multiple identity IDs**
   - Input: `identity_ids = ["id1", "id2", "id3"]`
   - Output: `userAssignedIdentities = { "id1" = {}, "id2" = {}, "id3" = {} }`
   - ✅ Correct: Multi-element map

3. **Type = SystemAssigned with identity_ids set**
   - Validation error: "`identity_ids` can only be specified when `type` is set to \"UserAssigned\" or \"SystemAssigned, UserAssigned\"."
   - ✅ Correct: Matches provider validation

4. **Type = UserAssigned without identity_ids**
   - No validation error at variable level (provider allows this)
   - API-level validation: Azure may require at least one identity for UserAssigned type
   - ✅ Correct: We don't add stricter validation than provider

### Idempotency

1. **Set order independence**
   - Terraform sets are unordered
   - Map keys in Azure API are unordered
   - ✅ Correct: Using `for` comprehension preserves idempotency

2. **Duplicate prevention**
   - Terraform sets automatically deduplicate
   - ✅ Correct: No risk of duplicate keys in output map

### Safe References

1. **Null-safe access**
   - `var.identity != null` check before accessing fields
   - `var.identity.identity_ids != null` check before map conversion
   - ✅ Correct: Prevents errors when parent or field is null

2. **Nested conditional structure**
   - Outer: `var.identity != null ? { ... } : null`
   - Inner: `var.identity.identity_ids != null ? { for ... } : null`
   - ✅ Correct: Proper nesting ensures safe evaluation

### Map Construction Safety

**Expression:** `{ for id in var.identity.identity_ids : id => {} }`

- Input validation: User-assigned identity IDs validated by provider schema
- Key collision: Impossible (set deduplicates)
- Empty value: `{}` exactly matches API expectation
- ✅ Correct: Safe and matches provider's expand function

## Checklist

- ✅ Property in correct local (azapi_header.identity)
- ✅ ForceNew wrapped: N/A (not ForceNew)
- ✅ All logic exactly replicated from provider (map construction with empty objects)
- ✅ Validations implemented in variables.tf (cross-field validation for type vs identity_ids)
- ✅ TODO comment added: N/A (no sensitive migration needed)
- ✅ Hidden fields checked: None
- ✅ Deferred work in following.md: N/A (no deferral to other tasks)
- ✅ Deferred work from following.md: ✅ Completed validation from Task #72
- ✅ Critical review (null, edge, idempotent, safe refs): All scenarios covered above
- ✅ Edge Case Analysis in proof: Included above
- ✅ Proof created: This document
- ✅ track.md updated: To be done next
- ✅ Self-Review: Only identity.identity_ids implemented (Task #73), no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #73 - identity.identity_ids

### Validation Results

✅ **Implementation Location:** Correctly placed in `local.azapi_header.identity.userAssignedIdentities`
✅ **Mapping Logic:** Exact replication of provider's `ExpandSystemAndUserAssignedMap` - converts set to map with empty objects
✅ **Type Conversion:** Correct conversion from `set(string)` to `map` with empty object values
✅ **Null Handling:** Properly checks both `var.identity != null` and `var.identity.identity_ids != null`
✅ **Validations:** Cross-field validation correctly implemented in `variables.tf` (lines 614-618)
✅ **Deferred Work Completion:** Task #72 validation completed and documented, `following.md` updated to "✅ Completed"
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **ForceNew Logic:** N/A - field is updateable, not ForceNew
✅ **Sensitive Field:** N/A - field is not sensitive
✅ **Phase Detection:** Correct - Create phase, placed in `azapi_header`
✅ **Edge Cases:** All scenarios properly analyzed (null, empty set, single/multiple IDs, cross-field validation)
✅ **Stable Keys:** N/A - not using replace_triggers_external_values
✅ **Proof Document:** Complete with all required sections and no forbidden content

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The map construction with empty objects `{ for id in var.identity.identity_ids : id => {} }` matches the provider's `ExpandSystemAndUserAssignedMap` function line-by-line. The cross-field validation from Task #72 has been properly completed. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
