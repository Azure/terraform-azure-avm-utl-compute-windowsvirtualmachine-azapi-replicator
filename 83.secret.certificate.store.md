# Task #83 - secret.certificate.store Argument

## Summary

Implemented the `secret.certificate.store` argument in `migrate_main.tf`. This required string field maps to `properties.osProfile.secrets[].vaultCertificates[].certificateStore` in the Azure API and specifies the certificate store name on the Windows Virtual Machine where the certificate should be installed.

## Create Phase Verification

**Query Create Method:**

From `resourceWindowsVirtualMachineCreate` and `expandWindowsSecrets()` (documented in Task #82):

```go
secretsRaw := d.Get("secret").([]interface{})
secrets := expandWindowsSecrets(secretsRaw)

params := virtualmachines.VirtualMachine{
	Properties: &virtualmachines.VirtualMachineProperties{
		OsProfile: &virtualmachines.OSProfile{
			Secrets: secrets,
		},
	},
}

if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Windows %s: %+v", id, err)
}
```

**Expand Function Detail:**

```go
func expandWindowsSecrets(input []interface{}) *[]virtualmachines.VaultSecretGroup {
	output := make([]virtualmachines.VaultSecretGroup, 0)

	for _, raw := range input {
		v := raw.(map[string]interface{})

		keyVaultId := v["key_vault_id"].(string)
		certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
		certificates := make([]virtualmachines.VaultCertificate, 0)
		for _, certificateRaw := range certificatesRaw {
			certificateV := certificateRaw.(map[string]interface{})

			store := certificateV["store"].(string)  // <-- Field read here
			url := certificateV["url"].(string)
			certificates = append(certificates, virtualmachines.VaultCertificate{
				CertificateStore: pointer.To(store),  // <-- Assigned here
				CertificateURL:   pointer.To(url),
			})
		}

		output = append(output, virtualmachines.VaultSecretGroup{
			SourceVault: &virtualmachines.SubResource{
				Id: pointer.To(keyVaultId),
			},
			VaultCertificates: &certificates,
		})
	}

	return &output
}
```

**Pattern:** Single-phase operation. The store field is processed as part of the certificate during the initial Create request and included in the primary `CreateOrUpdateThenPoll` operation.

**Classification:** Create phase - included in primary `local.body.properties.osProfile.secrets[].vaultCertificates[].certificateStore`.

**Decision:** Implement in `local.body.properties.osProfile.secrets[].vaultCertificates[].certificateStore` during primary Create phase.

## Assignment Path Verification

**Predicted Path:** `properties.osProfile.secrets[].vaultCertificates[].certificateStore`

**Go Code Evidence:**

From expand function:
```go
store := certificateV["store"].(string)
certificates = append(certificates, virtualmachines.VaultCertificate{
	CertificateStore: pointer.To(store),  // <-- Assignment here
	CertificateURL:   pointer.To(url),
})
```

**Path Trace:**
1. `store` field read from Terraform input
2. Assigned to `VaultCertificate.CertificateStore` field
3. `VaultCertificate` appended to certificates list
4. certificates assigned to `VaultSecretGroup.VaultCertificates`
5. `VaultSecretGroup` appended to secrets list
6. secrets → `params.Properties.OsProfile.Secrets`
7. `properties.osProfile.secrets[].vaultCertificates[].certificateStore` in API

**Verified Path:** `properties.osProfile.secrets[].vaultCertificates[].certificateStore` ✅

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

From `windowsSecretSchemaVM()` in `shared_schema.go`:

```go
"certificate": {
	Type:     pluginsdk.TypeSet,
	Required: true,
	MinItems: 1,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"store": {
				Type:     pluginsdk.TypeString,
				Required: true,
			},
			"url": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ValidateFunc: keyVaultValidate.NestedItemId,
			},
		},
	},
},
```

**Key Details:**
- **Type:** String (Required)
- **Parent:** certificate block (set)
- **ForceNew:** false (not specified)
- **Validation:** None (no ValidateFunc)
- **DiffSuppressFunc:** None
- **Description:** The certificate store name on the VM where the certificate should be installed

## Azure API Schema

From `Microsoft.Compute/virtualMachines@2024-03-01`:

```
properties.osProfile.secrets[].vaultCertificates[].certificateStore: String
```

**Structure:**
- `certificateStore` is a String field within each vaultCertificates array element
- Specifies the certificate store name where the certificate will be installed on the Windows VM
- Common values include: "My" (Personal), "Root", "CA", "Trust", etc.

## Hidden Fields

**Check Expand Function:**

From the expand function shown above (lines 10-26), the certificate store processing shows:

```go
store := certificateV["store"].(string)
certificates = append(certificates, virtualmachines.VaultCertificate{
	CertificateStore: pointer.To(store),
	CertificateURL:   pointer.To(url),
})
```

**Hidden Fields Found:** None

The expand function directly maps the input field to the API structure without adding any hidden values or transformations.

## Mapping

**Terraform → Azure API:**
- `secret[].certificate[].store` → `properties.osProfile.secrets[].vaultCertificates[].certificateStore`

**Naming Convention:**
- `store` (snake_case) → `certificateStore` (camelCase)

## Special Handling

### No Validation

Unlike the sibling `url` field which has `keyVaultValidate.NestedItemId` validation, the `store` field has **no validation** in the provider schema. This means:
- Any string value is accepted
- No format checking
- No enum constraint on store names

The Azure API and Windows OS will validate the store name at deployment time. Common certificate store names include:
- `My` - Personal certificates
- `Root` - Trusted Root Certification Authorities
- `CA` - Intermediate Certification Authorities
- `Trust` - Enterprise Trust
- `TrustedPeople` - Trusted People
- `TrustedPublisher` - Trusted Publishers

### Required Field

The provider schema marks this field as **Required** (not Optional). When the certificate block is specified (which itself is Required MinItems: 1 when secret is defined), each certificate must have a store name.

### No ForceNew

The `store` field does NOT have `ForceNew: true`, which means technically the provider would allow modification. However, the entire `secret` block structure is typically treated as ForceNew in practice due to how Windows certificate deployment works. For this implementation, we follow the schema definition: no ForceNew marker on the store field itself.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... other properties ...
      var.admin_username != null ? {
        osProfile = merge(
          # ... other osProfile fields ...
          (var.secret != null && length(var.secret) > 0) ? {
            secrets = [
              for secret_item in var.secret : {
                sourceVault = {
                  id = secret_item.key_vault_id
                }
                vaultCertificates = [
                  for cert in secret_item.certificate : {
                    certificateStore = cert.store # <-
                    # certificateUrl = ... # Task #84
                  }
                ]
              }
            ]
          } : {}
        )
      } : {}
    )
  }
}
```

## Deferred Work Completion

**Check `following.md`:** No work deferred TO this task.

**Work deferred FROM this task:** None - this is a straightforward required string field with no cross-field dependencies.

## Edge Case Analysis

### Null Semantics
- `cert.store == null` → Should not occur because the field is Required in the variable definition
- `cert.store == ""` → Empty string is technically valid per the schema (no validation), but Azure deployment will likely fail

### Boundary Conditions
- No length constraints in provider schema
- No character pattern validation in provider schema
- Azure OS will validate the store name exists when certificate is deployed

### Idempotency
- Store name is a simple string value
- Direct mapping ensures consistent behavior
- No transformations applied that could cause drift

### Safe References
- `cert.store` is safe because:
  - The parent `for cert in secret_item.certificate` only executes when certificates exist
  - The certificate set is Required with MinItems: 1 when secret is defined
  - The store field is Required within each certificate
  - The nested for loop is protected by parent null checks

## Critical Review

### Correctness
- ✅ Direct mapping from Terraform to API field
- ✅ No transformation needed
- ✅ Field is Required, matches provider schema
- ✅ No validation logic needed (provider has none)

### Provider Behavior Replication
- ✅ Exact mapping: Terraform string → Go string → API string
- ✅ No hidden fields added
- ✅ No transformations applied
- ✅ Required constraint enforced by variable definition

### Edge Cases
- ✅ Empty string handled (will fail at Azure deployment, not Terraform)
- ✅ Required constraint prevents null values
- ✅ Parent null checks protect nested access
- ✅ Set to list conversion handled by for expression (Task #82)

### Implementation Exactness
This implementation **exactly replicates** the provider behavior:
1. No validation logic (provider has none)
2. No transformations (direct string mapping)
3. No hidden fields (expand function shows direct assignment)
4. Required constraint enforced by existing variable definition

## Checklist

- ✅ Field added to body.properties.osProfile.secrets[].vaultCertificates[].certificateStore
- ✅ Direct mapping: `cert.store` → `certificateStore`
- ✅ No validations needed (none in provider)
- ✅ No ForceNew logic (not in schema)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (none for this task)
- ✅ Edge case analysis completed
- ✅ Provider behavior exactly replicated
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-review: Only Task #83 store field implemented, no other fields added

## Files Modified

1. `migrate_main.tf` - Replaced comment placeholder with `certificateStore = cert.store`
2. `83.secret.certificate.store.md` - This proof document
3. `track.md` - Status will be updated to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #83 - secret.certificate.store

### Validation Results

✅ **ForceNew Logic:** Not applicable - field does not have ForceNew in schema
✅ **Stable Keys:** All keys stable within merge structures
✅ **Phase Detection:** Correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Direct string mapping, no conversion needed
✅ **Null Handling:** Correctly handles Required constraint with parent null checks
✅ **Validations:** None required (provider has none) - correctly no validation added
✅ **Deferred Work Completion:** No deferred work for this task
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** All edge cases properly analyzed and handled
✅ **Sensitive Fields:** Not sensitive - correctly in body (not sensitive_body)
✅ **Shared Path Merge:** No duplicate parent keys detected

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
1. **Direct mapping** from Terraform string to API string with no transformations
2. **No validation logic** added (provider has none)
3. **No hidden fields** (expand function shows direct assignment)
4. **Required constraint** enforced by variable definition in variables.tf
5. **Correct nesting** within osProfile.secrets[].vaultCertificates[].certificateStore
6. **Proper null protection** via parent conditional checks

No deviations, simplifications, or "safer alternatives" were found. The executor followed all rules in `executor.md` precisely.

**Status:** APPROVED ✅

---
