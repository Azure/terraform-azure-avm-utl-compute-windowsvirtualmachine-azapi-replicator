# Task #85 - source_image_reference Block Structure Skeleton

## Summary

Created structure skeleton for the `source_image_reference` block with comment placeholders for 4 child arguments (publisher, offer, sku, version). No hidden fields found in expand function.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        {
          storageProfile = merge(
            # ... other fields ...
            var.source_image_id != null ? {
              imageReference = local.source_image_id_reference
            } : {},
            var.source_image_reference != null ? {  # <-
              imageReference = {  # <-
                # publisher = ... # Task #87  # <-
                # offer = ... # Task #86  # <-
                # sku = ... # Task #88  # <-
                # version = ... # Task #89  # <-
              }  # <-
            } : {}  # <-
          )
        }
      )
    }
  )
}
```

## Create Phase Verification

### Query Create Method

The Create function shows `source_image_reference` is processed in the Create phase:

```go
sourceImageReferenceRaw := d.Get("source_image_reference").([]interface{})
sourceImageId := d.Get("source_image_id").(string)
if len(sourceImageReferenceRaw) != 0 || sourceImageId != "" {
    params.Properties.StorageProfile.ImageReference = expandSourceImageReference(sourceImageReferenceRaw, sourceImageId)
}
```

**Pattern:** Single-phase creation - `source_image_reference` is expanded and assigned to `params.Properties.StorageProfile.ImageReference` before the primary `CreateOrUpdateThenPoll` call.

**Decision:** Field belongs in `local.body` (Create phase), NOT in post-creation operations.

## Assignment Path Verification

### Predicted Path
`body.properties.storageProfile.imageReference`

### Go Code Evidence

From Create method:
```go
params := virtualmachines.VirtualMachine{
    Properties: &virtualmachines.VirtualMachineProperties{
        StorageProfile: &virtualmachines.StorageProfile{
            // ...
        },
    },
}

// Later in the code:
if len(sourceImageReferenceRaw) != 0 || sourceImageId != "" {
    params.Properties.StorageProfile.ImageReference = expandSourceImageReference(sourceImageReferenceRaw, sourceImageId)
}
```

**Path Trace:**
1. `params.Properties` ‚Üí adds `properties` nesting
2. `.StorageProfile` ‚Üí adds `storageProfile` nesting
3. `.ImageReference` ‚Üí becomes `imageReference` (camelCase)

### Verified Path
`body.properties.storageProfile.imageReference` ‚úÖ Match

## Provider Schema

From `sourceImageReferenceSchemaVM()`:

```go
func sourceImageReferenceSchemaVM() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,
        MaxItems: 1,
        ExactlyOneOf: []string{
            "os_managed_disk_id",
            "source_image_id",
            "source_image_reference",
        },
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "publisher": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
                "offer": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
                "sku": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
                "version": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
            },
        },
    }
}
```

**Block Attributes:**
- Type: List with MaxItems: 1
- Optional: true
- ForceNew: true
- ExactlyOneOf: ["os_managed_disk_id", "source_image_id", "source_image_reference"]

**Child Fields (all Required and ForceNew):**
1. `publisher` - Required, ForceNew, StringIsNotEmpty
2. `offer` - Required, ForceNew, StringIsNotEmpty
3. `sku` - Required, ForceNew, StringIsNotEmpty
4. `version` - Required, ForceNew, StringIsNotEmpty

## Azure API Schema

Query: `body.properties.storageProfile.imageReference`

**Result:**
```
ObjectWithOptionalAttrs(map[string]Type{
  "communityGalleryImageId":String, 
  "id":String, 
  "offer":String, 
  "publisher":String, 
  "sharedGalleryImageId":String, 
  "sku":String, 
  "version":String
}, []string{"communityGalleryImageId", "id", "offer", "publisher", "sharedGalleryImageId", "sku", "version"})
```

**Azure API Fields:**
- `publisher` - Optional string
- `offer` - Optional string
- `sku` - Optional string
- `version` - Optional string
- `id` - Optional string (used for regular managed image reference)
- `communityGalleryImageId` - Optional string (used for community gallery images)
- `sharedGalleryImageId` - Optional string (used for shared gallery images)

**Note:** The API schema shows additional fields (`id`, `communityGalleryImageId`, `sharedGalleryImageId`) that are NOT in the Terraform schema. These are handled separately via `source_image_id` argument (Task #35).

## Hidden Fields

### Expand Function Analysis

From `expandSourceImageReference()`:

```go
func expandSourceImageReference(referenceInput []interface{}, imageId string) *virtualmachines.ImageReference {
    if imageId != "" {
        // With Version            : "/communityGalleries/publicGalleryName/images/myGalleryImageName/versions/(major.minor.patch | latest)"
        // Versionless(e.g. latest): "/communityGalleries/publicGalleryName/images/myGalleryImageName"
        if _, errors := validation.Any(validate.CommunityGalleryImageID, validate.CommunityGalleryImageVersionID)(imageId, "source_image_id"); len(errors) == 0 {
            return &virtualmachines.ImageReference{
                CommunityGalleryImageId: pointer.To(imageId),
            }
        }

        // With Version            : "/sharedGalleries/galleryUniqueName/images/myGalleryImageName/versions/(major.minor.patch | latest)"
        // Versionless(e.g. latest): "/sharedGalleries/galleryUniqueName/images/myGalleryImageName"
        if _, errors := validation.Any(validate.SharedGalleryImageID, validate.SharedGalleryImageVersionID)(imageId, "source_image_id"); len(errors) == 0 {
            return &virtualmachines.ImageReference{
                SharedGalleryImageId: pointer.To(imageId),
            }
        }

        return &virtualmachines.ImageReference{
            Id: pointer.To(imageId),
        }
    }

    raw := referenceInput[0].(map[string]interface{})
    return &virtualmachines.ImageReference{
        Publisher: pointer.To(raw["publisher"].(string)),
        Offer:     pointer.To(raw["offer"].(string)),
        Sku:       pointer.To(raw["sku"].(string)),
        Version:   pointer.To(raw["version"].(string)),
    }
}
```

**Analysis:** The expand function has two branches:
1. If `imageId` is provided (handled by `source_image_id` field in Task #35)
2. If `referenceInput` is provided (this block) - uses only the 4 declared fields: publisher, offer, sku, version

**Hidden Fields:** ‚úÖ **NONE** - The expand function uses ONLY the 4 fields declared in the schema when processing `source_image_reference` block.

## Mapping

Terraform (snake_case) ‚Üí Azure API (camelCase):
- `source_image_reference` ‚Üí `imageReference`
- `publisher` ‚Üí `publisher` (no change)
- `offer` ‚Üí `offer` (no change)
- `sku` ‚Üí `sku` (no change)
- `version` ‚Üí `version` (no change)

## Special Handling

### ForceNew
The block itself is ForceNew: true, and all 4 child fields are also ForceNew: true. However, ForceNew is NOT implemented for this skeleton task - it will be handled by each child argument task (#86-#89).

### ExactlyOneOf Constraint
From schema: `ExactlyOneOf: ["os_managed_disk_id", "source_image_id", "source_image_reference"]`

This validation is deferred to Task #26 (os_managed_disk_id) which owns the ExactlyOneOf constraint.

**Deferred Work:** Recorded in `following.md` - Entry already exists:
- Deferred By: #35
- Deferred To: #85
- Type: Validation
- Description: Cross-field validation: source_image_id, os_managed_disk_id, and source_image_reference are mutually exclusive (ExactlyOneOf - must specify exactly one)
- Status: Pending

## Deferred Work Completion

**Check following.md:** Entry exists for work deferred TO this task (#85):

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #35 | #85 | Validation | Cross-field validation: source_image_id, os_managed_disk_id, and source_image_reference are mutually exclusive (ExactlyOneOf - must specify exactly one) | Pending |

**Analysis:** The ExactlyOneOf validation requires all three variables to exist:
- `source_image_id` - exists (Task #35 completed)
- `os_managed_disk_id` - does NOT exist yet (Task #26 pending)
- `source_image_reference` - exists (defined in variables.tf)

**Decision:** This validation CANNOT be implemented yet because `os_managed_disk_id` variable doesn't exist. The validation will be implemented in Task #26 which creates the `os_managed_disk_id` variable.

**Action:** Update following.md to defer this back to Task #26:

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #85 | #26 | Validation | Cross-field validation: source_image_id, os_managed_disk_id, and source_image_reference are mutually exclusive (ExactlyOneOf - must specify exactly one) - deferred because os_managed_disk_id variable doesn't exist yet | Pending |

## Critical Review & Edge Case Analysis

### Null Semantics
- `var.source_image_reference != null` - Block is optional; when null, no imageReference is added to the body
- When block is set, all 4 child fields are Required per provider schema

### Edge Cases
1. **Empty block:** Not possible - all 4 child fields are Required in Terraform schema
2. **Mutual exclusivity:** ExactlyOneOf constraint ensures only one of (os_managed_disk_id, source_image_id, source_image_reference) can be set
3. **Conditional:** The skeleton uses `var.source_image_reference != null ?` to ensure the block is only added when user provides the block

### Idempotency
‚úÖ Conditional check ensures imageReference is only added when source_image_reference is provided

### Safe References
‚úÖ Block-level null check (`var.source_image_reference != null`) prevents accessing undefined properties

## Child Tasks Ready for Delegation

Based on the skeleton structure created, the following child tasks are now **ready for delegation**:

1. **Task #86** - `source_image_reference.offer` (Required argument)
2. **Task #87** - `source_image_reference.publisher` (Required argument)
3. **Task #88** - `source_image_reference.sku` (Required argument)
4. **Task #89** - `source_image_reference.version` (Required argument)

All 4 child tasks can now proceed as the parent block skeleton is in place.

## Checklist

- ‚úÖ Block skeleton created in `migrate_main.tf`
- ‚úÖ Comment placeholders added for all 4 child arguments with correct task numbers
- ‚úÖ Conditional structure: `var.source_image_reference != null ? {...} : {}`
- ‚úÖ Correct path: `body.properties.storageProfile.imageReference`
- ‚úÖ Hidden fields checked - NONE found
- ‚úÖ Deferred work checked - validation deferred back to Task #26
- ‚úÖ Critical review completed
- ‚úÖ Edge case analysis completed
- ‚úÖ Child tasks (#86-#89) ready for delegation
- ‚úÖ Proof document created
- ‚úÖ Self-review: Added ONLY the block skeleton, no individual argument implementations

---

## ‚ö†Ô∏è CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #85 - source_image_reference

### Issues Identified

#### Issue 1: Missing ForceNew Tracking

**Problem:**
The `source_image_reference` block has `ForceNew: true` in the provider schema, but it was not tracked in `replace_triggers_external_values`. This violates executor.md's requirement that all ForceNew fields must be tracked.

**Executor's Implementation:**
```hcl
replace_triggers_external_values = {
  # ... other fields ...
  source_image_id = { value = var.source_image_id }
  # source_image_reference was MISSING here
  timezone = { value = var.timezone }
  # ...
}
```

**Why This Violates executor.md:**
From executor.md lines 206-213:
> **Mode 1 - Direct Value Tracking (schema `ForceNew: true`):**
> Wrap in object to keep key stable. Track actual field value changes.
> 
> **üö® CRITICAL - Track FULL Value, Not Presence:**
> - ‚úÖ **CORRECT:** `field = { value = var.field }` - Tracks the ENTIRE value (primitives, objects, lists)

**Provider's Actual Behavior:**
From provider schema (proof document lines 90-100):
```go
func sourceImageReferenceSchemaVM() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,  // ‚Üê Block itself is ForceNew
        MaxItems: 1,
        // ...
    }
}
```

**Expected Behavior:**
- Any change to `source_image_reference` block should trigger VM replacement
- Setting the block (null ‚Üí object) should trigger replacement
- Changing any field within the block should trigger replacement
- Removing the block (object ‚Üí null) should trigger replacement

**Root Cause:**
Executor correctly created the block skeleton and identified ForceNew in the proof document (lines 230-231), but failed to implement the ForceNew tracking in `replace_triggers_external_values` as required by executor.md.

### Corrections Made

#### Fix 1: Added ForceNew Tracking

**Changed Files:**
- `migrate_main.tf`: Added `source_image_reference` entry to `replace_triggers_external_values`

**New Implementation:**
```hcl
replace_triggers_external_values = {
  # ... other fields ...
  source_image_id                             = { value = var.source_image_id }
  source_image_reference                      = { value = var.source_image_reference }  # ‚Üê ADDED
  timezone                                    = { value = var.timezone }
  # ...
}
```

**Why This is EXACT:**
1. **Tracks full block value:** The object type tracks all 4 fields (publisher, offer, sku, version) together
2. **Stable key:** The key `source_image_reference` is always present in the map
3. **Null handling:** When `var.source_image_reference` is null, the value is null, which is tracked correctly
4. **Change detection:** Any modification to the block (null ‚Üí object, object ‚Üí null, or any internal field change) will be detected
5. **Follows Mode 1:** Uses `{ value = var.field }` pattern as prescribed for schema-level ForceNew

**Verification:**
- Scenario 1: `null` ‚Üí `{publisher="...", offer="...", sku="...", version="..."}` ‚Üí Replacement triggered ‚úÖ
- Scenario 2: `{...}` ‚Üí `null` ‚Üí Replacement triggered ‚úÖ
- Scenario 3: `{publisher="old"}` ‚Üí `{publisher="new"}` ‚Üí Replacement triggered ‚úÖ
- Scenario 4: Block unchanged ‚Üí No replacement ‚úÖ

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:

‚úÖ **Block Skeleton:** Correctly created with conditional structure and comment placeholders
‚úÖ **ForceNew Logic:** Block-level ForceNew now tracked in `replace_triggers_external_values`
‚úÖ **Stable Keys:** Key always present in the map
‚úÖ **Phase Detection:** Block correctly placed in `local.body` (Create phase)
‚úÖ **Path Verification:** Correct path `body.properties.storageProfile.imageReference`
‚úÖ **Hidden Fields:** None found (verified from expand function)
‚úÖ **Validations:** ExactlyOneOf validation properly deferred to Task #26
‚úÖ **Deferred Work Completion:** Correctly handled - validation deferred back to Task #26
‚úÖ **Deferred Work Recording:** Properly updated in `following.md`
‚úÖ **Edge Cases:** Null semantics and mutual exclusivity properly analyzed

**Status:** CORRECTED AND APPROVED ‚úÖ

---
