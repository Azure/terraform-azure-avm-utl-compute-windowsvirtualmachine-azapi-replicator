# Task #78: plan.product Argument Implementation

## Summary
Implemented the `plan.product` argument as a Required field within the plan block. The field is ForceNew and maps directly to the Azure API's plan.product property at the root level of the VirtualMachine resource.

## Shadow Implementation

```hcl
locals {
  replace_triggers_external_values = {
    # ... existing fields ...
    plan_product = { value = var.plan != null ? var.plan.product : null }  # <-
  }
  
  body = merge(
    {
      properties = merge(
        # ... existing properties ...
      )
    },
    # ... existing root-level fields ...
    var.plan != null ? {
      plan = {
        name = var.plan.name
        product = var.plan.product  # <-
        # publisher = ... # Task #79
      }
    } : {}
  )
}
```

## Create Phase Verification

**Query Create Method:**

From Task #76 and #77 documentation, the Create method shows:

```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ...
  planRaw := d.Get("plan").([]interface{})
  plan := expandPlan(planRaw)
  
  // ...
  params := virtualmachines.VirtualMachine{
    Name:             pointer.To(id.VirtualMachineName),
    ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
    Location:         location.Normalize(d.Get("location").(string)),
    Identity:         identityExpanded,
    Plan:             plan,  // <-- Assigned to Plan field at root of VirtualMachine
    Properties: &virtualmachines.VirtualMachineProperties{
      // ... properties ...
    },
    Tags: tags.Expand(t),
  }
  // ...
  if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
  }
  // ...
}
```

**Pattern:** Single-phase creation. The `plan` field (including `plan.product`) is assigned during the primary `CreateOrUpdateThenPoll` operation.

**Classification:** This field is set before the primary create operation → belongs in `local.body`.

**Decision:** Implement in `local.body.plan.product` at root level (not inside properties).

## Assignment Path Verification

**Predicted Path:** `body.plan.product`

**Go Code Evidence:**

```go
// From expandPlan function:
func expandPlan(input []interface{}) *virtualmachines.Plan {
  if len(input) == 0 || input[0] == nil {
    return nil
  }

  raw := input[0].(map[string]interface{})

  return &virtualmachines.Plan{
    Name:      pointer.To(raw["name"].(string)),
    Product:   pointer.To(raw["product"].(string)),  // <-- Maps "product" field
    Publisher: pointer.To(raw["publisher"].(string)),
  }
}

// In resourceWindowsVirtualMachineCreate:
planRaw := d.Get("plan").([]interface{})
plan := expandPlan(planRaw)  // <-- Returns *virtualmachines.Plan

params := virtualmachines.VirtualMachine{
  Plan: plan,  // <-- Direct assignment to Plan field at VirtualMachine struct root
  Properties: &virtualmachines.VirtualMachineProperties{
    // ...
  },
}
```

**Struct Assignment Trace:**
1. `raw["product"].(string)` extracts the product value from Terraform config
2. `pointer.To(raw["product"].(string))` creates pointer to string
3. Assigned to `Plan.Product` field in returned struct
4. The `Plan` struct is assigned directly to `params.Plan` (not `params.Properties.Plan`)
5. `params` is of type `virtualmachines.VirtualMachine`
6. The `Plan` field is at the root level of the VirtualMachine struct, not inside Properties

**Verified Path:** `body.plan.product` (root level, NOT `body.properties.plan.product`)

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

**Go Source (planSchema function):**

```go
func planSchema() *pluginsdk.Schema {
  return &pluginsdk.Schema{
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
      Schema: map[string]*pluginsdk.Schema{
        "name": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
        "product": {
          Type:     pluginsdk.TypeString,
          Required: true,  // <-- Required field
          ForceNew: true,  // <-- ForceNew field
        },
        "publisher": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
      },
    },
  }
}
```

**Key Schema Properties:**
- **Type:** String
- **Required:** true
- **ForceNew:** true
- **Validations:** None found in provider source code

## Azure API Schema

**Query Result:**
From Task #76 documentation:

```
"plan": ObjectWithOptionalAttrs(map[string]Type{
  "name": String,
  "product": String,
  "promotionCode": String,
  "publisher": String
}, []string{"name", "product", "promotionCode", "publisher"})
```

**Property Path:** `body.plan.product`

**Field Type:** String

**Note:** All fields in the Azure API plan object are optional, but the provider enforces Required on name, product, and publisher. The provider does not expose the `promotionCode` field.

## Hidden Fields

**Expand Function Analysis:**

```go
func expandPlan(input []interface{}) *virtualmachines.Plan {
  if len(input) == 0 || input[0] == nil {
    return nil
  }

  raw := input[0].(map[string]interface{})

  return &virtualmachines.Plan{
    Name:      pointer.To(raw["name"].(string)),
    Product:   pointer.To(raw["product"].(string)),
    Publisher: pointer.To(raw["publisher"].(string)),
  }
}
```

**Hidden Fields Found:** None

The expand function directly maps the three schema fields (name, product, publisher) without adding any hidden/hardcoded values. The Azure API's `promotionCode` field is not set by the provider.

## Mapping

**Terraform → Azure API:**
- `plan.product` (string) → `plan.product` (string)

**Naming:** Direct mapping, no transformation needed (already camelCase in both).

## Special Handling

### ForceNew

**Provider Schema:** 
- The entire `plan` block is `ForceNew: true`
- The `plan.product` field is also `ForceNew: true`

**Implementation:**

Since `plan.product` is a Required field within an Optional block, I track it with a null-safe accessor:

```hcl
replace_triggers_external_values = {
  plan_product = { value = var.plan != null ? var.plan.product : null }
}
```

**Rationale:**
- When `var.plan == null`: The plan object doesn't exist, so plan_product trigger is null
- When `var.plan != null`: The plan.product field is guaranteed to exist (Required), so we track its value
- Changes to the product value will trigger replacement
- The key "plan_product" is always present (stable key pattern)

### Update Behavior

**Update Method Analysis:**

From Task #77 documentation, the Update method was checked for plan field references:

```go
func resourceWindowsVirtualMachineUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ... extensive update logic ...
  // NO MENTION of "plan" field anywhere
  // ...
}
```

**Finding:** The plan field is NOT mentioned in the Update method at all. This confirms that plan is ForceNew-only and cannot be updated in-place.

**Validation:** No update-time validations or restrictions found for plan.product.

## Deferred Work Completion

**Check following.md:**
No work was deferred to Task #78 in the following.md file.

## Edge Case Analysis

### Null Semantics
- **When `var.plan == null`:** The entire plan block is omitted from body (via empty map merge), and plan_product in replace_triggers is null
- **When `var.plan != null`:** The product field is Required (cannot be null/empty), so `var.plan.product` will always have a value
- **Terraform Validation:** The Required constraint on product ensures it's set when plan block is defined

### Boundary Conditions
- **Empty String:** The provider schema has no minimum length validation, so an empty string is technically allowed
- **Special Characters:** No character restrictions found in provider source
- **Unicode:** String type supports Unicode characters
- **Case Sensitivity:** No case normalization in expand function, so case-sensitive comparison

### Idempotency
- **Value Tracking:** The ForceNew trigger tracks the full value of `var.plan.product`
- **No Transformation:** Direct assignment without any transformation ensures idempotent behavior
- **Stable Key:** The "plan_product" key in replace_triggers is always present

### Safe References
- **Null Check:** `var.plan != null` check ensures safe access to `var.plan.product` in body
- **ForceNew Guard:** `var.plan != null ? var.plan.product : null` safely handles null plan in replace_triggers
- **No Nested Access:** Direct access to `.product` property (one level deep, safe)

### Azure API Compatibility
- **Direct Mapping:** The value is passed directly to Azure API without transformation
- **Type Match:** String to String mapping (exact type match)
- **No Hidden Fields:** Only the three provider-exposed fields are sent (name, product, publisher)

## Validation

**Provider Schema Validations:** None found

**Cross-Field Validations:** None found

The provider schema for `plan.product` has:
- `Required: true` - enforced by Terraform's type system when plan block is present
- `ForceNew: true` - implemented via replace_triggers_external_values
- No custom validation functions
- No ConflictsWith/RequiredWith/AtLeastOneOf constraints

Since the field is Required within the plan block, and the plan block itself is validated by Terraform's type system, no additional validations are needed in variables.tf.

## Checklist

- ✅ Property in correct local (body.plan.product at root level, not in properties)
- ✅ ForceNew tracked: `plan_product = { value = var.plan != null ? var.plan.product : null }`
- ✅ ALL logic EXACTLY replicated from provider (direct value assignment, no transformations)
- ✅ Validations reviewed: None required (Required constraint handled by Terraform type system)
- ✅ Hidden fields checked: None found in expandPlan function
- ✅ Deferred work in following.md: Not applicable (no deferring in this task)
- ✅ Deferred work from following.md: None deferred to Task #78
- ✅ Critical review: Null-safe access, stable keys, direct mapping
- ✅ Edge Case Analysis: Documented null semantics, boundary conditions, idempotency
- ✅ Proof created
- ✅ track.md ready to update to "Pending for check"
- ✅ Self-Review: Only plan.product implementation added, no other fields added

## Implementation Verification

**Files Modified:**
1. `migrate_main.tf`:
   - Added `plan_product` to `replace_triggers_external_values` with stable key pattern
   - Replaced comment placeholder with `product = var.plan.product` in plan block

**Files NOT Modified:**
- `variables.tf` - plan variable already exists with correct structure
- `migrate_variables.tf` - no new variables needed
- `migrate_validation.tf` - no validations needed

**Scope Verification:**
- ✅ Only implemented plan.product (this task)
- ✅ Did NOT modify plan.name (Task #77 - already completed)
- ✅ Did NOT implement plan.publisher (Task #79 - pending)
- ✅ Did NOT add any hidden fields
- ✅ Did NOT add fields from other tasks

## Final Notes

This implementation EXACTLY replicates the provider behavior:
1. Direct value mapping from `var.plan.product` to `body.plan.product`
2. ForceNew tracking via replace_triggers with stable key pattern
3. Null-safe access using conditional check on parent block
4. No validations (relies on Terraform's Required type constraint)
5. No transformations or modifications to the value

The implementation follows Type 4 (Block Argument) task rules from executor.md:
- Parent skeleton verified (created by Task #76)
- Schema queried and analyzed
- Create phase verified (single-phase, primary operation)
- Assignment path traced and verified
- ForceNew implemented with stable keys
- Comment placeholder replaced in skeleton
- No sensitive handling needed (not marked sensitive)
- Edge cases analyzed
- Proof document created

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #78 - plan.product

### Validation Results

✅ **ForceNew Logic:** Correctly implemented with stable key pattern - tracks FULL value using `{ value = var.plan != null ? var.plan.product : null }`
✅ **Stable Keys:** Key "plan_product" is always present in replace_triggers_external_values
✅ **Phase Detection:** Field correctly placed in local.body.plan.product (root level, not in properties)
✅ **Type Conversion:** Direct string-to-string mapping (no conversion needed)
✅ **Null Handling:** Correctly propagates null semantics with null-safe accessor
✅ **Validations:** None required - Required constraint enforced by Terraform type system
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled (null semantics, boundary conditions, idempotency, safe references)
✅ **Assignment Path:** Correctly verified at body.plan.product (root level), not in properties
✅ **Merge Pattern:** No shared path conflicts - plan block appears only once
✅ **Implementation Scope:** Only plan.product implemented - no scope creep

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The implementation:
- Maps value directly from var.plan.product to body.plan.product without transformation
- Implements ForceNew with stable key pattern and full value tracking
- Uses null-safe conditional accessor for parent block
- Correctly places field at root level (not in properties)
- Follows all executor.md rules for Type 4 (Block Argument) tasks

**Status:** APPROVED ✅

---
