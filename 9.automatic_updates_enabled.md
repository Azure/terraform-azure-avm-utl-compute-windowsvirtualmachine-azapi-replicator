# Task #9: automatic_updates_enabled - Implementation Proof

## Summary

Implemented `automatic_updates_enabled` as a root-level boolean argument that maps to `properties.osProfile.windowsConfiguration.enableAutomaticUpdates` in the Azure API. The field defaults to `true` and has `ForceNew: true` as updating this field is not allowed by Azure API. The field is only included when osProfile exists.

## Shadow Implementation

```hcl
# variables.tf
variable "automatic_updates_enabled" {
  type        = bool
  default     = true         # <-
  nullable    = false        # <-
  description = "(Optional) Specifies if Automatic Updates are Enabled for the Windows Virtual Machine. Changing this forces a new resource to be created. Defaults to `true`."
}

# migrate_main.tf
locals {
  replace_triggers_external_values = {
    # ... other fields ...
    automatic_updates_enabled  = { value = var.automatic_updates_enabled }  # <-
  }
  
  body = {
    properties = merge(
      # ... other properties ...
      var.admin_username != null ? {
        osProfile = merge(
          {
            adminUsername = var.admin_username
          },
          {
            allowExtensionOperations = var.allow_extension_operations
          },
          {
            windowsConfiguration = {
              enableAutomaticUpdates = var.automatic_updates_enabled  # <-
            }
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

**Query Result**: Queried `resourceWindowsVirtualMachineCreate` function.

**Pattern Identification**: Single-phase creation pattern - the field is set during the primary `CreateOrUpdateThenPoll` operation.

**Go Code Evidence**:
```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	
	if !osDiskIsImported {
		// ...
		
		autoUpdatesEnabled := true

		if !d.GetRawConfig().AsValueMap()["automatic_updates_enabled"].IsNull() {
			autoUpdatesEnabled = d.Get("automatic_updates_enabled").(bool)
		}

		if !features.FivePointOh() {
			// reconcile the 2 bools...
			if !d.GetRawConfig().AsValueMap()["enable_automatic_updates"].IsNull() {
				autoUpdatesEnabled = d.Get("enable_automatic_updates").(bool)
			}
		}

		params.Properties.OsProfile = &virtualmachines.OSProfile{
			AdminPassword:            pointer.To(d.Get("admin_password").(string)),
			AdminUsername:            pointer.To(d.Get("admin_username").(string)),
			ComputerName:             pointer.To(computerName),
			AllowExtensionOperations: pointer.To(allowExtensionOperations),
			WindowsConfiguration: &virtualmachines.WindowsConfiguration{
				ProvisionVMAgent:       pointer.To(provisionVMAgent),
				EnableAutomaticUpdates: pointer.To(autoUpdatesEnabled),  // <-- Field assigned here
				WinRM:                  expandWinRMListener(d.Get("winrm_listener").(*pluginsdk.Set).List()),
			},
			Secrets: secrets,
		}
		
		// ...
	}
	
	// ...
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Windows %s: %+v", id, err)
	}
}
```

**Classification**: The field is assigned during the Create phase as part of the primary resource creation (before the single `CreateOrUpdateThenPoll` call). It belongs in `local.body`.

**Decision**: Implement in `local.body.properties.osProfile.windowsConfiguration.enableAutomaticUpdates`.

## Assignment Path Verification

**Predicted Path**: `properties.osProfile.windowsConfiguration.enableAutomaticUpdates`

**Go Code Evidence - Assignment Chain**:
1. Field read: `autoUpdatesEnabled := d.Get("automatic_updates_enabled").(bool)` (with default `true`)
2. Assigned to struct: `params.Properties.OsProfile.WindowsConfiguration.EnableAutomaticUpdates = pointer.To(autoUpdatesEnabled)`
3. Where `params` is `virtualmachines.VirtualMachine` with struct:
   - `Properties` → `*virtualmachines.VirtualMachineProperties`
   - `Properties.OsProfile` → `*virtualmachines.OSProfile`
   - `Properties.OsProfile.WindowsConfiguration` → `*virtualmachines.WindowsConfiguration`
   - `Properties.OsProfile.WindowsConfiguration.EnableAutomaticUpdates` → `*bool`

**Verified Path**: `properties.osProfile.windowsConfiguration.enableAutomaticUpdates`

**Path Comparison**: ✅ Predicted path matches verified path.

## Provider Schema

**Source**: `resourceWindowsVirtualMachine()` schema definition in azurerm provider

```go
"automatic_updates_enabled": {
	Type:     pluginsdk.TypeBool,
	Optional: true,
	Computed: true,
	ForceNew: true, // updating this is not allowed "Changing property 'windowsConfiguration.enableAutomaticUpdates' is not allowed." Target="windowsConfiguration.enableAutomaticUpdates"
	ConflictsWith: []string{
		"os_managed_disk_id",
	},
},
```

**Key Properties**:
- **Type**: `TypeBool`
- **Optional**: `true`
- **Computed**: `true`
- **Default**: Not explicitly set in schema (handled in Create logic as `true`)
- **ForceNew**: `true` - updating is not allowed by Azure API
- **Validation**: None
- **ConflictsWith**: `os_managed_disk_id` (deferred to Task #26)

**ForceNew Explanation**: The comment in the schema explicitly states: `updating this is not allowed "Changing property 'windowsConfiguration.enableAutomaticUpdates' is not allowed." Target="windowsConfiguration.enableAutomaticUpdates"`

This means Azure API does not allow updating this field after VM creation, so it must trigger ForceNew.

## Azure API Schema

**Resource Type**: `Microsoft.Compute/virtualMachines@2024-03-01`

**Property Path**: `body.properties.osProfile.windowsConfiguration.enableAutomaticUpdates`

**Type**: `Bool`

**Description**: "Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is true. For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning."

**Note**: The description mentions that this can be updated for virtual machine scale sets, but for regular virtual machines (which is what we're implementing), the provider schema correctly marks it as `ForceNew: true`.

## Hidden Fields

None identified for this field.

## Mapping

| AzureRM Field | Azure API Field | Notes |
|---------------|----------------|-------|
| `automatic_updates_enabled` | `enableAutomaticUpdates` | Boolean field in windowsConfiguration |

**Naming Convention**: snake_case → camelCase

## Special Handling

### 1. Default Value

**Provider Behavior**: 
```go
autoUpdatesEnabled := true

if !d.GetRawConfig().AsValueMap()["automatic_updates_enabled"].IsNull() {
	autoUpdatesEnabled = d.Get("automatic_updates_enabled").(bool)
}
```

The provider defaults to `true` when the field is not specified.

**Implementation**: Added `default = true` and `nullable = false` to the variable definition in `variables.tf`.

**Rationale**: Since this is a root-level argument with a computed default, we must set both `default = true` AND `nullable = false` according to executor.md rules for top-level arguments with defaults.

### 2. ForceNew Behavior

**Provider Schema**: `ForceNew: true` with comment: `updating this is not allowed "Changing property 'windowsConfiguration.enableAutomaticUpdates' is not allowed." Target="windowsConfiguration.enableAutomaticUpdates"`

**Update Method Evidence**: Checking the Update method shows NO handling for `automatic_updates_enabled` changes - the field is completely absent from the Update function. This confirms that changes to this field are not supported through updates.

**Implementation**: Added to `replace_triggers_external_values`:
```hcl
automatic_updates_enabled = { value = var.automatic_updates_enabled }
```

**Rationale**: The field has `ForceNew: true` in the schema. Any change to this field must trigger resource replacement. Using Mode 1 (Direct Value Tracking) - wrapped in object to keep key stable and track actual boolean value changes.

### 3. Conditional Inclusion in osProfile

**Provider Behavior**: The field is only included when `osProfile` is created (i.e., when not using `os_managed_disk_id`). The field is inside `WindowsConfiguration` within `OsProfile`.

**Implementation**: The field is nested within the `windowsConfiguration` object which is merged into the `osProfile` object, which itself is conditionally created when `var.admin_username != null`:
```hcl
var.admin_username != null ? {
  osProfile = merge(
    {
      adminUsername = var.admin_username
    },
    {
      allowExtensionOperations = var.allow_extension_operations
    },
    {
      windowsConfiguration = {
        enableAutomaticUpdates = var.automatic_updates_enabled
      }
    }
  )
} : {}
```

This ensures the field is only included when an osProfile is being created.

### 4. Deprecated Field: enable_automatic_updates

**Provider Behavior**: The provider has a deprecated field `enable_automatic_updates` that conflicts with `automatic_updates_enabled`. In the Create method, the provider reconciles both fields:

```go
if !features.FivePointOh() {
	// reconcile the 2 bools...
	if !d.GetRawConfig().AsValueMap()["enable_automatic_updates"].IsNull() {
		autoUpdatesEnabled = d.Get("enable_automatic_updates").(bool)
	}
}
```

However, this is only relevant for provider versions before 5.0 and the schema includes `ConflictsWith` validation to prevent both fields from being set simultaneously.

**Implementation**: We only implement `automatic_updates_enabled` as it's the current, non-deprecated field. The deprecated field `enable_automatic_updates` will be handled in its own task (#63 per track.md).

## Deferred Work Completion

Checked `following.md` - no deferred work found for Task #9.

**Deferred Work**: Cross-field validation with `os_managed_disk_id` (ConflictsWith) is deferred to Task #26 as documented in following.md.

## Critical Review & Edge Case Analysis

### Null Semantics
- **When `null`**: Not applicable since we set `nullable = false` and `default = true`. The field always has a value.
- **When `true`**: Automatic updates are enabled (default behavior)
- **When `false`**: Automatic updates are disabled

### Boundary Conditions
- **Boolean field**: Only two states: `true` or `false`
- **ForceNew**: Any change triggers replacement

### Idempotency
✅ **Idempotent**: Boolean value is deterministic and does not depend on order or timing.

### Safe References
✅ **Safe**: Direct boolean value reference, no nested access required.

### Edge Cases

1. **Case: `automatic_updates_enabled = true` (default)**
   - **Result**: Field set to `true` in API, automatic updates enabled
   - **ForceNew**: No (first creation)

2. **Case: `automatic_updates_enabled = false`**
   - **Result**: Field set to `false` in API, automatic updates disabled
   - **ForceNew**: No (first creation)

3. **Case: Changing from `true` to `false`**
   - **Result**: Triggers ForceNew, resource replaced with new value
   - **Reason**: Azure API does not allow updating this field

4. **Case: Changing from `false` to `true`**
   - **Result**: Triggers ForceNew, resource replaced with new value
   - **Reason**: Azure API does not allow updating this field

5. **Case: osProfile not created (os_managed_disk_id used)**
   - **Handled**: Field is not included in body since windowsConfiguration merge is conditional on `admin_username != null`
   - **ConflictsWith**: Validation deferred to Task #26

6. **Case: Field value stays the same across applies**
   - **Result**: No ForceNew triggered, `replace_triggers_external_values` key value remains unchanged
   - **Correct**: Only actual value changes trigger replacement

### Stability of replace_triggers_external_values Key

✅ **Key Stability**: The `automatic_updates_enabled` key is always present in `replace_triggers_external_values` map:
```hcl
automatic_updates_enabled = { value = var.automatic_updates_enabled }
```

The key never appears/disappears because:
- The variable has `default = true` and `nullable = false`
- The value always exists (either user-provided or default)
- The wrapping object `{ value = ... }` ensures the key is stable

This prevents unnecessary replacements when the field's presence changes (which it never does).

## Checklist

- ✅ Property in correct local (`local.body.properties.osProfile.windowsConfiguration`)
- ✅ ForceNew handling: Added to `replace_triggers_external_values` with stable key wrapping
- ✅ Default value replicated (`default = true`, `nullable = false`)
- ✅ All logic exactly replicated from provider:
  - ✅ Default to `true` when not specified
  - ✅ ForceNew behavior (field cannot be updated, must replace)
  - ✅ Conditional inclusion when osProfile exists
  - ✅ Nested within windowsConfiguration
- ✅ Validations implemented: None required (no provider validations, ConflictsWith deferred)
- ✅ Hidden fields checked: None found
- ✅ Deferred work: None in following.md for this task; ConflictsWith validation deferred to Task #26
- ✅ Critical review performed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Proof document created
- ✅ Self-Review: Only `automatic_updates_enabled` field implemented, no content from other tasks
- ✅ Track.md will be updated to `Pending for check`

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #9 - automatic_updates_enabled

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew with schema `ForceNew: true`. Correctly implemented using Mode 1 (Direct Value Tracking) with stable key wrapping `{ value = var.automatic_updates_enabled }`.

✅ **Stable Keys:** The `automatic_updates_enabled` key in `replace_triggers_external_values` is always present (variable has `default = true` and `nullable = false`), ensuring key stability across applies.

✅ **Phase Detection:** Field correctly placed in `local.body` as it's assigned during the Create phase before the single `CreateOrUpdateThenPoll` operation.

✅ **Type Conversion:** Direct boolean-to-boolean mapping, no conversion needed.

✅ **Null Handling:** Correctly prevents null values with `nullable = false` and provides `default = true`, exactly matching provider behavior where the field defaults to `true` when not specified.

✅ **Validations:** No validations required for this field. ConflictsWith validation with `os_managed_disk_id` properly deferred to Task #26 and documented in both proof and `following.md`.

✅ **Default Value Implementation:** Correctly implements root-level argument default with BOTH `default = true` AND `nullable = false` as mandated by executor.md for top-level arguments with defaults.

✅ **Assignment Path:** Verified path `properties.osProfile.windowsConfiguration.enableAutomaticUpdates` matches provider implementation. Field correctly nested within windowsConfiguration object and conditionally included when osProfile exists.

✅ **Shared Path Merge:** No duplicate parent keys found in any merge statements. Each key (hardwareProfile, networkProfile, osProfile, and within osProfile: adminUsername, allowExtensionOperations, windowsConfiguration) appears only once at its respective level.

✅ **Deferred Work Completion:** No deferred work for this task in `following.md`. Verification complete.

✅ **Deferred Work Recording:** ConflictsWith validation properly deferred to Task #26 and documented in proof document.

✅ **Edge Cases:** All edge cases properly analyzed and handled:
- Boolean value changes correctly trigger ForceNew
- Field only included when osProfile exists (conditional on admin_username)
- Stable key prevents unnecessary replacements
- Default value behavior matches provider exactly

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The implementation follows all mandatory rules including:
- Root-level default with `nullable = false`
- ForceNew with stable key wrapping
- Proper conditional inclusion within osProfile
- Exact assignment path matching provider
- Complete proof documentation with all required sections

**Status:** APPROVED ✅

---
