# Task #61 - additional_unattend_content.setting - COMPLETED

## Summary

Implemented the `setting` argument within the `additional_unattend_content` block, which specifies the name of the Windows unattended setup setting. The field is Required, ForceNew, and accepts only two enum values: "AutoLogon" or "FirstLogonCommands". Implementation includes validation in variables.tf and mapping to the API's `settingName` field within the sensitive_body array structure.

## Shadow Implementation

```hcl
# variables.tf
variable "additional_unattend_content" {  # <-
  type = list(object({  # <-
    content = string  # <-
    setting = string  # <-
  }))  # <-
  default     = null  # <-
  description = <<-EOT  # <-
 - `content` - (Required) The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.  # <-
 - `setting` - (Required) The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.  # <-
EOT  # <-

  validation {  # <-
    condition = var.additional_unattend_content == null || alltrue([  # <-
      for item in var.additional_unattend_content : contains(["AutoLogon", "FirstLogonCommands"], item.setting)  # <-
    ])  # <-
    error_message = "Each setting value must be either 'AutoLogon' or 'FirstLogonCommands'."  # <-
  }  # <-
}  # <-

# migrate_main.tf
locals {
  sensitive_body = {  # <-
    properties = (var.admin_password != null || var.custom_data != null || (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0)) ? {  # <-
      osProfile = merge(  # <-
        # ... other sensitive fields ...  # <-
        (var.additional_unattend_content != null && length(var.additional_unattend_content) > 0) ? {  # <-
          windowsConfiguration = {  # <-
            additionalUnattendContent = [  # <-
              for item in var.additional_unattend_content : {  # <-
                content       = item.content  # <-
                settingName   = item.setting  # <-
                passName      = "OobeSystem"  # <-
                componentName = "Microsoft-Windows-Shell-Setup"  # <-
              }  # <-
            ]  # <-
          }  # <-
        } : {}  # <-
      )  # <-
    } : {}  # <-
  }  # <-
}
```

## Create Phase Verification

**Query Result:** Queried the Create method for `azurerm_windows_virtual_machine`.

**Pattern Identified:** Single-phase creation pattern.

**Go Code Evidence:**

From Create method:
```go
additionalUnattendContentRaw := d.Get("additional_unattend_content").([]interface{})
additionalUnattendContent := expandAdditionalUnattendContent(additionalUnattendContentRaw)

// ... later in the code ...

if len(additionalUnattendContentRaw) > 0 {
    params.Properties.OsProfile.WindowsConfiguration.AdditionalUnattendContent = additionalUnattendContent
}
```

From expand function:
```go
func expandAdditionalUnattendContent(input []interface{}) *[]virtualmachines.AdditionalUnattendContent {
	output := make([]virtualmachines.AdditionalUnattendContent, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		output = append(output, virtualmachines.AdditionalUnattendContent{
			SettingName: pointer.To(virtualmachines.SettingNames(raw["setting"].(string))),
			Content:     pointer.To(raw["content"].(string)),

			// no other possible values
			PassName:      pointer.To(virtualmachines.PassNamesOobeSystem),
			ComponentName: pointer.To(virtualmachines.ComponentNamesMicrosoftNegativeWindowsNegativeShellNegativeSetup),
		})
	}

	return &output
}
```

**Decision:** The field is assigned directly within the primary `CreateOrUpdate` call. The `setting` field is read from `raw["setting"]` and mapped to `SettingName` in the API struct. Since the parent array is in `sensitive_body` (due to the `content` field being Sensitive), this field is also placed in `sensitive_body`.

## Assignment Path Verification

**Predicted Path:** `sensitive_body.properties.osProfile.windowsConfiguration.additionalUnattendContent[*].settingName`

**Go Code Evidence:**

From expand function showing field mapping:
```go
output = append(output, virtualmachines.AdditionalUnattendContent{
    SettingName: pointer.To(virtualmachines.SettingNames(raw["setting"].(string))),
    // ...
})
```

The struct assignment chain:
1. `params` is `virtualmachines.VirtualMachine`
2. `params.Properties` is `*virtualmachines.VirtualMachineProperties`
3. `params.Properties.OsProfile` is `*virtualmachines.OSProfile`
4. `params.Properties.OsProfile.WindowsConfiguration` is `*virtualmachines.WindowsConfiguration`
5. `params.Properties.OsProfile.WindowsConfiguration.AdditionalUnattendContent` is `*[]virtualmachines.AdditionalUnattendContent`
6. Each array element has `SettingName` field of type `*virtualmachines.SettingNames` (which is a string type alias)

From Create method (line 183):
```go
params.Properties.OsProfile.WindowsConfiguration.AdditionalUnattendContent = additionalUnattendContent
```

**Verified Path:** `body.properties.osProfile.windowsConfiguration.additionalUnattendContent[*].settingName` (moved to `sensitive_body` due to list-based sensitive field pattern)

**Path Comparison:** ✅ MATCH - The verified path matches the predicted path. The entire array is in `sensitive_body` because `content` is Sensitive.

## Provider Schema

**Query Result:**

From schema query:
```json
{
  "nesting_mode": "list",
  "block": {
    "attributes": {
      "content": {
        "type": "string",
        "description_kind": "plain",
        "required": true,
        "sensitive": true
      },
      "setting": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      }
    },
    "description_kind": "plain"
  }
}
```

From detailed schema function:
```go
"setting": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ForceNew: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachines.SettingNamesAutoLogon),
        string(virtualmachines.SettingNamesFirstLogonCommands),
    }, false),
},
```

From Go SDK constants:
```go
SettingNamesAutoLogon          SettingNames = "AutoLogon"
SettingNamesFirstLogonCommands SettingNames = "FirstLogonCommands"
```

**Field Properties:**
- **Type:** String (enum type)
- **Required:** Yes
- **Sensitive:** No (unlike `content`, this field is not sensitive)
- **ForceNew:** Yes (from detailed schema: `ForceNew: true`)
- **Validation:** `StringInSlice` with values `["AutoLogon", "FirstLogonCommands"]`
- **ConflictsWith:** Inherited from parent block - `["os_managed_disk_id"]`

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachines`

**API Version:** `2024-03-01`

**Property Path:** `body.properties.osProfile.windowsConfiguration.additionalUnattendContent[*].settingName`

**Schema Type:** 
```
List(ObjectWithOptionalAttrs(map[string]Type{
  "componentName": String, 
  "content": String, 
  "passName": String, 
  "settingName": String
}, []string{"componentName", "content", "passName", "settingName"}))
```

**Field in API:** The API schema shows `settingName` as an optional string field within the array objects. However, the provider enforces it as required with specific enum values.

## Hidden Fields

No hidden fields for this specific argument. The hidden fields (`passName` and `componentName`) were documented and implemented in Task #59 (block skeleton).

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**

- `additional_unattend_content[*].setting` → `additionalUnattendContent[*].settingName`

Note: The provider reads from `raw["setting"]` and assigns to `SettingName` in the API struct.

## Special Handling

### ForceNew Behavior

**Provider Schema:** `ForceNew: true` is explicitly set in the schema.

**Block-Level ForceNew:** The entire `additional_unattend_content` block is marked as ForceNew in the schema function:
```go
ForceNew: true,
// whilst the SDK supports updating, the API doesn't:
//   Code="PropertyChangeNotAllowed"
//   Message="Changing property 'windowsConfiguration.additionalUnattendContent' is not allowed."
//   Target="windowsConfiguration.additionalUnattendContent
```

**Implementation:** Since the parent array is Sensitive and ForceNew, version tracking was implemented in Task #60. The `additional_unattend_content_version` variable covers changes to ALL fields within the block, including `setting`. No separate ForceNew handling is needed for this individual field.

**Natural Detection:** Changes to `item.setting` values will be detected as part of the array structure change in `sensitive_body`, and the version variable will trigger replacement when incremented.

### Validation - StringInSlice

**Provider Validation:** The provider uses `validation.StringInSlice` to restrict values to:
- `"AutoLogon"` (constant: `virtualmachines.SettingNamesAutoLogon`)
- `"FirstLogonCommands"` (constant: `virtualmachines.SettingNamesFirstLogonCommands`)

**Implementation:** Added validation block to `variables.tf`:
```hcl
validation {
  condition = var.additional_unattend_content == null || alltrue([
    for item in var.additional_unattend_content : contains(["AutoLogon", "FirstLogonCommands"], item.setting)
  ])
  error_message = "Each setting value must be either 'AutoLogon' or 'FirstLogonCommands'."
}
```

**Why This is EXACT:**
- Uses `alltrue()` with `for` loop to validate each item in the list
- Uses `contains()` to check against exact values from provider
- Handles null list case (skips validation when list is null)
- Error message matches the provider's validation constraint
- Case-sensitive matching (no case folding like some other fields)

### List-Based Sensitive Field Pattern

**Context:** The parent array `additionalUnattendContent` is placed in `sensitive_body` because it contains the Sensitive field `content`. Per executor.md:
> "When sensitive field is inside a list (without MaxItems: 1), the entire array must exist in EITHER body OR sensitive_body—never split."

**Implementation Impact:** Even though `setting` itself is NOT Sensitive, it must be in `sensitive_body` because it's part of the same array structure as the Sensitive `content` field. Splitting the array between `body` and `sensitive_body` would cause merge conflicts.

## Deferred Work Completion

**Checked `following.md`:** No deferred work found for Task #61.

## Edge Case Analysis

### Null Semantics
- `var.additional_unattend_content == null`: Entire block omitted, no validation runs
- `var.additional_unattend_content == []`: Entire block omitted (length check fails in parent), no validation runs
- `item.setting`: Required field in object type, always present when list has items

### Boundary Conditions
1. **Empty string:** Validation will fail - not in allowed values list
2. **Case sensitivity:** Validation is case-sensitive (must match exactly "AutoLogon" or "FirstLogonCommands")
3. **Invalid values:** Validation catches any value not in the enum list at plan time
4. **Whitespace:** Provider doesn't trim, validation matches exact strings

### Validation Edge Cases
- **Null list:** Validation condition `var.additional_unattend_content == null` returns true, skipping validation ✅
- **Empty list:** Not validated (length check in parent excludes it from API payload) ✅
- **Single item:** Validated correctly via `alltrue()` with single-element iteration ✅
- **Multiple items:** Each item validated independently via `for` loop ✅
- **Mixed valid/invalid:** If ANY item has invalid setting, validation fails (correct behavior) ✅

### Idempotent Behavior
- ✅ Enum value passed without modification
- ✅ No normalization or case transformation applied
- ✅ Provider converts string to SDK enum type exactly as provided
- ✅ Order-dependent list structure preserved (same as content field)

### Safe Reference Checks
- ✅ List existence checked before iteration: `var.additional_unattend_content != null && length(...) > 0`
- ✅ Field access: `item.setting` safe because setting is Required in object type (not nullable)
- ✅ Validation: `alltrue([for item...])` handles empty list gracefully (returns true for empty list)

## Critical Review

### Null Meaning
- **Parent list `null`**: Block not configured - omit from API payload, skip validation
- **Parent list `[]`**: Empty list - omit from API payload (length check), skip validation
- **Field value**: Always present (Required field in object type), never null

### Boundary Conditions
1. **Enum validation:** Catches invalid values at plan time before API call ✅
2. **Case sensitivity:** Validation matches provider's case-sensitive behavior ✅
3. **Type safety:** String type enforced by Terraform's type system ✅

### Idempotent Behavior
- ✅ String value passed as-is to API (no transformations)
- ✅ SDK enum type conversion is deterministic (same string → same enum)
- ✅ Order preserved in array (same position = same semantics)

### Safe Reference Checks
- ✅ List null check before validation: `var.additional_unattend_content == null || ...`
- ✅ Field access safe: `item.setting` always exists (Required field)
- ✅ Validation loop handles edge cases: empty list, single item, multiple items

## Checklist

- ✅ Property in correct local (sensitive_body for list-based sensitive field pattern)
- ✅ ForceNew behavior: Covered by parent array version tracking (Task #60)
- ✅ EXACT replication of provider behavior (enum validation, mapping, ForceNew)
- ✅ Validation IMPLEMENTED in variables.tf (StringInSlice with exact enum values)
- ✅ No hidden fields for this argument
- ✅ No deferred work in following.md
- ✅ Critical review completed
- ✅ Edge Case Analysis completed
- ✅ Proof created
- ✅ Ready to update track.md to "Pending for check"
- ✅ Self-review: Only `setting` field implemented, completes Task #61

## Self-Review

**Did I add ONLY what my task requires?** ✅ YES
- Implemented only the `setting` field by replacing the comment placeholder
- Added validation for the `setting` field values
- Did NOT modify any other fields or blocks
- Did NOT add any content from other tasks

**Did I add things that belong to other tasks?** ❌ NO
- The `content` field was already implemented by Task #60
- Hidden fields (`passName`, `componentName`) were already in place from Task #59
- Version tracking was already implemented by Task #60
- No modifications to unrelated code

**Did I follow executor.md rules?** ✅ YES
- Validation added to `variables.tf` (not deferred to Azure API)
- EXACT replication of provider's StringInSlice validation
- ForceNew handled via parent array version tracking (no separate handling needed)
- Field placed in `sensitive_body` following list-based sensitive field pattern
- No "more conservative" or "simpler" approaches - exact provider behavior replicated

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #61 - additional_unattend_content.setting

### Validation Results

✅ **ForceNew Logic:** Block-level ForceNew correctly handled via parent array version tracking (Task #60)
✅ **Stable Keys:** All keys in sensitive_body structure are stable
✅ **Phase Detection:** Field correctly placed in sensitive_body (Create phase)
✅ **Type Conversion:** Correct conversion from Terraform string to Azure API settingName (string)
✅ **Null Handling:** Correctly propagates null semantics with parent list checks
✅ **Validations:** StringInSlice validation EXACTLY replicated in variables.tf with alltrue() and contains()
✅ **List-Based Sensitive Pattern:** Entire array correctly placed in sensitive_body (not split)
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Edge Cases:** All edge cases properly analyzed and handled (null, empty list, enum validation, case sensitivity)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The validation logic matches the provider's `StringInSlice` validator precisely with case-sensitive enum checking for "AutoLogon" and "FirstLogonCommands". The field is correctly placed within the list-based sensitive field pattern, following the rule that entire arrays containing sensitive fields must reside in sensitive_body. ForceNew behavior is appropriately handled through the parent array's version tracking mechanism established in Task #60. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
