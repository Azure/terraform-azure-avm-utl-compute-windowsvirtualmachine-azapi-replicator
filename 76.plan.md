# Task #76: plan Block Structure Skeleton

## Summary
Created structure skeleton for `plan` block at root level of body (not inside properties). The block has three required child arguments (name, product, publisher) that will be implemented by Tasks #77, #78, and #79.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... existing properties ...
      )
    },
    # ... existing root-level fields ...
    var.plan != null ? {  # <-
      plan = {  # <-
        # name = ... # Task #77  # <-
        # product = ... # Task #78  # <-
        # publisher = ... # Task #79  # <-
      }  # <-
    } : {}  # <-
  )
}
```

## Create Phase Verification

**Query Create Method:**
```go
func resourceWindowsVirtualMachineCreate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ...
  planRaw := d.Get("plan").([]interface{})
  plan := expandPlan(planRaw)
  
  // ...
  params := virtualmachines.VirtualMachine{
    Name:             pointer.To(id.VirtualMachineName),
    ExtendedLocation: expandEdgeZone(d.Get("edge_zone").(string)),
    Location:         location.Normalize(d.Get("location").(string)),
    Identity:         identityExpanded,
    Plan:             plan,  // <-- Assigned to Plan field at root of VirtualMachine
    Properties: &virtualmachines.VirtualMachineProperties{
      // ... properties ...
    },
    Tags: tags.Expand(t),
  }
  // ...
  if err := client.CreateOrUpdateThenPoll(ctx, id, params, virtualmachines.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Windows %s: %+v", id, err)
  }
  // ...
}
```

**Pattern:** Single-phase creation. The `plan` field is assigned during the primary `CreateOrUpdateThenPoll` operation.

**Classification:** This field is set before the primary create operation → belongs in `local.body` (not post-creation).

**Decision:** Implement in `local.body` at root level (not inside properties).

## Assignment Path Verification

**Predicted Path:** `body.plan`

**Go Code Evidence:**
```go
// In resourceWindowsVirtualMachineCreate:
planRaw := d.Get("plan").([]interface{})
plan := expandPlan(planRaw)

params := virtualmachines.VirtualMachine{
  Plan: plan,  // <-- Direct assignment to Plan field at VirtualMachine struct root
  Properties: &virtualmachines.VirtualMachineProperties{
    // ...
  },
}
```

**Struct Assignment Trace:**
1. `expandPlan` returns `*virtualmachines.Plan`
2. Assigned directly to `params.Plan` (not `params.Properties.Plan`)
3. `params` is of type `virtualmachines.VirtualMachine`
4. The `Plan` field is at the root level of the VirtualMachine struct, not inside Properties

**Verified Path:** `body.plan` (root level, NOT `body.properties.plan`)

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

**Go Source (planSchema function):**
```go
func planSchema() *pluginsdk.Schema {
  return &pluginsdk.Schema{
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
      Schema: map[string]*pluginsdk.Schema{
        "name": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
        "product": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
        "publisher": {
          Type:     pluginsdk.TypeString,
          Required: true,
          ForceNew: true,
        },
      },
    },
  }
}
```

**Key Schema Properties:**
- **Type:** List (MaxItems: 1)
- **Optional:** true
- **ForceNew:** true (entire block)
- **Child Fields:** All three fields (name, product, publisher) are Required and ForceNew

## Azure API Schema

**Query Result:**
```
body.plan: ObjectWithOptionalAttrs(map[string]Type{
  "name": String,
  "product": String,
  "promotionCode": String,
  "publisher": String
}, []string{"name", "product", "promotionCode", "publisher"})
```

**Property Path:** `body.plan` (root level, not inside properties)

**Note:** Azure API has an additional field `promotionCode` that is not exposed in the provider schema. The provider only maps: name, product, publisher.

## Hidden Fields

**Expand Function Analysis:**
```go
func expandPlan(input []interface{}) *virtualmachines.Plan {
  if len(input) == 0 || input[0] == nil {
    return nil
  }

  raw := input[0].(map[string]interface{})

  return &virtualmachines.Plan{
    Name:      pointer.To(raw["name"].(string)),
    Product:   pointer.To(raw["product"].(string)),
    Publisher: pointer.To(raw["publisher"].(string)),
  }
}
```

**Hidden Fields Found:** None

The expand function only maps the three schema fields (name, product, publisher) without adding any hidden/hardcoded values. The Azure API field `promotionCode` is not set by the provider.

## Mapping

**Terraform → Azure API:**
- `plan` (block) → `plan` (object at root level)
- Child fields (name, product, publisher) will be mapped by their respective tasks

## Special Handling

### ForceNew
**Provider Schema:** The entire `plan` block is `ForceNew: true`, and all three child fields are also `ForceNew: true`.

**Implementation:** ForceNew handling will be implemented by the individual child argument tasks (#77, #78, #79), not at the block level. Each child argument will track its value in `replace_triggers_external_values`.

### Block Structure
**Pattern:** Single-item list converted to optional object
```hcl
var.plan != null ? {
  plan = {
    # Child arguments will be added here by Tasks #77-79
  }
} : {}
```

### Conditional Logic
The block is created only when `var.plan != null`. This matches the provider's expand function behavior which returns `nil` when input is empty or nil.

## Child Tasks Ready for Delegation

The following child tasks are now ready to be delegated:

- **Task #77:** `plan.name` - Required argument
- **Task #78:** `plan.product` - Required argument  
- **Task #79:** `plan.publisher` - Required argument

All three child tasks can be executed in parallel since they have no dependencies on each other.

## Edge Case Analysis

**Null Semantics:**
- When `var.plan == null`: The plan object is omitted from body (empty map merged)
- When `var.plan != null`: The plan object is created with child fields

**Idempotency:**
- Block-level condition (`var.plan != null`) is stable
- Child argument values will be handled by individual tasks

**Safe References:**
- Check `var.plan != null` before accessing child fields
- Child tasks will safely reference `var.plan.name`, `var.plan.product`, `var.plan.publisher` since the parent condition ensures plan is non-null

**Azure API Compatibility:**
- Provider does not set `promotionCode` field
- Only three fields are mapped: name, product, publisher
- This matches the provider schema exactly

## Checklist

- ✅ Skeleton structure created in `migrate_main.tf`
- ✅ Conditional logic added: `var.plan != null ? { plan = { ... } } : {}`
- ✅ Comment placeholders for child arguments (Tasks #77-79)
- ✅ Root-level placement verified (body.plan, not body.properties.plan)
- ✅ Hidden fields checked in expand function (none found)
- ✅ ForceNew noted (handled by child tasks)
- ✅ Create phase verified (single-phase, primary create)
- ✅ Assignment path traced and verified
- ✅ Child tasks identified and listed in proof
- ✅ Edge cases analyzed
- ✅ Proof document created
- ✅ Ready to update track.md status to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-24
**Task:** #76 - plan

### Validation Results

✅ **Block Structure:** Correctly implemented as Type 3 (Block Structure Skeleton)
✅ **Placement:** Root level of body (body.plan), NOT inside properties - verified with Go code evidence
✅ **Conditional Logic:** Correct pattern `var.plan != null ? { plan = { ... } } : {}` matches provider's expandPlan nil handling
✅ **Stable Keys:** Key "plan" is always present at merge level (no conditional key appearance)
✅ **Comment Placeholders:** All three child argument placeholders present (Tasks #77, #78, #79)
✅ **Phase Detection:** Correctly identified as Create phase (single-phase, primary CreateOrUpdateThenPoll)
✅ **Assignment Path:** Traced and verified - direct assignment to `params.Plan` at VirtualMachine struct root
✅ **Hidden Fields:** Expand function checked - no hidden fields found (only maps name, product, publisher)
✅ **ForceNew Logic:** Correctly deferred to child argument tasks (standard pattern for Type 3)
✅ **Merge Structure:** No shared path violations - "plan" appears only once at body merge level
✅ **Deferred Work Completion:** No deferred work for Task #76 in following.md
✅ **Edge Cases:** Null semantics correctly analyzed (nil when plan is null, object when non-null)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The skeleton follows Type 3 task rules:
- Creates conditional structure only (no field values)
- Places comment placeholders for child arguments
- Defers ForceNew handling to child tasks
- Verifies correct nesting level (root, not properties)
- Checks expand function for hidden fields (none found)

The implementation is at the correct structural level (body.plan at root), matching the Go code evidence showing `Plan` is a field of `virtualmachines.VirtualMachine` struct, not inside Properties.

**Status:** APPROVED ✅

---
